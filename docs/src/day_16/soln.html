<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport"
	content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Day 16: Packet Decoder :: Advent of Code 2021</title>
        <link rel="prev" href="../day_15/soln">
        <link rel="next" href="../day_17/soln">
    <meta name="generator" content="Antora 3.1.2">
<link rel="stylesheet" href="../../_/css/site.css" />
<link rel="stylesheet" href="../../_/css/code-syntax-highlight.css" />
<link rel="stylesheet" href="https://use.typekit.net/fnd4xvj.css" />
<link rel="stylesheet" href="https://iosevka-rltb.pages.dev/dist/iosevka-rltb-mono/iosevka-rltb-mono-cloudflare.css">
<meta name="theme-color" content="#0970c4" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#0967b4" media="(prefers-color-scheme: dark)">
<script>var uiRootPath = '../../_';</script>
<link rel="icon" type="image/x-icon" href="../../favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
</head>

<body class="article">
  <header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">Advent of Code 2021</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable open-left">
          <span class="navbar-link">Links</span>
          <div class="navbar-dropdown">
            <a class="navbar-item navbar-external-link" href="https://github.com/rben01" target="_blank">
              <div class="site-logo github-logo github-repo-logo"></div><span class="site-url">/&nbsp;rben01</span>
            </a>
          </div>
        </div>
          <div class="navbar-item search hide-for-print">
            <div id="search-field" class="field">
              <input id="search-input" type="text" placeholder="Search this site">
            </div>
          </div>
      </div>
    </div>
  </nav>
</header>
<svg xmlns="http://www.w3.org/2000/svg" id="icon-mask-container" width="0" height="0">
	<defs>
		<clipPath id="icon-github" clipPathUnits="objectBoundingBox">
			<path transform="scale(0.0102040816)" fill-rule="evenodd" clip-rule="evenodd"
				d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z">
			</path>
		</clipPath>
		<clipPath id="icon-menu-clippath" clipPathUnits="objectBoundingBox">
			<circle cx=".1" cy=".1575" r=".06"></circle>
			<path d="M.325 .1175h.65 v.08h-.65z"></path>
			<circle cx=".25" cy=".4775" r=".06"></circle>
			<path d="M.475 .4375h.5 v.08h-.5z"></path>
			<circle cx=".25" cy=".7975" r=".06"></circle>
			<path d="M.475 .7575h.5 v.08h-.5z"></path>
		</clipPath>
		<clipPath id="icon-external-link" clipPathUnits="objectBoundingBox">
			<path transform="translate(.5 .5) scale(0.0017) translate(-256 -256)"
				d="M320 0c-17.7 0-32 14.3-32 32s14.3 32 32 32h82.7L201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L448 109.3V192c0 17.7 14.3 32 32 32s32-14.3 32-32V32c0-17.7-14.3-32-32-32H320zM80 32C35.8 32 0 67.8 0 112V432c0 44.2 35.8 80 80 80H400c44.2 0 80-35.8 80-80V320c0-17.7-14.3-32-32-32s-32 14.3-32 32V432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16H192c17.7 0 32-14.3 32-32s-14.3-32-32-32H80z" />
		</clipPath>
		<clipPath id="icon-star" clipPathUnits="objectBoundingBox">
			<path transform="translate(0 0.075) scale(0.001736)"
				d="M316.9 18C311.6 7 300.4 0 288.1 0s-23.4 7-28.8 18L195 150.3 51.4 171.5c-12 1.8-22 10.2-25.7 21.7s-.7 24.2 7.9 32.7L137.8 329 113.2 474.7c-2 12 3 24.2 12.9 31.3s23 8 33.8 2.3l128.3-68.5 128.3 68.5c10.8 5.7 23.9 4.9 33.8-2.3s14.9-19.3 12.9-31.3L438.5 329 542.7 225.9c8.6-8.5 11.7-21.2 7.9-32.7s-13.7-19.9-25.7-21.7L381.2 150.3 316.9 18z" />
		</clipPath>
	</defs>
	<symbol viewBox="0 0 100 100" id="icon-back" class="svg-icon-template">
		<path
			d="m 50.000978,9.89975 -40.1010516,40.10025 40.1010516,40.10025 5.6556,-5.65551 -30.434757,-30.44194 h 64.878253 v -8.0056 H 25.221821 l 30.434757,-30.44001 z" />
	</symbol>
	<symbol viewBox="0 0 30 30" id="icon-caret" class="svg-icon-template">
		<path d="m 10.18745,2.9998 14.0001,12.0002 -14.0001,12.0001 z" stroke-width="2" stroke-linecap="round"
			stroke-linejoin="round" />
	</symbol>
	<symbol viewBox="0 0 30 30" id="icon-chevron">
		<path
			d="M 3.6699219,6.5898438 1.4550781,8.6152344 15,23.374272 28.544922,8.6152344 26.330078,6.5898438 15,18.759498 Z" />
	</symbol>
	<symbol viewBox="0 0 16 16" id="icon-clipboard">
		<path fill-rule="evenodd"
			d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z" />
	</symbol>
	<symbol viewBox="0 0 1 1" id="icon-home-filled" class="svg-icon-template icon-home">
		<path
			d="M.5002 .10747572875253811 L.10042786437626905 .4662178643762691 l.02671524585077328 .029770717813528465 l.06725688977295768 -.060354082044552726 v.44845 h.25506 v-.25166 H.5505 v.25166 h.25506 v-.44845 l.06725688977295768 .060354082044552726 l.02671524585077328 -.029770717813528465 l-.154812135623731 -.13892322952293115 V.1 h-.12657 V.21371495268001076 z" />
	</symbol>
	<symbol viewBox="0 0 1 1" id="icon-home-outline" class="svg-icon-template icon-home">
		<path
			d="M.5002 .10747572875253811 L.10042786437626905 .4662178643762691 l.02671524585077328 .029770717813528465 l.06725688977295768 -.060354082044552726 v.44845 h.25506 v-.25166 H.5505 v.25166 h.25506 v-.44845 l.06725688977295768 .060354082044552726 l.02671524585077328 -.029770717813528465 l-.154812135623731 -.13892322952293115 V.1 h-.12657 V.21371495268001076 z v.0565685424949238 L.65815 .30578331524901864 V.14 H.70472 V.2910051322295775 L.65815 .2492147727540948 v.0565685424949238 L.76556 .40216945463621206 V.8440845001452447 h-.17166 v-.25166 H.40946 v.25166 h-.17166 V.40216945463621206 L.5002 .16404427124746193 z " />
	</symbol>
	<symbol viewBox="0 0 1 1" id="icon-menu">
		<circle cx=".1" cy=".1575" r=".06"></circle>
		<path d="M.325 .1175h.65 v.08h-.65z"></path>
		<circle cx=".25" cy=".4775" r=".06"></circle>
		<path d="M.475 .4375h.5 v.08h-.5z"></path>
		<circle cx=".25" cy=".7975" r=".06"></circle>
		<path d="M.475 .7575h.5 v.08h-.5z"></path>
	</symbol>
</svg>
  <div class="body">
	<div class="nav-container"  data-component="ROOT"
  data-version="" >
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-explore is-active" data-panel="explore">
  <div class="context">
    <span class="title">Navigation</span>
    <span class="nav-explore-expander">
      <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon" viewBox="0 0 1 1">
        <title>Discloure chevron</title>
        <use href="#icon-chevron"></use>
      </svg>
    </span>
  </div>
  <ul class="components">
      <li
        class="component is-current">
          <a class="title" href="../../">Solutions</a>
            <ul class="nav-list">
      <li class="nav-item is-active"
        data-depth="0">
        <span
          class="nav-item-expander clickable">
        </span>
          <ul class="nav-list">
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_01/soln">Day 1: Sonar Sweep</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_02/soln">Day 2: Dive!</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_03/soln">Day 3: Binary Diagnostic</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_04/soln">Day 4: Giant Squid</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_05/soln">Day 5: Hydrothermal Venture</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_06/soln">Day 6: Lanternfish</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_07/soln">Day 7: The Treachery of Whales</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_08/soln">Day 8: Seven Segment Search</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_09/soln">Day 9: Smoke Basin</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_10/soln">Day 10: Syntax Scoring</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_11/soln">Day 11: Dumbo Octopus</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_12/soln">Day 12: Passage Pathing</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_13/soln">Day 13: Transparent Origami</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_14/soln">Day 14: Extended Polymerization</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_15/soln">Day 15: Chiton</a>
        </span>
              </li>
      <li class="nav-item is-active is-current-page"
        data-depth="1">
        <span
          class="nav-item-expander final-depth">
              <span class="nav-text">Day 16: Packet Decoder</span>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_17/soln">Day 17: Trick Shot</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_18/soln">Day 18: Snailfish</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_19/soln">Day 19: Beacon Scanner</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_20/soln">Day 20: Trench Map</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_21/soln">Day 21: Dirac Dice</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_22/soln">Day 22: Reactor Reboot</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_23/soln">Day 23: Amphipod</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_24/soln">Day 24: Arithmetic Logic Unit</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_25/soln">Day 25: Sea Cucumber</a>
        </span>
              </li>
  </ul>
      </li>
  </ul>
      </li>
  </ul>
</div>
    </div>
  </aside>
</div>
	<main class="article">
  <div class="toolbar" role="navigation">
  <button class="nav-toggle">
	<svg class="svg-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1">
		<title>Show or hide menu</title>
		<use class="icon-menu" href="#icon-menu"></use>
		<use class="icon-back" href="#icon-back"></use>
	</svg>
</button>
    <a href="../../" class="home-link" title="Home">
      <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon icon-home" viewBox="0 0 1 1">
        <title>Home</title>
        <use class="icon-home icon-home-filled" href="#icon-home-filled"></use>
        <use class="icon-home icon-home-outline" href="#icon-home-outline"></use>
      </svg>
    </a>
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li>&#47;</li> 
          <li>
              <a href="../../">Solutions</a>

          </li>
        <li>&#47;</li>
        <li><span>Day 16: Packet Decoder</span></li>
    </ul>
</nav>
  </div>
  <div class="content">
      <aside class="toc sidebar" data-title="Contents"
  data-levels="2">
  <div class="toc-menu"></div>
</aside>
      <article class="doc">
	<div class="title-container">
			<h1 class="page">Day 16: Packet Decoder</h1>
	</div>
	<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/16" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day #16 problem description</a> │ <a href="/_attachments/src/day_16/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>Dear lord, this problem was brutal.
It consisted of roughly three parts:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parse a hex string into a binary string by parsing each hex character into a quartet — trivial</p>
</li>
<li>
<p>(Part 1) Parse this binary string into a tree of packets according to rules set out in the problem statement — “easy” in the sense that I wrote up an <em>almost</em> correct solution in no time at all.
Very very hard in the sense that it required precise bookkeeping and it took forever for me to get it all exactly correct.
But from a theoretical standpoint it wasn&#8217;t really that hard.</p>
</li>
<li>
<p>(Part 2) Evaluate the packet tree as an expression tree (more or less like parsing S-expressions) — easy.</p>
</li>
</ol>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_setup"><a class="anchor" href="#_setup"></a>Setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main function here is <code>Binary::as_packets</code>.
There&#8217;s a lot to unpack here, but roughly the algorithm is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Maintain a cursor into the original data</p>
</li>
<li>
<p>Maintain a stack of parse states, which consist of:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>The depth in the parse tree</p>
</li>
<li>
<p>The length of remaining data for this packet.
Packets tell us how much data they expect; when there isn&#8217;t any left, we head back up a level in the tree.
So we have to track how much of their data we&#8217;ve consumed so far.
This “amount of data” quantity comes in two flavors:</p>
<div class="openblock">
<div class="content">
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Number of bits that the children comprise</p>
</li>
<li>
<p>Number of direct children, i.e., number of child packets</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>One tricky bit is that packets share bits-remaining with their children.
In other words, if a child consumes some bits from the input, so have all of its ancestors that count their data in bits.
(Packets that are expecting a fixed number of child packets are unaffected when their descendants consume data.)
In either case, if the current packet has no more data remaining — 0 bits or 0 child packets — continue on to the next parse state on the stack.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Looking at the data beginning at the cursor, parse the stream into a single packet.</p>
</li>
<li>
<p>Advance the cursor the number of bits this packet consumed.</p>
</li>
<li>
<p>If this packet was an operator, increment the depth, as its children will follow. Otherwise the depth remains unchanged.</p>
</li>
<li>
<p>Push a new parse state onto the stack, containing the incremented depth and the length of remaining data for this packet.</p>
</li>
<li>
<p>If this packet was the last of its parent&#8217;s children, decrement the depth.</p>
</li>
</ol>
</div>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">// tag::setup[]
use crate::{utils::to_big_decimal, Answer};
use std::fmt::{Display, Write};

type Number = i64;

struct Binary(Vec&lt;bool&gt;);

impl Binary {
	fn from_hex(s: &amp;str) -&gt; Option&lt;Self&gt; {
		let mut binary = Vec::with_capacity(s.len() * 4);
		for c in s.trim().chars() {
			let n = c.to_digit(16)?;
			let digits = [3, 2, 1, 0usize].map(|place| ((1 &lt;&lt; place) &amp; n) != 0);
			binary.extend_from_slice(&amp;digits);
		}

		Some(Self(binary))
	}
}

impl Display for Binary {
	fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
		for &amp;digit in &amp;self.0 {
			let c = if digit { '1' } else { '0' };
			f.write_char(c)?;
		}
		Ok(())
	}
}

impl Binary {
	fn as_packets(&amp;self) -&gt; Vec&lt;Packet&gt; {
		#[derive(Debug)]
		enum RemainingData {
			NBits(usize),
			NPackets(usize),
		}

		impl RemainingData {
			fn is_empty(&amp;self) -&gt; bool {
				matches!(self, RemainingData::NBits(0) | RemainingData::NPackets(0))
			}
		}

		#[derive(Debug)]
		struct ParseState {
			depth: usize,
			remaining: RemainingData,
		}

		let mut packets = vec![];

		let orig_data = &amp;self.0;
		let header_length = 6;
		let mut cursor = 0;
		let mut stack = vec![ParseState {
			depth: 0,
			remaining: RemainingData::NPackets(1),
		}];

		while let Some(parse_state) = stack.pop() {
			let ParseState { depth, remaining } = parse_state;

			if remaining.is_empty() {
				continue;
			}

			let packet_bits = &amp;orig_data[cursor..];

			let version_number = to_big_decimal(&amp;packet_bits[0..3]);
			let kind_number = to_big_decimal(&amp;packet_bits[3..6]);
			let data_bits = &amp;packet_bits[header_length..];

			let parent_packet_length = match remaining {
				RemainingData::NBits(n) =&gt; RemainingData::NBits(n),
				RemainingData::NPackets(n) =&gt; RemainingData::NPackets(n - 1),
			};
			stack.push(ParseState {
				depth,
				remaining: parent_packet_length,
			});

			let packet;
			let n_bits_consumed;
			match kind_number {
				4 =&gt; {
					let chunk_size = 5;
					let mut bin_bits = vec![];

					let mut n_chunks = 0;
					for chunk in data_bits.chunks_exact(5) {
						n_chunks += 1;
						bin_bits.extend_from_slice(&amp;chunk[1..]);
						if !chunk[0] {
							break;
						}
					}

					let value = i64::try_from(to_big_decimal(bin_bits)).unwrap();

					n_bits_consumed = header_length + n_chunks * chunk_size;
					packet = Packet {
						version_number,
						kind: PacketKind::Literal { value },
						depth,
					};
				}
				op =&gt; {
					let op_data_length;
					let n_bits_for_length;

					let length_type = data_bits[0];
					if length_type {
						// length in packets
						n_bits_for_length = 12;
						let n_packets =
							usize::try_from(to_big_decimal(&amp;data_bits[1..n_bits_for_length]))
								.unwrap();
						op_data_length = RemainingData::NPackets(n_packets);
					} else {
						// length in bits
						n_bits_for_length = 16;
						let n_bits =
							usize::try_from(to_big_decimal(&amp;data_bits[1..n_bits_for_length]))
								.unwrap();
						op_data_length = RemainingData::NBits(n_bits);
					};

					n_bits_consumed = header_length + n_bits_for_length;
					// A hack; we're going to subtract n_bits_consumed from this later
					// despite the fact that in theory we shouldn't (because the newly added
					// packet hasn't consumed any data yet), so we we pre-add n_bits_consumed
					// here so that when we subtract it later we end up with the right number
					// of bits
					let op_data_length = match op_data_length {
						RemainingData::NBits(n) =&gt; RemainingData::NBits(n + n_bits_consumed),
						rd @ RemainingData::NPackets(_) =&gt; rd,
					};

					packet = Packet {
						version_number,
						kind: PacketKind::Operator { op: op.into() },
						depth,
					};

					stack.push(ParseState {
						depth: depth + 1,
						remaining: op_data_length,
					});
				}
			};

			cursor += n_bits_consumed;

			for ps in &amp;mut stack {
				if let RemainingData::NBits(n) = &amp;mut ps.remaining {
					if *n &gt; 0 {
						// The hack above is to counteract this subtraction; if we just pushed
						// a RemainingData::NumBits, we won't actually have consumed any of
						// its input yet
						//
						// If our code has no bugs, and the input is trustworthy, this will
						// never underflow.
						*n -= n_bits_consumed;
					}
				}
			}

			packets.push(packet);
		}

		packets
	}
}

#[derive(Debug)]
enum PacketKind {
	Literal { value: Number },
	Operator { op: Operation }, // Defined in pt2
}

#[derive(Debug)]
struct Packet {
	version_number: u64,
	kind: PacketKind,
	depth: usize,
}

fn read_input(input: &amp;str) -&gt; Vec&lt;Packet&gt; {
	let b = Binary::from_hex(input).unwrap();
	b.as_packets()
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;u64, Number&gt; {
	let p = read_input(input);
	(16, (pt1(&amp;p), pt2(&amp;p).unwrap())).into()
}

pub fn ans() -&gt; Answer&lt;u64, Number&gt; {
	ans_for_input(include_str!("input.txt"))
}
// end::setup[]

// tag::pt1[]
fn pt1(packets: &amp;[Packet]) -&gt; u64 {
	packets.iter().map(|packet| packet.version_number).sum()
}
// end::pt1[]

// tag::pt2[]
#[derive(Debug)]
enum Reducer {
	Sum,
	Product,
	Min,
	Max,
}

impl Reducer {
	fn identity(&amp;self) -&gt; Number {
		use Reducer::*;
		match self {
			Sum =&gt; 0,
			Product =&gt; 1,
			Min =&gt; Number::MAX,
			Max =&gt; Number::MIN,
		}
	}

	fn combine(&amp;self, x: Number, y: Number) -&gt; Number {
		use Reducer::*;
		match self {
			Sum =&gt; x + y,
			Product =&gt; x * y,
			Min =&gt; x.min(y),
			Max =&gt; x.max(y),
		}
	}
}

#[derive(Debug)]
enum Comparitor {
	Gt,
	Lt,
	Eq,
}

impl Comparitor {
	fn apply(&amp;self, x: Number, y: Number) -&gt; Number {
		use Comparitor::*;
		i64::from(match self {
			Gt =&gt; x &gt; y,
			Lt =&gt; x &lt; y,
			Eq =&gt; x == y,
		})
	}
}

#[derive(Debug)]
enum Operation {
	Reduce(Reducer),
	Compare(Comparitor),
}

impl From&lt;u64&gt; for Operation {
	fn from(n: u64) -&gt; Self {
		use Comparitor::*;
		use Operation::*;
		use Reducer::*;
		match n {
			0 =&gt; Reduce(Sum),
			1 =&gt; Reduce(Product),
			2 =&gt; Reduce(Min),
			3 =&gt; Reduce(Max),
			5 =&gt; Compare(Gt),
			6 =&gt; Compare(Lt),
			7 =&gt; Compare(Eq),
			_ =&gt; unreachable!(),
		}
	}
}

fn pt2(packets: &amp;[Packet]) -&gt; Option&lt;Number&gt; {
	struct Arg {
		depth: usize,
		value: Number,
	}
	let mut arg_stack = vec![];

	for Packet {
		kind: packet_kind,
		depth: packet_depth,
		..
	} in packets.iter().rev()
	{
		let packet_depth = *packet_depth;

		match packet_kind {
			&amp;PacketKind::Literal { value } =&gt; arg_stack.push(Arg {
				depth: packet_depth,
				value,
			}),
			PacketKind::Operator { op } =&gt; {
				use Operation::*;
				let value = match op {
					Reduce(reducer) =&gt; {
						let mut result = reducer.identity();
						while let Some(arg @ Arg { depth, value }) = arg_stack.pop() {
							if depth &lt;= packet_depth {
								arg_stack.push(arg); // oops, went too far
								break;
							}
							result = reducer.combine(result, value);
						}
						result
					}
					Compare(comparitor) =&gt; {
						let Arg { value: first, .. } = arg_stack.pop()?;
						let Arg { value: second, .. } = arg_stack.pop()?;

						comparitor.apply(first, second)
					}
				};

				arg_stack.push(Arg {
					depth: packet_depth,
					value,
				});
			}
		}
	}

	Some(arg_stack.first()?.value)
}
// end::pt2[]

#[cfg(test)]
mod test {
	use super::*;
	use crate::test_input;

	#[test]
	fn test() {
		#[track_caller]
		fn test_pt1(in_str: &amp;str, pt1_val: u64) {
			test_input!(&amp;read_input(in_str), pt1: pt1_val);
		}

		#[track_caller]
		fn test_pt2(in_str: &amp;str, pt2_val: Number) {
			test_input!(&amp;read_input(in_str), pt2: Some(pt2_val));
		}

		// pt1 only
		test_pt1("D2FE28", 6);
		test_pt1("8A004A801A8002F478", 16);
		test_pt1("620080001611562C8802118E34", 12);
		test_pt1("C0015000016115A2E0802F182340", 23);
		test_pt1("A0016C880162017C3686B18A3D4780", 31);
		test_pt1(include_str!("input.txt"), 927);

		// pt2 only
		test_pt2("D2FE28", 2021);
		test_pt2("C200B40A82", 3);
		test_pt2("04005AC33890", 54);
		test_pt2("880086C3E88112", 7);
		test_pt2("CE00C43D881120", 9);
		test_pt2("D8005AC2A8F0", 1);
		test_pt2("F600BC2D8F", 0);
		test_pt2("9C005AC2F8F0", 0);
		test_pt2("9C0141080250320F1802104A08", 1);
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_part_1"><a class="anchor" href="#_part_1"></a>Part 1</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Part 1 just asks us to compute some summary data of all the packets in the parse tree.
As long as we have the right packets (regardless of their depths) we&#8217;ll get the right answer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">// tag::setup[]
use crate::{utils::to_big_decimal, Answer};
use std::fmt::{Display, Write};

type Number = i64;

struct Binary(Vec&lt;bool&gt;);

impl Binary {
	fn from_hex(s: &amp;str) -&gt; Option&lt;Self&gt; {
		let mut binary = Vec::with_capacity(s.len() * 4);
		for c in s.trim().chars() {
			let n = c.to_digit(16)?;
			let digits = [3, 2, 1, 0usize].map(|place| ((1 &lt;&lt; place) &amp; n) != 0);
			binary.extend_from_slice(&amp;digits);
		}

		Some(Self(binary))
	}
}

impl Display for Binary {
	fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
		for &amp;digit in &amp;self.0 {
			let c = if digit { '1' } else { '0' };
			f.write_char(c)?;
		}
		Ok(())
	}
}

impl Binary {
	fn as_packets(&amp;self) -&gt; Vec&lt;Packet&gt; {
		#[derive(Debug)]
		enum RemainingData {
			NBits(usize),
			NPackets(usize),
		}

		impl RemainingData {
			fn is_empty(&amp;self) -&gt; bool {
				matches!(self, RemainingData::NBits(0) | RemainingData::NPackets(0))
			}
		}

		#[derive(Debug)]
		struct ParseState {
			depth: usize,
			remaining: RemainingData,
		}

		let mut packets = vec![];

		let orig_data = &amp;self.0;
		let header_length = 6;
		let mut cursor = 0;
		let mut stack = vec![ParseState {
			depth: 0,
			remaining: RemainingData::NPackets(1),
		}];

		while let Some(parse_state) = stack.pop() {
			let ParseState { depth, remaining } = parse_state;

			if remaining.is_empty() {
				continue;
			}

			let packet_bits = &amp;orig_data[cursor..];

			let version_number = to_big_decimal(&amp;packet_bits[0..3]);
			let kind_number = to_big_decimal(&amp;packet_bits[3..6]);
			let data_bits = &amp;packet_bits[header_length..];

			let parent_packet_length = match remaining {
				RemainingData::NBits(n) =&gt; RemainingData::NBits(n),
				RemainingData::NPackets(n) =&gt; RemainingData::NPackets(n - 1),
			};
			stack.push(ParseState {
				depth,
				remaining: parent_packet_length,
			});

			let packet;
			let n_bits_consumed;
			match kind_number {
				4 =&gt; {
					let chunk_size = 5;
					let mut bin_bits = vec![];

					let mut n_chunks = 0;
					for chunk in data_bits.chunks_exact(5) {
						n_chunks += 1;
						bin_bits.extend_from_slice(&amp;chunk[1..]);
						if !chunk[0] {
							break;
						}
					}

					let value = i64::try_from(to_big_decimal(bin_bits)).unwrap();

					n_bits_consumed = header_length + n_chunks * chunk_size;
					packet = Packet {
						version_number,
						kind: PacketKind::Literal { value },
						depth,
					};
				}
				op =&gt; {
					let op_data_length;
					let n_bits_for_length;

					let length_type = data_bits[0];
					if length_type {
						// length in packets
						n_bits_for_length = 12;
						let n_packets =
							usize::try_from(to_big_decimal(&amp;data_bits[1..n_bits_for_length]))
								.unwrap();
						op_data_length = RemainingData::NPackets(n_packets);
					} else {
						// length in bits
						n_bits_for_length = 16;
						let n_bits =
							usize::try_from(to_big_decimal(&amp;data_bits[1..n_bits_for_length]))
								.unwrap();
						op_data_length = RemainingData::NBits(n_bits);
					};

					n_bits_consumed = header_length + n_bits_for_length;
					// A hack; we're going to subtract n_bits_consumed from this later
					// despite the fact that in theory we shouldn't (because the newly added
					// packet hasn't consumed any data yet), so we we pre-add n_bits_consumed
					// here so that when we subtract it later we end up with the right number
					// of bits
					let op_data_length = match op_data_length {
						RemainingData::NBits(n) =&gt; RemainingData::NBits(n + n_bits_consumed),
						rd @ RemainingData::NPackets(_) =&gt; rd,
					};

					packet = Packet {
						version_number,
						kind: PacketKind::Operator { op: op.into() },
						depth,
					};

					stack.push(ParseState {
						depth: depth + 1,
						remaining: op_data_length,
					});
				}
			};

			cursor += n_bits_consumed;

			for ps in &amp;mut stack {
				if let RemainingData::NBits(n) = &amp;mut ps.remaining {
					if *n &gt; 0 {
						// The hack above is to counteract this subtraction; if we just pushed
						// a RemainingData::NumBits, we won't actually have consumed any of
						// its input yet
						//
						// If our code has no bugs, and the input is trustworthy, this will
						// never underflow.
						*n -= n_bits_consumed;
					}
				}
			}

			packets.push(packet);
		}

		packets
	}
}

#[derive(Debug)]
enum PacketKind {
	Literal { value: Number },
	Operator { op: Operation }, // Defined in pt2
}

#[derive(Debug)]
struct Packet {
	version_number: u64,
	kind: PacketKind,
	depth: usize,
}

fn read_input(input: &amp;str) -&gt; Vec&lt;Packet&gt; {
	let b = Binary::from_hex(input).unwrap();
	b.as_packets()
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;u64, Number&gt; {
	let p = read_input(input);
	(16, (pt1(&amp;p), pt2(&amp;p).unwrap())).into()
}

pub fn ans() -&gt; Answer&lt;u64, Number&gt; {
	ans_for_input(include_str!("input.txt"))
}
// end::setup[]

// tag::pt1[]
fn pt1(packets: &amp;[Packet]) -&gt; u64 {
	packets.iter().map(|packet| packet.version_number).sum()
}
// end::pt1[]

// tag::pt2[]
#[derive(Debug)]
enum Reducer {
	Sum,
	Product,
	Min,
	Max,
}

impl Reducer {
	fn identity(&amp;self) -&gt; Number {
		use Reducer::*;
		match self {
			Sum =&gt; 0,
			Product =&gt; 1,
			Min =&gt; Number::MAX,
			Max =&gt; Number::MIN,
		}
	}

	fn combine(&amp;self, x: Number, y: Number) -&gt; Number {
		use Reducer::*;
		match self {
			Sum =&gt; x + y,
			Product =&gt; x * y,
			Min =&gt; x.min(y),
			Max =&gt; x.max(y),
		}
	}
}

#[derive(Debug)]
enum Comparitor {
	Gt,
	Lt,
	Eq,
}

impl Comparitor {
	fn apply(&amp;self, x: Number, y: Number) -&gt; Number {
		use Comparitor::*;
		i64::from(match self {
			Gt =&gt; x &gt; y,
			Lt =&gt; x &lt; y,
			Eq =&gt; x == y,
		})
	}
}

#[derive(Debug)]
enum Operation {
	Reduce(Reducer),
	Compare(Comparitor),
}

impl From&lt;u64&gt; for Operation {
	fn from(n: u64) -&gt; Self {
		use Comparitor::*;
		use Operation::*;
		use Reducer::*;
		match n {
			0 =&gt; Reduce(Sum),
			1 =&gt; Reduce(Product),
			2 =&gt; Reduce(Min),
			3 =&gt; Reduce(Max),
			5 =&gt; Compare(Gt),
			6 =&gt; Compare(Lt),
			7 =&gt; Compare(Eq),
			_ =&gt; unreachable!(),
		}
	}
}

fn pt2(packets: &amp;[Packet]) -&gt; Option&lt;Number&gt; {
	struct Arg {
		depth: usize,
		value: Number,
	}
	let mut arg_stack = vec![];

	for Packet {
		kind: packet_kind,
		depth: packet_depth,
		..
	} in packets.iter().rev()
	{
		let packet_depth = *packet_depth;

		match packet_kind {
			&amp;PacketKind::Literal { value } =&gt; arg_stack.push(Arg {
				depth: packet_depth,
				value,
			}),
			PacketKind::Operator { op } =&gt; {
				use Operation::*;
				let value = match op {
					Reduce(reducer) =&gt; {
						let mut result = reducer.identity();
						while let Some(arg @ Arg { depth, value }) = arg_stack.pop() {
							if depth &lt;= packet_depth {
								arg_stack.push(arg); // oops, went too far
								break;
							}
							result = reducer.combine(result, value);
						}
						result
					}
					Compare(comparitor) =&gt; {
						let Arg { value: first, .. } = arg_stack.pop()?;
						let Arg { value: second, .. } = arg_stack.pop()?;

						comparitor.apply(first, second)
					}
				};

				arg_stack.push(Arg {
					depth: packet_depth,
					value,
				});
			}
		}
	}

	Some(arg_stack.first()?.value)
}
// end::pt2[]

#[cfg(test)]
mod test {
	use super::*;
	use crate::test_input;

	#[test]
	fn test() {
		#[track_caller]
		fn test_pt1(in_str: &amp;str, pt1_val: u64) {
			test_input!(&amp;read_input(in_str), pt1: pt1_val);
		}

		#[track_caller]
		fn test_pt2(in_str: &amp;str, pt2_val: Number) {
			test_input!(&amp;read_input(in_str), pt2: Some(pt2_val));
		}

		// pt1 only
		test_pt1("D2FE28", 6);
		test_pt1("8A004A801A8002F478", 16);
		test_pt1("620080001611562C8802118E34", 12);
		test_pt1("C0015000016115A2E0802F182340", 23);
		test_pt1("A0016C880162017C3686B18A3D4780", 31);
		test_pt1(include_str!("input.txt"), 927);

		// pt2 only
		test_pt2("D2FE28", 2021);
		test_pt2("C200B40A82", 3);
		test_pt2("04005AC33890", 54);
		test_pt2("880086C3E88112", 7);
		test_pt2("CE00C43D881120", 9);
		test_pt2("D8005AC2A8F0", 1);
		test_pt2("F600BC2D8F", 0);
		test_pt2("9C005AC2F8F0", 0);
		test_pt2("9C0141080250320F1802104A08", 1);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_part_2"><a class="anchor" href="#_part_2"></a>Part 2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Part 2 asks us to actually evaluate the packet tree as a tree of an expressions, akin to S-expressions.
While this wasn&#8217;t hard, one challenge was to implement it without code duplication.
The way I achieved this was to split the operators into two families, <code>Reducer</code>s (<code>+</code>, <code>*</code>, <code>min</code>, and <code>max</code>) and <code>Operators</code>s (<code>≤</code>, <code>==</code>, <code>≥</code>) which essentially comprise their own interfaces that specify how they should be applied to values in the stack.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">// tag::setup[]
use crate::{utils::to_big_decimal, Answer};
use std::fmt::{Display, Write};

type Number = i64;

struct Binary(Vec&lt;bool&gt;);

impl Binary {
	fn from_hex(s: &amp;str) -&gt; Option&lt;Self&gt; {
		let mut binary = Vec::with_capacity(s.len() * 4);
		for c in s.trim().chars() {
			let n = c.to_digit(16)?;
			let digits = [3, 2, 1, 0usize].map(|place| ((1 &lt;&lt; place) &amp; n) != 0);
			binary.extend_from_slice(&amp;digits);
		}

		Some(Self(binary))
	}
}

impl Display for Binary {
	fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
		for &amp;digit in &amp;self.0 {
			let c = if digit { '1' } else { '0' };
			f.write_char(c)?;
		}
		Ok(())
	}
}

impl Binary {
	fn as_packets(&amp;self) -&gt; Vec&lt;Packet&gt; {
		#[derive(Debug)]
		enum RemainingData {
			NBits(usize),
			NPackets(usize),
		}

		impl RemainingData {
			fn is_empty(&amp;self) -&gt; bool {
				matches!(self, RemainingData::NBits(0) | RemainingData::NPackets(0))
			}
		}

		#[derive(Debug)]
		struct ParseState {
			depth: usize,
			remaining: RemainingData,
		}

		let mut packets = vec![];

		let orig_data = &amp;self.0;
		let header_length = 6;
		let mut cursor = 0;
		let mut stack = vec![ParseState {
			depth: 0,
			remaining: RemainingData::NPackets(1),
		}];

		while let Some(parse_state) = stack.pop() {
			let ParseState { depth, remaining } = parse_state;

			if remaining.is_empty() {
				continue;
			}

			let packet_bits = &amp;orig_data[cursor..];

			let version_number = to_big_decimal(&amp;packet_bits[0..3]);
			let kind_number = to_big_decimal(&amp;packet_bits[3..6]);
			let data_bits = &amp;packet_bits[header_length..];

			let parent_packet_length = match remaining {
				RemainingData::NBits(n) =&gt; RemainingData::NBits(n),
				RemainingData::NPackets(n) =&gt; RemainingData::NPackets(n - 1),
			};
			stack.push(ParseState {
				depth,
				remaining: parent_packet_length,
			});

			let packet;
			let n_bits_consumed;
			match kind_number {
				4 =&gt; {
					let chunk_size = 5;
					let mut bin_bits = vec![];

					let mut n_chunks = 0;
					for chunk in data_bits.chunks_exact(5) {
						n_chunks += 1;
						bin_bits.extend_from_slice(&amp;chunk[1..]);
						if !chunk[0] {
							break;
						}
					}

					let value = i64::try_from(to_big_decimal(bin_bits)).unwrap();

					n_bits_consumed = header_length + n_chunks * chunk_size;
					packet = Packet {
						version_number,
						kind: PacketKind::Literal { value },
						depth,
					};
				}
				op =&gt; {
					let op_data_length;
					let n_bits_for_length;

					let length_type = data_bits[0];
					if length_type {
						// length in packets
						n_bits_for_length = 12;
						let n_packets =
							usize::try_from(to_big_decimal(&amp;data_bits[1..n_bits_for_length]))
								.unwrap();
						op_data_length = RemainingData::NPackets(n_packets);
					} else {
						// length in bits
						n_bits_for_length = 16;
						let n_bits =
							usize::try_from(to_big_decimal(&amp;data_bits[1..n_bits_for_length]))
								.unwrap();
						op_data_length = RemainingData::NBits(n_bits);
					};

					n_bits_consumed = header_length + n_bits_for_length;
					// A hack; we're going to subtract n_bits_consumed from this later
					// despite the fact that in theory we shouldn't (because the newly added
					// packet hasn't consumed any data yet), so we we pre-add n_bits_consumed
					// here so that when we subtract it later we end up with the right number
					// of bits
					let op_data_length = match op_data_length {
						RemainingData::NBits(n) =&gt; RemainingData::NBits(n + n_bits_consumed),
						rd @ RemainingData::NPackets(_) =&gt; rd,
					};

					packet = Packet {
						version_number,
						kind: PacketKind::Operator { op: op.into() },
						depth,
					};

					stack.push(ParseState {
						depth: depth + 1,
						remaining: op_data_length,
					});
				}
			};

			cursor += n_bits_consumed;

			for ps in &amp;mut stack {
				if let RemainingData::NBits(n) = &amp;mut ps.remaining {
					if *n &gt; 0 {
						// The hack above is to counteract this subtraction; if we just pushed
						// a RemainingData::NumBits, we won't actually have consumed any of
						// its input yet
						//
						// If our code has no bugs, and the input is trustworthy, this will
						// never underflow.
						*n -= n_bits_consumed;
					}
				}
			}

			packets.push(packet);
		}

		packets
	}
}

#[derive(Debug)]
enum PacketKind {
	Literal { value: Number },
	Operator { op: Operation }, // Defined in pt2
}

#[derive(Debug)]
struct Packet {
	version_number: u64,
	kind: PacketKind,
	depth: usize,
}

fn read_input(input: &amp;str) -&gt; Vec&lt;Packet&gt; {
	let b = Binary::from_hex(input).unwrap();
	b.as_packets()
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;u64, Number&gt; {
	let p = read_input(input);
	(16, (pt1(&amp;p), pt2(&amp;p).unwrap())).into()
}

pub fn ans() -&gt; Answer&lt;u64, Number&gt; {
	ans_for_input(include_str!("input.txt"))
}
// end::setup[]

// tag::pt1[]
fn pt1(packets: &amp;[Packet]) -&gt; u64 {
	packets.iter().map(|packet| packet.version_number).sum()
}
// end::pt1[]

// tag::pt2[]
#[derive(Debug)]
enum Reducer {
	Sum,
	Product,
	Min,
	Max,
}

impl Reducer {
	fn identity(&amp;self) -&gt; Number {
		use Reducer::*;
		match self {
			Sum =&gt; 0,
			Product =&gt; 1,
			Min =&gt; Number::MAX,
			Max =&gt; Number::MIN,
		}
	}

	fn combine(&amp;self, x: Number, y: Number) -&gt; Number {
		use Reducer::*;
		match self {
			Sum =&gt; x + y,
			Product =&gt; x * y,
			Min =&gt; x.min(y),
			Max =&gt; x.max(y),
		}
	}
}

#[derive(Debug)]
enum Comparitor {
	Gt,
	Lt,
	Eq,
}

impl Comparitor {
	fn apply(&amp;self, x: Number, y: Number) -&gt; Number {
		use Comparitor::*;
		i64::from(match self {
			Gt =&gt; x &gt; y,
			Lt =&gt; x &lt; y,
			Eq =&gt; x == y,
		})
	}
}

#[derive(Debug)]
enum Operation {
	Reduce(Reducer),
	Compare(Comparitor),
}

impl From&lt;u64&gt; for Operation {
	fn from(n: u64) -&gt; Self {
		use Comparitor::*;
		use Operation::*;
		use Reducer::*;
		match n {
			0 =&gt; Reduce(Sum),
			1 =&gt; Reduce(Product),
			2 =&gt; Reduce(Min),
			3 =&gt; Reduce(Max),
			5 =&gt; Compare(Gt),
			6 =&gt; Compare(Lt),
			7 =&gt; Compare(Eq),
			_ =&gt; unreachable!(),
		}
	}
}

fn pt2(packets: &amp;[Packet]) -&gt; Option&lt;Number&gt; {
	struct Arg {
		depth: usize,
		value: Number,
	}
	let mut arg_stack = vec![];

	for Packet {
		kind: packet_kind,
		depth: packet_depth,
		..
	} in packets.iter().rev()
	{
		let packet_depth = *packet_depth;

		match packet_kind {
			&amp;PacketKind::Literal { value } =&gt; arg_stack.push(Arg {
				depth: packet_depth,
				value,
			}),
			PacketKind::Operator { op } =&gt; {
				use Operation::*;
				let value = match op {
					Reduce(reducer) =&gt; {
						let mut result = reducer.identity();
						while let Some(arg @ Arg { depth, value }) = arg_stack.pop() {
							if depth &lt;= packet_depth {
								arg_stack.push(arg); // oops, went too far
								break;
							}
							result = reducer.combine(result, value);
						}
						result
					}
					Compare(comparitor) =&gt; {
						let Arg { value: first, .. } = arg_stack.pop()?;
						let Arg { value: second, .. } = arg_stack.pop()?;

						comparitor.apply(first, second)
					}
				};

				arg_stack.push(Arg {
					depth: packet_depth,
					value,
				});
			}
		}
	}

	Some(arg_stack.first()?.value)
}
// end::pt2[]

#[cfg(test)]
mod test {
	use super::*;
	use crate::test_input;

	#[test]
	fn test() {
		#[track_caller]
		fn test_pt1(in_str: &amp;str, pt1_val: u64) {
			test_input!(&amp;read_input(in_str), pt1: pt1_val);
		}

		#[track_caller]
		fn test_pt2(in_str: &amp;str, pt2_val: Number) {
			test_input!(&amp;read_input(in_str), pt2: Some(pt2_val));
		}

		// pt1 only
		test_pt1("D2FE28", 6);
		test_pt1("8A004A801A8002F478", 16);
		test_pt1("620080001611562C8802118E34", 12);
		test_pt1("C0015000016115A2E0802F182340", 23);
		test_pt1("A0016C880162017C3686B18A3D4780", 31);
		test_pt1(include_str!("input.txt"), 927);

		// pt2 only
		test_pt2("D2FE28", 2021);
		test_pt2("C200B40A82", 3);
		test_pt2("04005AC33890", 54);
		test_pt2("880086C3E88112", 7);
		test_pt2("CE00C43D881120", 9);
		test_pt2("D8005AC2A8F0", 1);
		test_pt2("F600BC2D8F", 0);
		test_pt2("9C005AC2F8F0", 0);
		test_pt2("9C0141080250320F1802104A08", 1);
	}
}</code></pre>
</div>
</div>
</div>
</div>     <nav class="pagination">
        <span class="prev"><a href="../day_15/soln">Day 15: Chiton</a></span>
        <span class="next"><a href="../day_17/soln">Day 17: Trick Shot</a></span>
    </nav>

</article>
  </div>
  <footer class="footer">
  <p>This page was built using <a href="https://antora.org" target="_blank">Antora</a> with a theme forked from the <a
      href="https://gitlab.com/antora/antora-ui-default" target="_blank">default UI</a>. Search is powered by <a
      href="https://lunrjs.com" target="_blank">Lunr</a>.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script>
	function add_is_current_path() {
		let elem = document.querySelector(`.nav-container .is-current-page > .final-depth`);
		if (!elem) { return; }
		while (!elem.classList.contains("nav-panel-explore")) {
			if (elem.tagName === "LI") {
				elem.classList.add("is-current-path");
			}
			elem = elem.parentNode;
		}
	}
	add_is_current_path()
</script>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
	<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
<script>
	function set_up_footnotes() {
		let footnoteBox;
		let footnoteP;
		const _isMobile = "ontouchstart" in document.documentElement;

		// Apparently, sticking the tooltip in a child div of document.body, instead of in
		// document.body directly, helps performance.
		// https://atfzl.com/don-t-attach-tooltips-to-document-body
		const footnoteHolder = document.createElement("div");
		document.body.appendChild(footnoteHolder);

		function showFootnoteBoxOnHover(elem) {
			const FOOTNOTE_BOX_MAX_WIDTH = 400;

			if (footnoteBox === undefined) {
				footnoteBox = document.createElement("div");
				footnoteHolder.appendChild(footnoteBox);
				footnoteBox.classList.add("footnote-box");
				footnoteBox.addEventListener("mouseleave", () => removeFootnoteBox());

				footnoteP = document.createElement("p");
				footnoteBox.appendChild(footnoteP);

				footnoteBox.style.zIndex = 9999;
			}

			// Remove the numbering from this footnote box
			const footnoteId = elem.getAttribute("href"); // Starts with #
			const footnoteClone = document
				.getElementById(footnoteId.substring(1))
				.cloneNode(true);
			const footnoteA = footnoteClone.getElementsByTagName("a")[0];
			footnoteA.remove();

			const footnoteHtml = footnoteClone.innerHTML.replace(/^\s*\.\s*/, "");

			footnoteP.innerHTML = footnoteHtml;
			footnoteBox.style.right = null;
			footnoteBox.style.left = "0px";
			footnoteBox.style.top = "0px";

			const elemRect = elem.getBoundingClientRect();
			const bodyRect = document.body.getBoundingClientRect();

			footnoteBox.style.display = "block";

			let tx = false;
			let ty = false;

			if (elemRect.left - FOOTNOTE_BOX_MAX_WIDTH < 10) {
				const px = -bodyRect.left + 10;
				footnoteBox.style.left = `${px}px`;

				tx = true;
			} else {
				const px = elemRect.left - bodyRect.left + 20;
				footnoteBox.style.left = `${px}px`;
			}

			const footnoteRect = footnoteBox.getBoundingClientRect();

			const windowHeight = document.documentElement.clientHeight;
			if (elemRect.top + footnoteRect.height > windowHeight) {
				const py = -10 + window.scrollY + windowHeight;
				footnoteBox.style.top = `${py}px`;
			} else {
				const py = elemRect.top - bodyRect.top;
				footnoteBox.style.top = `${py}px`;

				ty = true;
			}

			footnoteBox.style.transform = (() => {
				let transX = tx ? 0 : "-100%";
				let transY = ty ? 0 : "-100%";
				return `translate(${transX}, ${transY})`;
			})();

			// if (elemRect.right + FOOTNOTE_BOX_MAX_WIDTH - 30 > bodyRect.right) {
			// 	const px = bodyRect.right - (bodyRect.left + bodyRect.width);
			// 	console.log(bodyRect);
			// 	footnoteBox.style.left = null;
			// 	footnoteBox.style.right = `${px}px`;
			// 	console.log("right");
			// } else {
			// 	const px = -10 + elemRect.left - bodyRect.left;
			// 	footnoteBox.style.right = null;
			// 	footnoteBox.style.left = `${px}px`;
			// 	console.log("left");
			// }
		}

		function removeFootnoteBox() {
			if (footnoteBox === undefined) {
				return;
			}
			footnoteBox.style.display = "none";
		}

		function initializeFootnotes() {
			const footnotes = document.querySelectorAll(
				":not(#footnotes) .footnote a.footnote",
			);
			const nFootnotes = footnotes.length;
			for (let i = 0; i < nFootnotes; i++) {
				const footnote = footnotes[i];
				footnote.addEventListener("mouseenter", event => {
					showFootnoteBoxOnHover(footnote);
				});
			}
		}

		if (!_isMobile) {
			initializeFootnotes();
		}
	}
	set_up_footnotes()
</script>
<script>
	function add_titles() {
		const elems = document.querySelectorAll(".ui-icon.nav-menu-icon");
		for (let i = 0, len = elems.length; i < len; i++) {
			const elem = elems[i];
			if (elem.getAttribute('title') === null) {
				elems[i].setAttribute("title", "Navigation menu icon: one bullet followed by three sub-bullets");
			}
		}
	}
	add_titles()
</script>
</main>
</div>
</body>

</html>
