<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport"
	content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Day 8: Seven Segment Search :: Advent of Code 2021</title>
        <link rel="prev" href="../day_07/soln">
        <link rel="next" href="../day_09/soln">
    <meta name="generator" content="Antora 3.1.2">
<link rel="stylesheet" href="../../_/css/site.css" />
<link rel="stylesheet" href="../../_/css/code-syntax-highlight.css" />
<link rel="stylesheet" href="https://use.typekit.net/fnd4xvj.css" />
<link rel="stylesheet" href="https://iosevka-rltb.pages.dev/dist/iosevka-rltb-mono/iosevka-rltb-mono-cloudflare.css">
<meta name="theme-color" content="#0970c4" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#0967b4" media="(prefers-color-scheme: dark)">
<script>var uiRootPath = '../../_';</script>
<link rel="icon" type="image/x-icon" href="../../favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
</head>

<body class="article">
  <header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">Advent of Code 2021</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable open-left">
          <span class="navbar-link">Links</span>
          <div class="navbar-dropdown">
            <a class="navbar-item navbar-external-link" href="https://github.com/rben01" target="_blank">
              <div class="site-logo github-logo github-repo-logo"></div><span class="site-url">/&nbsp;rben01</span>
            </a>
          </div>
        </div>
          <div class="navbar-item search hide-for-print">
            <div id="search-field" class="field">
              <input id="search-input" type="text" placeholder="Search this site">
            </div>
          </div>
      </div>
    </div>
  </nav>
</header>
<svg xmlns="http://www.w3.org/2000/svg" id="icon-mask-container" width="0" height="0">
	<defs>
		<clipPath id="icon-github" clipPathUnits="objectBoundingBox">
			<path transform="scale(0.0102040816)" fill-rule="evenodd" clip-rule="evenodd"
				d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z">
			</path>
		</clipPath>
		<clipPath id="icon-menu-clippath" clipPathUnits="objectBoundingBox">
			<circle cx=".1" cy=".1575" r=".06"></circle>
			<path d="M.325 .1175h.65 v.08h-.65z"></path>
			<circle cx=".25" cy=".4775" r=".06"></circle>
			<path d="M.475 .4375h.5 v.08h-.5z"></path>
			<circle cx=".25" cy=".7975" r=".06"></circle>
			<path d="M.475 .7575h.5 v.08h-.5z"></path>
		</clipPath>
		<clipPath id="icon-external-link" clipPathUnits="objectBoundingBox">
			<path transform="translate(.5 .5) scale(0.0017) translate(-256 -256)"
				d="M320 0c-17.7 0-32 14.3-32 32s14.3 32 32 32h82.7L201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L448 109.3V192c0 17.7 14.3 32 32 32s32-14.3 32-32V32c0-17.7-14.3-32-32-32H320zM80 32C35.8 32 0 67.8 0 112V432c0 44.2 35.8 80 80 80H400c44.2 0 80-35.8 80-80V320c0-17.7-14.3-32-32-32s-32 14.3-32 32V432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16H192c17.7 0 32-14.3 32-32s-14.3-32-32-32H80z" />
		</clipPath>
		<clipPath id="icon-star" clipPathUnits="objectBoundingBox">
			<path transform="translate(0 0.075) scale(0.001736)"
				d="M316.9 18C311.6 7 300.4 0 288.1 0s-23.4 7-28.8 18L195 150.3 51.4 171.5c-12 1.8-22 10.2-25.7 21.7s-.7 24.2 7.9 32.7L137.8 329 113.2 474.7c-2 12 3 24.2 12.9 31.3s23 8 33.8 2.3l128.3-68.5 128.3 68.5c10.8 5.7 23.9 4.9 33.8-2.3s14.9-19.3 12.9-31.3L438.5 329 542.7 225.9c8.6-8.5 11.7-21.2 7.9-32.7s-13.7-19.9-25.7-21.7L381.2 150.3 316.9 18z" />
		</clipPath>
	</defs>
	<symbol viewBox="0 0 100 100" id="icon-back" class="svg-icon-template">
		<path
			d="m 50.000978,9.89975 -40.1010516,40.10025 40.1010516,40.10025 5.6556,-5.65551 -30.434757,-30.44194 h 64.878253 v -8.0056 H 25.221821 l 30.434757,-30.44001 z" />
	</symbol>
	<symbol viewBox="0 0 30 30" id="icon-caret" class="svg-icon-template">
		<path d="m 10.18745,2.9998 14.0001,12.0002 -14.0001,12.0001 z" stroke-width="2" stroke-linecap="round"
			stroke-linejoin="round" />
	</symbol>
	<symbol viewBox="0 0 30 30" id="icon-chevron">
		<path
			d="M 3.6699219,6.5898438 1.4550781,8.6152344 15,23.374272 28.544922,8.6152344 26.330078,6.5898438 15,18.759498 Z" />
	</symbol>
	<symbol viewBox="0 0 16 16" id="icon-clipboard">
		<path fill-rule="evenodd"
			d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z" />
	</symbol>
	<symbol viewBox="0 0 1 1" id="icon-home-filled" class="svg-icon-template icon-home">
		<path
			d="M.5002 .10747572875253811 L.10042786437626905 .4662178643762691 l.02671524585077328 .029770717813528465 l.06725688977295768 -.060354082044552726 v.44845 h.25506 v-.25166 H.5505 v.25166 h.25506 v-.44845 l.06725688977295768 .060354082044552726 l.02671524585077328 -.029770717813528465 l-.154812135623731 -.13892322952293115 V.1 h-.12657 V.21371495268001076 z" />
	</symbol>
	<symbol viewBox="0 0 1 1" id="icon-home-outline" class="svg-icon-template icon-home">
		<path
			d="M.5002 .10747572875253811 L.10042786437626905 .4662178643762691 l.02671524585077328 .029770717813528465 l.06725688977295768 -.060354082044552726 v.44845 h.25506 v-.25166 H.5505 v.25166 h.25506 v-.44845 l.06725688977295768 .060354082044552726 l.02671524585077328 -.029770717813528465 l-.154812135623731 -.13892322952293115 V.1 h-.12657 V.21371495268001076 z v.0565685424949238 L.65815 .30578331524901864 V.14 H.70472 V.2910051322295775 L.65815 .2492147727540948 v.0565685424949238 L.76556 .40216945463621206 V.8440845001452447 h-.17166 v-.25166 H.40946 v.25166 h-.17166 V.40216945463621206 L.5002 .16404427124746193 z " />
	</symbol>
	<symbol viewBox="0 0 1 1" id="icon-menu">
		<circle cx=".1" cy=".1575" r=".06"></circle>
		<path d="M.325 .1175h.65 v.08h-.65z"></path>
		<circle cx=".25" cy=".4775" r=".06"></circle>
		<path d="M.475 .4375h.5 v.08h-.5z"></path>
		<circle cx=".25" cy=".7975" r=".06"></circle>
		<path d="M.475 .7575h.5 v.08h-.5z"></path>
	</symbol>
</svg>
  <div class="body">
	<div class="nav-container"  data-component="ROOT"
  data-version="" >
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-explore is-active" data-panel="explore">
  <div class="context">
    <span class="title">Navigation</span>
    <span class="nav-explore-expander">
      <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon" viewBox="0 0 1 1">
        <title>Discloure chevron</title>
        <use href="#icon-chevron"></use>
      </svg>
    </span>
  </div>
  <ul class="components">
      <li
        class="component is-current">
          <a class="title" href="../../">Solutions</a>
            <ul class="nav-list">
      <li class="nav-item is-active"
        data-depth="0">
        <span
          class="nav-item-expander clickable">
        </span>
          <ul class="nav-list">
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_01/soln">Day 1: Sonar Sweep</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_02/soln">Day 2: Dive!</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_03/soln">Day 3: Binary Diagnostic</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_04/soln">Day 4: Giant Squid</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_05/soln">Day 5: Hydrothermal Venture</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_06/soln">Day 6: Lanternfish</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_07/soln">Day 7: The Treachery of Whales</a>
        </span>
              </li>
      <li class="nav-item is-active is-current-page"
        data-depth="1">
        <span
          class="nav-item-expander final-depth">
              <span class="nav-text">Day 8: Seven Segment Search</span>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_09/soln">Day 9: Smoke Basin</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_10/soln">Day 10: Syntax Scoring</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_11/soln">Day 11: Dumbo Octopus</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_12/soln">Day 12: Passage Pathing</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_13/soln">Day 13: Transparent Origami</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_14/soln">Day 14: Extended Polymerization</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_15/soln">Day 15: Chiton</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_16/soln">Day 16: Packet Decoder</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_17/soln">Day 17: Trick Shot</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_18/soln">Day 18: Snailfish</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_19/soln">Day 19: Beacon Scanner</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_20/soln">Day 20: Trench Map</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_21/soln">Day 21: Dirac Dice</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_22/soln">Day 22: Reactor Reboot</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_23/soln">Day 23: Amphipod</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_24/soln">Day 24: Arithmetic Logic Unit</a>
        </span>
              </li>
      <li class="nav-item is-active"
        data-depth="1">
        <span
          class="nav-item-expander clickable final-depth">
              <a class="nav-link"
                href="../day_25/soln">Day 25: Sea Cucumber</a>
        </span>
              </li>
  </ul>
      </li>
  </ul>
      </li>
  </ul>
</div>
    </div>
  </aside>
</div>
	<main class="article">
  <div class="toolbar" role="navigation">
  <button class="nav-toggle">
	<svg class="svg-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1">
		<title>Show or hide menu</title>
		<use class="icon-menu" href="#icon-menu"></use>
		<use class="icon-back" href="#icon-back"></use>
	</svg>
</button>
    <a href="../../" class="home-link" title="Home">
      <svg xmlns="http://www.w3.org/2000/svg" class="svg-icon icon-home" viewBox="0 0 1 1">
        <title>Home</title>
        <use class="icon-home icon-home-filled" href="#icon-home-filled"></use>
        <use class="icon-home icon-home-outline" href="#icon-home-outline"></use>
      </svg>
    </a>
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li>&#47;</li> 
          <li>
              <a href="../../">Solutions</a>

          </li>
        <li>&#47;</li>
        <li><span>Day 8: Seven Segment Search</span></li>
    </ul>
</nav>
  </div>
  <div class="content">
      <aside class="toc sidebar" data-title="Contents"
  data-levels="2">
  <div class="toc-menu"></div>
</aside>
      <article class="doc">
	<div class="title-container">
			<h1 class="page">Day 8: Seven Segment Search</h1>
	</div>
	<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/8" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day #8 problem description</a> │ <a href="/_attachments/src/day_08/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>What an interesting problem!
We are asked to deduce the manner in which a computer has been incorrectly hooked up to a <a href="https://en.wikipedia.org/wiki/Seven-segment_display" target="_blank" rel="noopener">seven-segment display</a> (7SD):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Seven_segment_01_Pengo.jpg/485px-Seven_segment_01_Pengo.jpg" alt="A seven-segment display chip with pins showing" width="300">
</div>
</div>
<div class="paragraph">
<p>We will use the following display schematic, with the segments labeled A–G:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">  0:      1:      2:      3:      4:
 AAAA            AAAA    AAAA
B    C       C       C       C  B    C
B    C       C       C       C  B    C
                 DDDD    DDDD    DDDD
E    F       F  E            F       F
E    F       F  E            F       F
 GGGG            GGGG    GGGG

  5:      6:      7:      8:      9:
 AAAA    AAAA    AAAA    AAAA    AAAA
B       B            C  B    C  B    C
B       B            C  B    C  B    C
 DDDD    DDDD            DDDD    DDDD
     F  E    F       F  E    F       F
     F  E    F       F  E    F       F
 GGGG    GGGG            GGGG    GGGG</code></pre>
</div>
</div>
<div class="paragraph">
<p>The computer sends a stream of digits that we see as various patterns of lit segments on the 7SD.
The computer has the correct logic to display digits, but its wires to the 7SD got crossed during setup, so the digits it attempts to display end up looking like gibberish to us.
But because the computer&#8217;s underlying logic still holds, we can still deduce things from its output.
For instance, if it lights up only two segments, we know that it is trying to display a 1 (because 1 is the only digit made of exactly two segments), and so the two segments it lit up <em>should</em> be rewired to the two segments <code>CF</code> (although we still don&#8217;t know in which order).
If it lights up five segments, then it could be trying to display either a 2 (<code>ACDEG</code>), 3 (<code>ACDFG</code>), or 5 (<code>ABDFG</code>).
By observing the patterns it lights up, and using our knowledge of how the digits 0–9 should have been displayed, we can deduce the full wiring scheme and how the computer must be rewired to the display in order to function correctly.</p>
</div>
<div class="paragraph">
<p>The only other wrinkle is we don&#8217;t even get to tell the computer which digits to attempt to display; that is entirely up to it.
We simply receive a stream of <em>some</em> digits, and from that must deduce the wiring scheme.</p>
</div>
<div class="paragraph">
<div class="title">The Solution</div>
<p>The strategy is as follows: for each garbled digit we see, record its pattern and the list of candidate digits (those having the same number of segments turned on).
Then, by taking set differences and intersections between the patterns seen and their candidates, we can derive more specific information about the rewiring.
For instance:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Suppose the computer sends two digits and lights up <code>ABD</code> and <code>AB</code>.
<code>ABD</code> only has one candidate, 7 (<code>ACF</code>), because only 7 has three segments turned on.
<code>AB</code> only has one candidate, 1 (<code>CF</code>), because only 1 has two segments turned on.
Then we take the difference of the displayed segments — <code>ABD − AB = D</code> — and all pairwise differences between their corresponding candidates (just one in this case) — <code>ACF − CF = A</code> — to deduce that <code>D</code> must be rewired to <code>A</code>.
We continue this logic, subtracting (say) the map <code>D ➜ A</code> from other display-candidate pairs to narrow <em>them</em> down.
We are done when we know the one segment that each segment needs to be rewired to.</p>
</li>
<li>
<p>Suppose the computer sends <code>ABCDE</code>; its candidates would be 2 (<code>ACDEG</code>), 3 (<code>ACDFG</code>), and 5 (<code>ABDFG</code>).
If it then sends <code>DEF</code>, its candidates would be just 7 (<code>ACF</code>).
The intersection of the two sent digits is <code>DE</code>.
Taking the pairwise intersections between the candidates, and keeping only those with the same length as <code>DE</code>, we see that the candidates for <code>DE</code> are <code>AC</code> and <code>AF</code>.
Subtracting <code>D ➜ A</code> from this, we deduce that <code>E</code> must be mapped to either <code>C</code> or <code>F</code>.
Subtracting <code>D ➜ A</code> and <code>E ➜ C|F</code> from <code>DEF ➜ ACF</code>, we see that <code>F ➜ C|F</code> as well.</p>
</li>
<li>
<p>Continuing this way, we can eventually deduce all the mappings.</p>
</li>
</ol>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_setup"><a class="anchor" href="#_setup"></a>Setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, we model the notion of a digit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">// tag::setup[]
use crate::Answer;
use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set};

const N_SEGMENTS: usize = 7;
// end::setup[]

// tag::digit[]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct Digit {
	segments: [bool; N_SEGMENTS],
	n_on: usize,
}

impl Digit {
	fn new(segments: [bool; N_SEGMENTS]) -&gt; Self {
		Self {
			segments,
			n_on: segments.iter().filter(|&amp;&amp;b| b).count(),
		}
	}

	fn from_str(s: &amp;str) -&gt; Self {
		let mut segments = [false; N_SEGMENTS];
		for c in s.bytes() {
			let i = c - b'a';
			segments[usize::from(i)] = true;
		}
		Self::new(segments)
	}

	fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -&gt; bool) -&gt; Self {
		Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y)))
	}
}

impl std::ops::BitOr for Digit {
	type Output = Self;
	fn bitor(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x | y)
	}
}

impl std::ops::BitAnd for Digit {
	type Output = Self;
	fn bitand(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x &amp; y)
	}
}

impl std::ops::Not for Digit {
	type Output = Self;
	fn not(self) -&gt; Self::Output {
		Self::new(self.segments.map(|b| !b))
	}
}

impl From&lt;usize&gt; for Digit {
	fn from(n: usize) -&gt; Self {
		let segments = match n {
			/*
			-----[A, B, C, D, E, F, G]
			*/
			0 =&gt; [1, 1, 1, 0, 1, 1, 1],
			1 =&gt; [0, 0, 1, 0, 0, 1, 0],
			2 =&gt; [1, 0, 1, 1, 1, 0, 1],
			3 =&gt; [1, 0, 1, 1, 0, 1, 1],
			4 =&gt; [0, 1, 1, 1, 0, 1, 0],
			5 =&gt; [1, 1, 0, 1, 0, 1, 1],
			6 =&gt; [1, 1, 0, 1, 1, 1, 1],
			7 =&gt; [1, 0, 1, 0, 0, 1, 0],
			8 =&gt; [1, 1, 1, 1, 1, 1, 1],
			9 =&gt; [1, 1, 1, 1, 0, 1, 1],
			_ =&gt; panic!("Cannot make digit for n={}", n),
		};
		let segments = segments.map(|i| i != 0);
		Self::new(segments)
	}
}

impl From&lt;Digit&gt; for usize {
	fn from(digit: Digit) -&gt; Self {
		let segments = digit.segments.map(u8::from);
		match segments {
			/*
			[A, B, C, D, E, F, G]
			*/
			[1, 1, 1, 0, 1, 1, 1] =&gt; 0,
			[0, 0, 1, 0, 0, 1, 0] =&gt; 1,
			[1, 0, 1, 1, 1, 0, 1] =&gt; 2,
			[1, 0, 1, 1, 0, 1, 1] =&gt; 3,
			[0, 1, 1, 1, 0, 1, 0] =&gt; 4,
			[1, 1, 0, 1, 0, 1, 1] =&gt; 5,
			[1, 1, 0, 1, 1, 1, 1] =&gt; 6,
			[1, 0, 1, 0, 0, 1, 0] =&gt; 7,
			[1, 1, 1, 1, 1, 1, 1] =&gt; 8,
			[1, 1, 1, 1, 0, 1, 1] =&gt; 9,
			_ =&gt; panic!("Digit {:?} is not valid", digit),
		}
	}
}
// end::digit[]

// tag::setup[]
fn get_mapping_from_garbled_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	garbled_digits: impl Iterator&lt;Item = D&gt;,
) -&gt; Result&lt;Map&lt;Digit, Digit&gt;, Map&lt;Digit, Set&lt;Digit&gt;&gt;&gt; {
	let mut mappings = Map::new();

	{
		let mut grouped_by_n_on = Map::new();
		for n in 0..=9 {
			let digit = Digit::from(n);
			grouped_by_n_on
				.entry(digit.n_on)
				.or_insert_with(Set::new)
				.insert(digit);
		}

		for gd in garbled_digits {
			let gd = *gd.borrow();
			let digits_w_same_n_segments = &amp;grouped_by_n_on[&amp;gd.n_on];
			mappings.insert(gd, digits_w_same_n_segments.clone());
		}
	}

	let identity: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| x);
	let bitwise_not: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| !x);

	loop {
		let mut new_mappings = Map::new();

		for (i, (&amp;garbled1, choices1)) in mappings.iter().enumerate() {
			for (&amp;garbled2, choices2) in mappings.iter().skip(i + 1) {
				for (op1, op2) in [
					(identity, identity),
					(identity, bitwise_not),
					(bitwise_not, identity),
				] {
					let new_garbled = op1(garbled1) &amp; op2(garbled2);

					if new_garbled.n_on == 0 {
						continue;
					}

					let mut new_good_candidates = Set::new();
					for &amp;good_digit1 in choices1 {
						for &amp;good_digit2 in choices2 {
							let candidate = op1(good_digit1) &amp; op2(good_digit2);
							if candidate.n_on == new_garbled.n_on {
								new_good_candidates.insert(candidate);
							}
						}
					}

					match new_mappings.entry(new_garbled) {
						MapEntry::Vacant(v) =&gt; {
							v.insert(new_good_candidates);
						}
						MapEntry::Occupied(mut o) =&gt; {
							o.insert(o.get() &amp; &amp;new_good_candidates);
						}
					}
				}
			}
		}

		// Remove all keys that can be written as the disjoint-bitwise-or of two other
		// keys, as they're redundant. This means if e.g., A and BC are present, then
		// remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB
		// and BC are not disjoint)
		let mut redundant_keys = Set::new();
		let new_garbled_keys = new_mappings.keys().copied().collect::&lt;Set&lt;_&gt;&gt;();
		for (i, &amp;garbled1) in new_garbled_keys.iter().enumerate() {
			for &amp;garbled2 in new_garbled_keys.iter().skip(i + 1) {
				if (garbled1 &amp; garbled2).n_on != 0 {
					continue;
				}
				let segment_union = garbled1 | garbled2;
				if new_garbled_keys.contains(&amp;segment_union) {
					redundant_keys.insert(segment_union);
				}
			}
		}

		for k in &amp;redundant_keys {
			new_mappings.remove(k);
		}

		if mappings.len() == N_SEGMENTS &amp;&amp; mappings.values().all(|m| m.len() == 1) {
			return Ok(mappings
				.into_iter()
				.map(|(k, v)| (k, v.iter().next().copied().unwrap()))
				.collect());
		} else if mappings == new_mappings {
			return Err(mappings);
		}

		mappings = new_mappings;
	}
}

fn apply_mapping_to_garbled_digit(mapping: &amp;Map&lt;Digit, Digit&gt;, garbled_digit: Digit) -&gt; usize {
	let mut result = Digit::new([false; 7]);
	for (&amp;k, &amp;v) in mapping {
		if (garbled_digit &amp; k).n_on &gt; 0 {
			result = result | v;
		}
	}
	result.into()
}

fn read_input(input: &amp;str) -&gt; Vec&lt;(Vec&lt;Digit&gt;, Vec&lt;Digit&gt;)&gt; {
	fn whitespace_sepd_strs_to_digits(strs: &amp;str) -&gt; Vec&lt;Digit&gt; {
		strs.trim()
			.split_ascii_whitespace()
			.map(Digit::from_str)
			.collect()
	}
	input
		.lines()
		.filter_map(|line| {
			let line = line.trim();
			if line.is_empty() {
				return None;
			}
			let mut in_out = line.split('|');
			let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			Some((in_digits, out_digits))
		})
		.collect()
}

fn translate_line_to_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	idod: (impl Iterator&lt;Item = D&gt;, impl Iterator&lt;Item = D&gt;),
) -&gt; Option&lt;Vec&lt;usize&gt;&gt; {
	let (in_digits, out_digits) = idod;

	let mapping = get_mapping_from_garbled_digits(in_digits).ok()?;
	Some(
		out_digits
			.map(|d| apply_mapping_to_garbled_digit(&amp;mapping, *d.borrow()))
			.collect(),
	)
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;usize, usize&gt; {
	let in_out_lines = read_input(input);

	let output_digits = in_out_lines
		.iter()
		.map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter())))
		.collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()
		.unwrap();
	(8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into()
}

pub fn ans() -&gt; Answer&lt;usize, usize&gt; {
	ans_for_input(include_str!("input.txt"))
}
// end::setup[]

// tag::pt1[]
fn pt1&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.filter(|&amp;n| [1, 4, 7, 8].contains(n))
				.count()
		})
		.sum()
}
// end::pt1[]

// tag::pt2[]
fn pt2&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.rev()
				.enumerate()
				.map(|(pow10, &amp;val)| val * 10_usize.pow(u32::try_from(pow10).unwrap()))
				.sum::&lt;usize&gt;()
		})
		.sum()
}
// end::pt2[]

#[cfg(test)]
mod test {
	use super::*;
	use crate::test_input;

	#[test]
	fn test() {
		test_input!(include_str!("input.txt"), day: 8, ans: (237, 1_009_098));
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">The Algorithm</div>
<p>We repeatedly take the intersection and set-differences between digits, getting a more and more refined mapping until finally we are left with a 1:1 mapping.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">// tag::setup[]
use crate::Answer;
use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set};

const N_SEGMENTS: usize = 7;
// end::setup[]

// tag::digit[]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct Digit {
	segments: [bool; N_SEGMENTS],
	n_on: usize,
}

impl Digit {
	fn new(segments: [bool; N_SEGMENTS]) -&gt; Self {
		Self {
			segments,
			n_on: segments.iter().filter(|&amp;&amp;b| b).count(),
		}
	}

	fn from_str(s: &amp;str) -&gt; Self {
		let mut segments = [false; N_SEGMENTS];
		for c in s.bytes() {
			let i = c - b'a';
			segments[usize::from(i)] = true;
		}
		Self::new(segments)
	}

	fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -&gt; bool) -&gt; Self {
		Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y)))
	}
}

impl std::ops::BitOr for Digit {
	type Output = Self;
	fn bitor(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x | y)
	}
}

impl std::ops::BitAnd for Digit {
	type Output = Self;
	fn bitand(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x &amp; y)
	}
}

impl std::ops::Not for Digit {
	type Output = Self;
	fn not(self) -&gt; Self::Output {
		Self::new(self.segments.map(|b| !b))
	}
}

impl From&lt;usize&gt; for Digit {
	fn from(n: usize) -&gt; Self {
		let segments = match n {
			/*
			-----[A, B, C, D, E, F, G]
			*/
			0 =&gt; [1, 1, 1, 0, 1, 1, 1],
			1 =&gt; [0, 0, 1, 0, 0, 1, 0],
			2 =&gt; [1, 0, 1, 1, 1, 0, 1],
			3 =&gt; [1, 0, 1, 1, 0, 1, 1],
			4 =&gt; [0, 1, 1, 1, 0, 1, 0],
			5 =&gt; [1, 1, 0, 1, 0, 1, 1],
			6 =&gt; [1, 1, 0, 1, 1, 1, 1],
			7 =&gt; [1, 0, 1, 0, 0, 1, 0],
			8 =&gt; [1, 1, 1, 1, 1, 1, 1],
			9 =&gt; [1, 1, 1, 1, 0, 1, 1],
			_ =&gt; panic!("Cannot make digit for n={}", n),
		};
		let segments = segments.map(|i| i != 0);
		Self::new(segments)
	}
}

impl From&lt;Digit&gt; for usize {
	fn from(digit: Digit) -&gt; Self {
		let segments = digit.segments.map(u8::from);
		match segments {
			/*
			[A, B, C, D, E, F, G]
			*/
			[1, 1, 1, 0, 1, 1, 1] =&gt; 0,
			[0, 0, 1, 0, 0, 1, 0] =&gt; 1,
			[1, 0, 1, 1, 1, 0, 1] =&gt; 2,
			[1, 0, 1, 1, 0, 1, 1] =&gt; 3,
			[0, 1, 1, 1, 0, 1, 0] =&gt; 4,
			[1, 1, 0, 1, 0, 1, 1] =&gt; 5,
			[1, 1, 0, 1, 1, 1, 1] =&gt; 6,
			[1, 0, 1, 0, 0, 1, 0] =&gt; 7,
			[1, 1, 1, 1, 1, 1, 1] =&gt; 8,
			[1, 1, 1, 1, 0, 1, 1] =&gt; 9,
			_ =&gt; panic!("Digit {:?} is not valid", digit),
		}
	}
}
// end::digit[]

// tag::setup[]
fn get_mapping_from_garbled_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	garbled_digits: impl Iterator&lt;Item = D&gt;,
) -&gt; Result&lt;Map&lt;Digit, Digit&gt;, Map&lt;Digit, Set&lt;Digit&gt;&gt;&gt; {
	let mut mappings = Map::new();

	{
		let mut grouped_by_n_on = Map::new();
		for n in 0..=9 {
			let digit = Digit::from(n);
			grouped_by_n_on
				.entry(digit.n_on)
				.or_insert_with(Set::new)
				.insert(digit);
		}

		for gd in garbled_digits {
			let gd = *gd.borrow();
			let digits_w_same_n_segments = &amp;grouped_by_n_on[&amp;gd.n_on];
			mappings.insert(gd, digits_w_same_n_segments.clone());
		}
	}

	let identity: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| x);
	let bitwise_not: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| !x);

	loop {
		let mut new_mappings = Map::new();

		for (i, (&amp;garbled1, choices1)) in mappings.iter().enumerate() {
			for (&amp;garbled2, choices2) in mappings.iter().skip(i + 1) {
				for (op1, op2) in [
					(identity, identity),
					(identity, bitwise_not),
					(bitwise_not, identity),
				] {
					let new_garbled = op1(garbled1) &amp; op2(garbled2);

					if new_garbled.n_on == 0 {
						continue;
					}

					let mut new_good_candidates = Set::new();
					for &amp;good_digit1 in choices1 {
						for &amp;good_digit2 in choices2 {
							let candidate = op1(good_digit1) &amp; op2(good_digit2);
							if candidate.n_on == new_garbled.n_on {
								new_good_candidates.insert(candidate);
							}
						}
					}

					match new_mappings.entry(new_garbled) {
						MapEntry::Vacant(v) =&gt; {
							v.insert(new_good_candidates);
						}
						MapEntry::Occupied(mut o) =&gt; {
							o.insert(o.get() &amp; &amp;new_good_candidates);
						}
					}
				}
			}
		}

		// Remove all keys that can be written as the disjoint-bitwise-or of two other
		// keys, as they're redundant. This means if e.g., A and BC are present, then
		// remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB
		// and BC are not disjoint)
		let mut redundant_keys = Set::new();
		let new_garbled_keys = new_mappings.keys().copied().collect::&lt;Set&lt;_&gt;&gt;();
		for (i, &amp;garbled1) in new_garbled_keys.iter().enumerate() {
			for &amp;garbled2 in new_garbled_keys.iter().skip(i + 1) {
				if (garbled1 &amp; garbled2).n_on != 0 {
					continue;
				}
				let segment_union = garbled1 | garbled2;
				if new_garbled_keys.contains(&amp;segment_union) {
					redundant_keys.insert(segment_union);
				}
			}
		}

		for k in &amp;redundant_keys {
			new_mappings.remove(k);
		}

		if mappings.len() == N_SEGMENTS &amp;&amp; mappings.values().all(|m| m.len() == 1) {
			return Ok(mappings
				.into_iter()
				.map(|(k, v)| (k, v.iter().next().copied().unwrap()))
				.collect());
		} else if mappings == new_mappings {
			return Err(mappings);
		}

		mappings = new_mappings;
	}
}

fn apply_mapping_to_garbled_digit(mapping: &amp;Map&lt;Digit, Digit&gt;, garbled_digit: Digit) -&gt; usize {
	let mut result = Digit::new([false; 7]);
	for (&amp;k, &amp;v) in mapping {
		if (garbled_digit &amp; k).n_on &gt; 0 {
			result = result | v;
		}
	}
	result.into()
}

fn read_input(input: &amp;str) -&gt; Vec&lt;(Vec&lt;Digit&gt;, Vec&lt;Digit&gt;)&gt; {
	fn whitespace_sepd_strs_to_digits(strs: &amp;str) -&gt; Vec&lt;Digit&gt; {
		strs.trim()
			.split_ascii_whitespace()
			.map(Digit::from_str)
			.collect()
	}
	input
		.lines()
		.filter_map(|line| {
			let line = line.trim();
			if line.is_empty() {
				return None;
			}
			let mut in_out = line.split('|');
			let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			Some((in_digits, out_digits))
		})
		.collect()
}

fn translate_line_to_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	idod: (impl Iterator&lt;Item = D&gt;, impl Iterator&lt;Item = D&gt;),
) -&gt; Option&lt;Vec&lt;usize&gt;&gt; {
	let (in_digits, out_digits) = idod;

	let mapping = get_mapping_from_garbled_digits(in_digits).ok()?;
	Some(
		out_digits
			.map(|d| apply_mapping_to_garbled_digit(&amp;mapping, *d.borrow()))
			.collect(),
	)
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;usize, usize&gt; {
	let in_out_lines = read_input(input);

	let output_digits = in_out_lines
		.iter()
		.map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter())))
		.collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()
		.unwrap();
	(8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into()
}

pub fn ans() -&gt; Answer&lt;usize, usize&gt; {
	ans_for_input(include_str!("input.txt"))
}
// end::setup[]

// tag::pt1[]
fn pt1&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.filter(|&amp;n| [1, 4, 7, 8].contains(n))
				.count()
		})
		.sum()
}
// end::pt1[]

// tag::pt2[]
fn pt2&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.rev()
				.enumerate()
				.map(|(pow10, &amp;val)| val * 10_usize.pow(u32::try_from(pow10).unwrap()))
				.sum::&lt;usize&gt;()
		})
		.sum()
}
// end::pt2[]

#[cfg(test)]
mod test {
	use super::*;
	use crate::test_input;

	#[test]
	fn test() {
		test_input!(include_str!("input.txt"), day: 8, ans: (237, 1_009_098));
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_part_1"><a class="anchor" href="#_part_1"></a>Part 1</h2>
<div class="sectionbody">
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">// tag::setup[]
use crate::Answer;
use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set};

const N_SEGMENTS: usize = 7;
// end::setup[]

// tag::digit[]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct Digit {
	segments: [bool; N_SEGMENTS],
	n_on: usize,
}

impl Digit {
	fn new(segments: [bool; N_SEGMENTS]) -&gt; Self {
		Self {
			segments,
			n_on: segments.iter().filter(|&amp;&amp;b| b).count(),
		}
	}

	fn from_str(s: &amp;str) -&gt; Self {
		let mut segments = [false; N_SEGMENTS];
		for c in s.bytes() {
			let i = c - b'a';
			segments[usize::from(i)] = true;
		}
		Self::new(segments)
	}

	fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -&gt; bool) -&gt; Self {
		Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y)))
	}
}

impl std::ops::BitOr for Digit {
	type Output = Self;
	fn bitor(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x | y)
	}
}

impl std::ops::BitAnd for Digit {
	type Output = Self;
	fn bitand(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x &amp; y)
	}
}

impl std::ops::Not for Digit {
	type Output = Self;
	fn not(self) -&gt; Self::Output {
		Self::new(self.segments.map(|b| !b))
	}
}

impl From&lt;usize&gt; for Digit {
	fn from(n: usize) -&gt; Self {
		let segments = match n {
			/*
			-----[A, B, C, D, E, F, G]
			*/
			0 =&gt; [1, 1, 1, 0, 1, 1, 1],
			1 =&gt; [0, 0, 1, 0, 0, 1, 0],
			2 =&gt; [1, 0, 1, 1, 1, 0, 1],
			3 =&gt; [1, 0, 1, 1, 0, 1, 1],
			4 =&gt; [0, 1, 1, 1, 0, 1, 0],
			5 =&gt; [1, 1, 0, 1, 0, 1, 1],
			6 =&gt; [1, 1, 0, 1, 1, 1, 1],
			7 =&gt; [1, 0, 1, 0, 0, 1, 0],
			8 =&gt; [1, 1, 1, 1, 1, 1, 1],
			9 =&gt; [1, 1, 1, 1, 0, 1, 1],
			_ =&gt; panic!("Cannot make digit for n={}", n),
		};
		let segments = segments.map(|i| i != 0);
		Self::new(segments)
	}
}

impl From&lt;Digit&gt; for usize {
	fn from(digit: Digit) -&gt; Self {
		let segments = digit.segments.map(u8::from);
		match segments {
			/*
			[A, B, C, D, E, F, G]
			*/
			[1, 1, 1, 0, 1, 1, 1] =&gt; 0,
			[0, 0, 1, 0, 0, 1, 0] =&gt; 1,
			[1, 0, 1, 1, 1, 0, 1] =&gt; 2,
			[1, 0, 1, 1, 0, 1, 1] =&gt; 3,
			[0, 1, 1, 1, 0, 1, 0] =&gt; 4,
			[1, 1, 0, 1, 0, 1, 1] =&gt; 5,
			[1, 1, 0, 1, 1, 1, 1] =&gt; 6,
			[1, 0, 1, 0, 0, 1, 0] =&gt; 7,
			[1, 1, 1, 1, 1, 1, 1] =&gt; 8,
			[1, 1, 1, 1, 0, 1, 1] =&gt; 9,
			_ =&gt; panic!("Digit {:?} is not valid", digit),
		}
	}
}
// end::digit[]

// tag::setup[]
fn get_mapping_from_garbled_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	garbled_digits: impl Iterator&lt;Item = D&gt;,
) -&gt; Result&lt;Map&lt;Digit, Digit&gt;, Map&lt;Digit, Set&lt;Digit&gt;&gt;&gt; {
	let mut mappings = Map::new();

	{
		let mut grouped_by_n_on = Map::new();
		for n in 0..=9 {
			let digit = Digit::from(n);
			grouped_by_n_on
				.entry(digit.n_on)
				.or_insert_with(Set::new)
				.insert(digit);
		}

		for gd in garbled_digits {
			let gd = *gd.borrow();
			let digits_w_same_n_segments = &amp;grouped_by_n_on[&amp;gd.n_on];
			mappings.insert(gd, digits_w_same_n_segments.clone());
		}
	}

	let identity: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| x);
	let bitwise_not: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| !x);

	loop {
		let mut new_mappings = Map::new();

		for (i, (&amp;garbled1, choices1)) in mappings.iter().enumerate() {
			for (&amp;garbled2, choices2) in mappings.iter().skip(i + 1) {
				for (op1, op2) in [
					(identity, identity),
					(identity, bitwise_not),
					(bitwise_not, identity),
				] {
					let new_garbled = op1(garbled1) &amp; op2(garbled2);

					if new_garbled.n_on == 0 {
						continue;
					}

					let mut new_good_candidates = Set::new();
					for &amp;good_digit1 in choices1 {
						for &amp;good_digit2 in choices2 {
							let candidate = op1(good_digit1) &amp; op2(good_digit2);
							if candidate.n_on == new_garbled.n_on {
								new_good_candidates.insert(candidate);
							}
						}
					}

					match new_mappings.entry(new_garbled) {
						MapEntry::Vacant(v) =&gt; {
							v.insert(new_good_candidates);
						}
						MapEntry::Occupied(mut o) =&gt; {
							o.insert(o.get() &amp; &amp;new_good_candidates);
						}
					}
				}
			}
		}

		// Remove all keys that can be written as the disjoint-bitwise-or of two other
		// keys, as they're redundant. This means if e.g., A and BC are present, then
		// remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB
		// and BC are not disjoint)
		let mut redundant_keys = Set::new();
		let new_garbled_keys = new_mappings.keys().copied().collect::&lt;Set&lt;_&gt;&gt;();
		for (i, &amp;garbled1) in new_garbled_keys.iter().enumerate() {
			for &amp;garbled2 in new_garbled_keys.iter().skip(i + 1) {
				if (garbled1 &amp; garbled2).n_on != 0 {
					continue;
				}
				let segment_union = garbled1 | garbled2;
				if new_garbled_keys.contains(&amp;segment_union) {
					redundant_keys.insert(segment_union);
				}
			}
		}

		for k in &amp;redundant_keys {
			new_mappings.remove(k);
		}

		if mappings.len() == N_SEGMENTS &amp;&amp; mappings.values().all(|m| m.len() == 1) {
			return Ok(mappings
				.into_iter()
				.map(|(k, v)| (k, v.iter().next().copied().unwrap()))
				.collect());
		} else if mappings == new_mappings {
			return Err(mappings);
		}

		mappings = new_mappings;
	}
}

fn apply_mapping_to_garbled_digit(mapping: &amp;Map&lt;Digit, Digit&gt;, garbled_digit: Digit) -&gt; usize {
	let mut result = Digit::new([false; 7]);
	for (&amp;k, &amp;v) in mapping {
		if (garbled_digit &amp; k).n_on &gt; 0 {
			result = result | v;
		}
	}
	result.into()
}

fn read_input(input: &amp;str) -&gt; Vec&lt;(Vec&lt;Digit&gt;, Vec&lt;Digit&gt;)&gt; {
	fn whitespace_sepd_strs_to_digits(strs: &amp;str) -&gt; Vec&lt;Digit&gt; {
		strs.trim()
			.split_ascii_whitespace()
			.map(Digit::from_str)
			.collect()
	}
	input
		.lines()
		.filter_map(|line| {
			let line = line.trim();
			if line.is_empty() {
				return None;
			}
			let mut in_out = line.split('|');
			let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			Some((in_digits, out_digits))
		})
		.collect()
}

fn translate_line_to_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	idod: (impl Iterator&lt;Item = D&gt;, impl Iterator&lt;Item = D&gt;),
) -&gt; Option&lt;Vec&lt;usize&gt;&gt; {
	let (in_digits, out_digits) = idod;

	let mapping = get_mapping_from_garbled_digits(in_digits).ok()?;
	Some(
		out_digits
			.map(|d| apply_mapping_to_garbled_digit(&amp;mapping, *d.borrow()))
			.collect(),
	)
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;usize, usize&gt; {
	let in_out_lines = read_input(input);

	let output_digits = in_out_lines
		.iter()
		.map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter())))
		.collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()
		.unwrap();
	(8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into()
}

pub fn ans() -&gt; Answer&lt;usize, usize&gt; {
	ans_for_input(include_str!("input.txt"))
}
// end::setup[]

// tag::pt1[]
fn pt1&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.filter(|&amp;n| [1, 4, 7, 8].contains(n))
				.count()
		})
		.sum()
}
// end::pt1[]

// tag::pt2[]
fn pt2&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.rev()
				.enumerate()
				.map(|(pow10, &amp;val)| val * 10_usize.pow(u32::try_from(pow10).unwrap()))
				.sum::&lt;usize&gt;()
		})
		.sum()
}
// end::pt2[]

#[cfg(test)]
mod test {
	use super::*;
	use crate::test_input;

	#[test]
	fn test() {
		test_input!(include_str!("input.txt"), day: 8, ans: (237, 1_009_098));
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_part_2"><a class="anchor" href="#_part_2"></a>Part 2</h2>
<div class="sectionbody">
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">// tag::setup[]
use crate::Answer;
use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set};

const N_SEGMENTS: usize = 7;
// end::setup[]

// tag::digit[]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct Digit {
	segments: [bool; N_SEGMENTS],
	n_on: usize,
}

impl Digit {
	fn new(segments: [bool; N_SEGMENTS]) -&gt; Self {
		Self {
			segments,
			n_on: segments.iter().filter(|&amp;&amp;b| b).count(),
		}
	}

	fn from_str(s: &amp;str) -&gt; Self {
		let mut segments = [false; N_SEGMENTS];
		for c in s.bytes() {
			let i = c - b'a';
			segments[usize::from(i)] = true;
		}
		Self::new(segments)
	}

	fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -&gt; bool) -&gt; Self {
		Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y)))
	}
}

impl std::ops::BitOr for Digit {
	type Output = Self;
	fn bitor(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x | y)
	}
}

impl std::ops::BitAnd for Digit {
	type Output = Self;
	fn bitand(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x &amp; y)
	}
}

impl std::ops::Not for Digit {
	type Output = Self;
	fn not(self) -&gt; Self::Output {
		Self::new(self.segments.map(|b| !b))
	}
}

impl From&lt;usize&gt; for Digit {
	fn from(n: usize) -&gt; Self {
		let segments = match n {
			/*
			-----[A, B, C, D, E, F, G]
			*/
			0 =&gt; [1, 1, 1, 0, 1, 1, 1],
			1 =&gt; [0, 0, 1, 0, 0, 1, 0],
			2 =&gt; [1, 0, 1, 1, 1, 0, 1],
			3 =&gt; [1, 0, 1, 1, 0, 1, 1],
			4 =&gt; [0, 1, 1, 1, 0, 1, 0],
			5 =&gt; [1, 1, 0, 1, 0, 1, 1],
			6 =&gt; [1, 1, 0, 1, 1, 1, 1],
			7 =&gt; [1, 0, 1, 0, 0, 1, 0],
			8 =&gt; [1, 1, 1, 1, 1, 1, 1],
			9 =&gt; [1, 1, 1, 1, 0, 1, 1],
			_ =&gt; panic!("Cannot make digit for n={}", n),
		};
		let segments = segments.map(|i| i != 0);
		Self::new(segments)
	}
}

impl From&lt;Digit&gt; for usize {
	fn from(digit: Digit) -&gt; Self {
		let segments = digit.segments.map(u8::from);
		match segments {
			/*
			[A, B, C, D, E, F, G]
			*/
			[1, 1, 1, 0, 1, 1, 1] =&gt; 0,
			[0, 0, 1, 0, 0, 1, 0] =&gt; 1,
			[1, 0, 1, 1, 1, 0, 1] =&gt; 2,
			[1, 0, 1, 1, 0, 1, 1] =&gt; 3,
			[0, 1, 1, 1, 0, 1, 0] =&gt; 4,
			[1, 1, 0, 1, 0, 1, 1] =&gt; 5,
			[1, 1, 0, 1, 1, 1, 1] =&gt; 6,
			[1, 0, 1, 0, 0, 1, 0] =&gt; 7,
			[1, 1, 1, 1, 1, 1, 1] =&gt; 8,
			[1, 1, 1, 1, 0, 1, 1] =&gt; 9,
			_ =&gt; panic!("Digit {:?} is not valid", digit),
		}
	}
}
// end::digit[]

// tag::setup[]
fn get_mapping_from_garbled_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	garbled_digits: impl Iterator&lt;Item = D&gt;,
) -&gt; Result&lt;Map&lt;Digit, Digit&gt;, Map&lt;Digit, Set&lt;Digit&gt;&gt;&gt; {
	let mut mappings = Map::new();

	{
		let mut grouped_by_n_on = Map::new();
		for n in 0..=9 {
			let digit = Digit::from(n);
			grouped_by_n_on
				.entry(digit.n_on)
				.or_insert_with(Set::new)
				.insert(digit);
		}

		for gd in garbled_digits {
			let gd = *gd.borrow();
			let digits_w_same_n_segments = &amp;grouped_by_n_on[&amp;gd.n_on];
			mappings.insert(gd, digits_w_same_n_segments.clone());
		}
	}

	let identity: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| x);
	let bitwise_not: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| !x);

	loop {
		let mut new_mappings = Map::new();

		for (i, (&amp;garbled1, choices1)) in mappings.iter().enumerate() {
			for (&amp;garbled2, choices2) in mappings.iter().skip(i + 1) {
				for (op1, op2) in [
					(identity, identity),
					(identity, bitwise_not),
					(bitwise_not, identity),
				] {
					let new_garbled = op1(garbled1) &amp; op2(garbled2);

					if new_garbled.n_on == 0 {
						continue;
					}

					let mut new_good_candidates = Set::new();
					for &amp;good_digit1 in choices1 {
						for &amp;good_digit2 in choices2 {
							let candidate = op1(good_digit1) &amp; op2(good_digit2);
							if candidate.n_on == new_garbled.n_on {
								new_good_candidates.insert(candidate);
							}
						}
					}

					match new_mappings.entry(new_garbled) {
						MapEntry::Vacant(v) =&gt; {
							v.insert(new_good_candidates);
						}
						MapEntry::Occupied(mut o) =&gt; {
							o.insert(o.get() &amp; &amp;new_good_candidates);
						}
					}
				}
			}
		}

		// Remove all keys that can be written as the disjoint-bitwise-or of two other
		// keys, as they're redundant. This means if e.g., A and BC are present, then
		// remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB
		// and BC are not disjoint)
		let mut redundant_keys = Set::new();
		let new_garbled_keys = new_mappings.keys().copied().collect::&lt;Set&lt;_&gt;&gt;();
		for (i, &amp;garbled1) in new_garbled_keys.iter().enumerate() {
			for &amp;garbled2 in new_garbled_keys.iter().skip(i + 1) {
				if (garbled1 &amp; garbled2).n_on != 0 {
					continue;
				}
				let segment_union = garbled1 | garbled2;
				if new_garbled_keys.contains(&amp;segment_union) {
					redundant_keys.insert(segment_union);
				}
			}
		}

		for k in &amp;redundant_keys {
			new_mappings.remove(k);
		}

		if mappings.len() == N_SEGMENTS &amp;&amp; mappings.values().all(|m| m.len() == 1) {
			return Ok(mappings
				.into_iter()
				.map(|(k, v)| (k, v.iter().next().copied().unwrap()))
				.collect());
		} else if mappings == new_mappings {
			return Err(mappings);
		}

		mappings = new_mappings;
	}
}

fn apply_mapping_to_garbled_digit(mapping: &amp;Map&lt;Digit, Digit&gt;, garbled_digit: Digit) -&gt; usize {
	let mut result = Digit::new([false; 7]);
	for (&amp;k, &amp;v) in mapping {
		if (garbled_digit &amp; k).n_on &gt; 0 {
			result = result | v;
		}
	}
	result.into()
}

fn read_input(input: &amp;str) -&gt; Vec&lt;(Vec&lt;Digit&gt;, Vec&lt;Digit&gt;)&gt; {
	fn whitespace_sepd_strs_to_digits(strs: &amp;str) -&gt; Vec&lt;Digit&gt; {
		strs.trim()
			.split_ascii_whitespace()
			.map(Digit::from_str)
			.collect()
	}
	input
		.lines()
		.filter_map(|line| {
			let line = line.trim();
			if line.is_empty() {
				return None;
			}
			let mut in_out = line.split('|');
			let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			Some((in_digits, out_digits))
		})
		.collect()
}

fn translate_line_to_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	idod: (impl Iterator&lt;Item = D&gt;, impl Iterator&lt;Item = D&gt;),
) -&gt; Option&lt;Vec&lt;usize&gt;&gt; {
	let (in_digits, out_digits) = idod;

	let mapping = get_mapping_from_garbled_digits(in_digits).ok()?;
	Some(
		out_digits
			.map(|d| apply_mapping_to_garbled_digit(&amp;mapping, *d.borrow()))
			.collect(),
	)
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;usize, usize&gt; {
	let in_out_lines = read_input(input);

	let output_digits = in_out_lines
		.iter()
		.map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter())))
		.collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()
		.unwrap();
	(8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into()
}

pub fn ans() -&gt; Answer&lt;usize, usize&gt; {
	ans_for_input(include_str!("input.txt"))
}
// end::setup[]

// tag::pt1[]
fn pt1&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.filter(|&amp;n| [1, 4, 7, 8].contains(n))
				.count()
		})
		.sum()
}
// end::pt1[]

// tag::pt2[]
fn pt2&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.rev()
				.enumerate()
				.map(|(pow10, &amp;val)| val * 10_usize.pow(u32::try_from(pow10).unwrap()))
				.sum::&lt;usize&gt;()
		})
		.sum()
}
// end::pt2[]

#[cfg(test)]
mod test {
	use super::*;
	use crate::test_input;

	#[test]
	fn test() {
		test_input!(include_str!("input.txt"), day: 8, ans: (237, 1_009_098));
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>     <nav class="pagination">
        <span class="prev"><a href="../day_07/soln">Day 7: The Treachery of Whales</a></span>
        <span class="next"><a href="../day_09/soln">Day 9: Smoke Basin</a></span>
    </nav>

</article>
  </div>
  <footer class="footer">
  <p>This page was built using <a href="https://antora.org" target="_blank">Antora</a> with a theme forked from the <a
      href="https://gitlab.com/antora/antora-ui-default" target="_blank">default UI</a>. Search is powered by <a
      href="https://lunrjs.com" target="_blank">Lunr</a>.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script>
	function add_is_current_path() {
		let elem = document.querySelector(`.nav-container .is-current-page > .final-depth`);
		if (!elem) { return; }
		while (!elem.classList.contains("nav-panel-explore")) {
			if (elem.tagName === "LI") {
				elem.classList.add("is-current-path");
			}
			elem = elem.parentNode;
		}
	}
	add_is_current_path()
</script>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
	<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
<script>
	function set_up_footnotes() {
		let footnoteBox;
		let footnoteP;
		const _isMobile = "ontouchstart" in document.documentElement;

		// Apparently, sticking the tooltip in a child div of document.body, instead of in
		// document.body directly, helps performance.
		// https://atfzl.com/don-t-attach-tooltips-to-document-body
		const footnoteHolder = document.createElement("div");
		document.body.appendChild(footnoteHolder);

		function showFootnoteBoxOnHover(elem) {
			const FOOTNOTE_BOX_MAX_WIDTH = 400;

			if (footnoteBox === undefined) {
				footnoteBox = document.createElement("div");
				footnoteHolder.appendChild(footnoteBox);
				footnoteBox.classList.add("footnote-box");
				footnoteBox.addEventListener("mouseleave", () => removeFootnoteBox());

				footnoteP = document.createElement("p");
				footnoteBox.appendChild(footnoteP);

				footnoteBox.style.zIndex = 9999;
			}

			// Remove the numbering from this footnote box
			const footnoteId = elem.getAttribute("href"); // Starts with #
			const footnoteClone = document
				.getElementById(footnoteId.substring(1))
				.cloneNode(true);
			const footnoteA = footnoteClone.getElementsByTagName("a")[0];
			footnoteA.remove();

			const footnoteHtml = footnoteClone.innerHTML.replace(/^\s*\.\s*/, "");

			footnoteP.innerHTML = footnoteHtml;
			footnoteBox.style.right = null;
			footnoteBox.style.left = "0px";
			footnoteBox.style.top = "0px";

			const elemRect = elem.getBoundingClientRect();
			const bodyRect = document.body.getBoundingClientRect();

			footnoteBox.style.display = "block";

			let tx = false;
			let ty = false;

			if (elemRect.left - FOOTNOTE_BOX_MAX_WIDTH < 10) {
				const px = -bodyRect.left + 10;
				footnoteBox.style.left = `${px}px`;

				tx = true;
			} else {
				const px = elemRect.left - bodyRect.left + 20;
				footnoteBox.style.left = `${px}px`;
			}

			const footnoteRect = footnoteBox.getBoundingClientRect();

			const windowHeight = document.documentElement.clientHeight;
			if (elemRect.top + footnoteRect.height > windowHeight) {
				const py = -10 + window.scrollY + windowHeight;
				footnoteBox.style.top = `${py}px`;
			} else {
				const py = elemRect.top - bodyRect.top;
				footnoteBox.style.top = `${py}px`;

				ty = true;
			}

			footnoteBox.style.transform = (() => {
				let transX = tx ? 0 : "-100%";
				let transY = ty ? 0 : "-100%";
				return `translate(${transX}, ${transY})`;
			})();

			// if (elemRect.right + FOOTNOTE_BOX_MAX_WIDTH - 30 > bodyRect.right) {
			// 	const px = bodyRect.right - (bodyRect.left + bodyRect.width);
			// 	console.log(bodyRect);
			// 	footnoteBox.style.left = null;
			// 	footnoteBox.style.right = `${px}px`;
			// 	console.log("right");
			// } else {
			// 	const px = -10 + elemRect.left - bodyRect.left;
			// 	footnoteBox.style.right = null;
			// 	footnoteBox.style.left = `${px}px`;
			// 	console.log("left");
			// }
		}

		function removeFootnoteBox() {
			if (footnoteBox === undefined) {
				return;
			}
			footnoteBox.style.display = "none";
		}

		function initializeFootnotes() {
			const footnotes = document.querySelectorAll(
				":not(#footnotes) .footnote a.footnote",
			);
			const nFootnotes = footnotes.length;
			for (let i = 0; i < nFootnotes; i++) {
				const footnote = footnotes[i];
				footnote.addEventListener("mouseenter", event => {
					showFootnoteBoxOnHover(footnote);
				});
			}
		}

		if (!_isMobile) {
			initializeFootnotes();
		}
	}
	set_up_footnotes()
</script>
<script>
	function add_titles() {
		const elems = document.querySelectorAll(".ui-icon.nav-menu-icon");
		for (let i = 0, len = elems.length; i < len; i++) {
			const elem = elems[i];
			if (elem.getAttribute('title') === null) {
				elems[i].setAttribute("title", "Navigation menu icon: one bullet followed by three sub-bullets");
			}
		}
	}
	add_titles()
</script>
</main>
</div>
</body>

</html>
