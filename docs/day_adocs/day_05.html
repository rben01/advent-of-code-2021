<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Day 5: Hydrothermal Venture</title>
<link rel="stylesheet" href="./../aoc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<!-- <script defer src="https://use.fontawesome.com/releases/v5.0.4/js/all.js"></script> -->
<!-- <link rel="preconnect" href="https://fonts.googleapis.com" /><link
	rel="preconnect"
	href="https://fonts.gstatic.com"
	crossorigin
/><link
	href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&family=Source+Serif+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap"
	rel="stylesheet"
/> -->
<link
	rel="stylesheet"
	type="text/css"
	href="https://rben01.github.io/Iosevka/dist/iosevka-rltb-mono/iosevka-rltb-mono.css"
/>
<link
	rel="stylesheet"
	type="text/css"
	href="https://rben01.github.io/Iosevka/dist/iosevka-rltb-proportional-sans/iosevka-rltb-proportional-sans.css"
/>

<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"
	integrity="sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw"
	crossorigin="anonymous"
/>

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js"
	integrity="sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH"
	crossorigin="anonymous"
></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js"
	integrity="sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v"
	crossorigin="anonymous"
	onload="renderMathInElement(document.body);"
></script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p><a href="../advent_of_code_2021.html#_problems_and_solutions" class="header-nav-link first"><span class="icon"><i class="fa fa-list-ol"></i></span> Back to Home</a>
<a href="././day_04.html" class="header-nav-link"><span class="icon"><i class="fa fa-chevron-left"></i></span> Previous (Day 4)</a>
<a href="././day_06.html" class="header-nav-link">Next (Day 6) <span class="icon"><i class="fa fa-chevron-right"></i></span></a></p>
</div>
<div class="sect1">
<h2 id="_day_5_hydrothermal_venture">Day 5: Hydrothermal Venture</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/5" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day 5 problem description</a> │ <a href="../../src/day_05/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>This challenge requires iterating the integer points between two other points on the plane.</p>
</div>
<hr>
<div class="sect2">
<h3 id="_setup">Setup</h3>
<div class="paragraph">
<p>First, we read the input into a list of lines of the form \(((x_1, y_1), (x_2, y_2))\).
We also define the helpful <code>range_between(a, b)</code> function, which returns the (nonempty!) range of integers between <code>a</code> and <code>b</code>, inclusive.
The range is ascending if and only if <code>a &lt; b</code>.
(This is different from <code>a..=b</code>, which is empty if <code>a &gt; b</code>.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use crate::Answer;
use num::Integer;
use regex::Regex;
use std::{collections::BTreeMap as Map, str::FromStr};

#[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
struct Point&lt;T&gt;(T, T);
struct EndpointPair&lt;T: Integer&gt;(Point&lt;T&gt;, Point&lt;T&gt;);
type PointCounter&lt;T&gt; = Map&lt;Point&lt;T&gt;, usize&gt;;

fn get_lines&lt;T: Integer + FromStr&gt;(input: &amp;str) -&gt; Option&lt;Vec&lt;EndpointPair&lt;T&gt;&gt;&gt; {
	let line_re = Regex::new(r"(\d+),(\d+)\s*-&gt;\s*(\d+),(\d+)").ok()?;
	input
		.lines()
		.map(|line| {
			let caps = line_re.captures(line)?;
			let [x1, y1, x2, y2] = [1, 2, 3, 4].map(|i| caps.get(i)?.as_str().parse::&lt;T&gt;().ok());
			Some(EndpointPair(Point(x1?, y1?), Point(x2?, y2?)))
		})
		.collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()
}

fn range_between(a: i32, b: i32) -&gt; num::iter::RangeStepInclusive&lt;i32&gt; {
	let step = if a &lt; b { 1 } else { -1 };
	num::range_step_inclusive(a, b, step)
}

fn get_ans&lt;T&gt;(counter: &amp;PointCounter&lt;T&gt;) -&gt; usize {
	counter
		.values()
		.map(|count| if *count &gt;= 2 { 1 } else { 0 })
		.sum()
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;usize, usize&gt; {
	let endpoints = get_lines(input).unwrap();
	(5, (pt1(&amp;endpoints), pt2(&amp;endpoints))).into()
}

pub fn ans() -&gt; Answer&lt;usize, usize&gt; {
	let input = include_str!("input.txt");
	ans_for_input(input)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_1">Part 1</h3>
<div class="paragraph">
<p>Part 1 asks us to count how many times each point belongs to some horizontal or vertical line.
These are lines \(((x_1, y_1), (x_2, y_2))\) for which \(x_1 = x_2\) or \(y_1 = y_2\).
Such a line&#8217;s points are the Cartesian “product” of the ranges <code>range_between(x1, x2)</code> and <code>range_between(y1, y2)</code> (“product” in quotes because one of those ranges has length 1, so it&#8217;s not much of a product).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn get_hv_point_counts(endpoints: &amp;[EndpointPair&lt;i32&gt;]) -&gt; PointCounter&lt;i32&gt; {
	let mut counter = Map::new();
	for &amp;EndpointPair(Point(x1, y1), Point(x2, y2)) in endpoints {
		if x1 != x2 &amp;&amp; y1 != y2 {
			continue;
		}
		for x in range_between(x1, x2) {
			for y in range_between(y1, y2) {
				*counter.entry(Point(x, y)).or_default() += 1;
			}
		}
	}
	counter
}

fn pt1(endpoints: &amp;[EndpointPair&lt;i32&gt;]) -&gt; usize {
	get_ans(&amp;get_hv_point_counts(endpoints))
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_2">Part 2</h3>
<div class="paragraph">
<p>Part 2 asks us to count how many times each point belongs to either a horizontal line, a vertical line, or a \(45^\circ\) diagonal line (whose slope must be \(\pm1\)).
We already found the points on horizontal and vertical lines in Part 1.
Diagonal lines are lines \(((x_1, y_1), (x_2, y_2))\) whose points \( (x_k,y_k)\) satisfy \(|x_k-x_1|=|y_k-y_1|\) with \(x_k\) between \(x_1\) and \(x_2\) and \(y_k\) between \(y_k\) and \(y_2\) (inclusive).
Since the \(k\)<sup>th</sup> element of <code>range_between(a, b)</code> is \(k\) away from \(a\), the points of the diagonal line in question are in fact simply the elements of <code>range_between(x1, x2).zip(range_between(y1, y2))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn get_diag_point_counts(endpoints: &amp;[EndpointPair&lt;i32&gt;]) -&gt; PointCounter&lt;i32&gt; {
	let mut counter = Map::new();
	for &amp;EndpointPair(Point(x1, y1), Point(x2, y2)) in endpoints {
		if (x1 - x2).abs() != (y1 - y2).abs() {
			continue;
		}

		for (x, y) in range_between(x1, x2).zip(range_between(y1, y2)) {
			*counter.entry(Point(x, y)).or_default() += 1;
		}
	}

	counter
}

fn pt2(endpoints: &amp;[EndpointPair&lt;i32&gt;]) -&gt; usize {
	let hv_counter = get_hv_point_counts(endpoints);

	let all_counter = {
		let mut diag_counter = get_diag_point_counts(endpoints);

		for (k, v) in hv_counter {
			*diag_counter.entry(k).or_default() += v;
		}

		diag_counter
	};
	get_ans(&amp;all_counter)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/swift.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>