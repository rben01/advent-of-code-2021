<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Transparent Origami</title>
<link rel="stylesheet" href="./../aoc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<!-- <script defer src="https://use.fontawesome.com/releases/v5.0.4/js/all.js"></script> -->
<link rel="preconnect" href="https://fonts.googleapis.com" /><link
	rel="preconnect"
	href="https://fonts.gstatic.com"
	crossorigin
/><link
	href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Source+Code+Pro:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
	rel="stylesheet"
/>

<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"
	integrity="sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw"
	crossorigin="anonymous"
/>

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js"
	integrity="sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH"
	crossorigin="anonymous"
></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js"
	integrity="sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v"
	crossorigin="anonymous"
	onload="renderMathInElement(document.body);"
></script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p><a href="../advent_of_code_2021.html#_problems_and_solutions"><span class="icon"><i class="fa fa-list-ol"></i></span> Back to Home</a></p>
</div>
<div class="sect1">
<h2 id="_transparent_origami">Transparent Origami</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/13" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day 13 problem description</a> │ <a href="../../src/day_13/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>This problem asks us track how dots on a transparent piece of paper migrate as that piece of paper is folded across vertical and horizontal lines.
Throughout, the upper left corner of the page remains fixed in place; folds move the bottom right corner either up or to the left.
It is a precondition that no dot will lie <em>on</em> a fold.</p>
</div>
<div class="paragraph">
<p>When the page is reflected over the vertical line \(x=a\), one of two things will happen to the dot \( (x,y)\):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If \( (x,y)\) is left of \(x=a\) (i.e., \(x&lt;a\)), it remains in place.</p>
</li>
<li>
<p>Otherwise, the dot will end up as far to the left of \(x=a\) as it was to the right of \(x=a\) before the fold; this distance is simply \(x-a\), and so it ends up with an \(x\)-coordinate of \(a-(x-a)\), and a final position of \( (a-(x-a), y)\).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For a fold over the horizontal line \(y=b\), simply exchange \(x\) with \(y\) and \(a\) with \(b\).</p>
</div>
<div class="paragraph">
<div class="title">Setup</div>
<p>The input comes in as a list of dots <code>x,y</code> followed by a list of folds.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use crate::Answer;
use num::{CheckedAdd, Integer};
use std::{collections::BTreeSet as Set, fmt::Display, str::FromStr};

#[derive(Copy, Clone)]
enum Fold&lt;T&gt; {
	X(T),
	Y(T),
}

impl&lt;T: FromStr&gt; Fold&lt;T&gt; {
	fn from_str(s: &amp;str) -&gt; Option&lt;Self&gt; {
		let mut words = s.split_whitespace();
		words.next()?;
		words.next()?;
		let fold_eqn = words.next()?;

		let mut eqn_sides = fold_eqn.split('=');
		let var = eqn_sides.next()?;
		let value = eqn_sides.next()?.parse::&lt;T&gt;().ok()?;

		Some(match var {
			"x" =&gt; Self::X(value),
			"y" =&gt; Self::Y(value),
			_ =&gt; return None,
		})
	}
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
struct Point&lt;T: Integer&gt;(T, T);

impl&lt;T: Integer + Copy&gt; Point&lt;T&gt; {
	fn folded(&amp;self, across: &amp;Fold&lt;T&gt;) -&gt; Self {
		let &amp;Point(x, y) = self;
		match *across {
			Fold::X(fold_x) =&gt; {
				let new_x = if x &gt; fold_x { fold_x - (x - fold_x) } else { x };
				Point(new_x, y)
			}
			Fold::Y(fold_y) =&gt; {
				let new_y = if y &gt; fold_y { fold_y - (y - fold_y) } else { y };
				Point(x, new_y)
			}
		}
	}
}

#[derive(Clone, Debug)]
struct Paper&lt;T: Integer&gt; {
	dots: Set&lt;Point&lt;T&gt;&gt;,
}

impl&lt;T: Integer + Copy&gt; Paper&lt;T&gt; {
	fn from_dots(dots: impl IntoIterator&lt;Item = Point&lt;T&gt;&gt;) -&gt; Paper&lt;T&gt; {
		let dots = dots.into_iter().collect();
		Self { dots }
	}

	fn folded_across(&amp;self, fold: &amp;Fold&lt;T&gt;) -&gt; Paper&lt;T&gt; {
		let mut dots = Set::new();
		for p in &amp;self.dots {
			dots.insert(p.folded(fold));
		}

		Paper::from_dots(dots)
	}

	fn do_folds&lt;F: std::borrow::Borrow&lt;Fold&lt;T&gt;&gt;&gt;(
		&amp;self,
		folds: impl Iterator&lt;Item = F&gt;,
	) -&gt; Paper&lt;T&gt; {
		let mut paper = self.clone();
		for fold in folds {
			let fold = fold.borrow();
			paper = paper.folded_across(fold);
		}
		paper
	}
}

fn read_input&lt;T: Integer + FromStr + Copy&gt;(input: &amp;str) -&gt; Option&lt;(Paper&lt;T&gt;, Vec&lt;Fold&lt;T&gt;&gt;)&gt; {
	let mut lines = input.lines();

	let points = lines
		.by_ref()
		.take_while(|line| !line.trim().is_empty())
		.map(|line| {
			let mut comps = line.split(',');
			let x = comps.next()?.parse::&lt;T&gt;().ok()?;
			let y = comps.next()?.parse::&lt;T&gt;().ok()?;

			Some(Point(x, y))
		})
		.collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()?;
	let paper = Paper::&lt;T&gt;::from_dots(points);

	let folds = lines.map(Fold::&lt;T&gt;::from_str).collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()?;

	Some((paper, folds))
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;usize, String&gt; {
	let (paper, folds) = read_input::&lt;i32&gt;(input).unwrap();
	(13, (pt1(&amp;paper, &amp;folds[0]), pt2(&amp;paper, folds.iter()))).into()
}

pub fn ans() -&gt; Answer&lt;usize, String&gt; {
	ans_for_input(include_str!("input.txt"))
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Part 1</div>
<p>Part 1 has us perform a single fold. (Just one? No fun!)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt1&lt;T: Integer + Copy&gt;(paper: &amp;Paper&lt;T&gt;, fold: &amp;Fold&lt;T&gt;) -&gt; usize {
	paper.folded_across(fold).dots.len()
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Part 2</div>
<p>Part 2 has us perform all of the folds, and then <em>read the resulting arrangement of dots as a password containing eight capital capital letters</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">impl&lt;T: Integer + CheckedAdd + Clone + Copy&gt; Display for Paper&lt;T&gt; {
	fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
		let (max_x, max_y) = {
			let mut max_x = num::zero();
			let mut max_y = num::zero();
			for &amp;Point(x, y) in &amp;self.dots {
				if x &gt; max_x {
					max_x = x;
				}
				if y &gt; max_y {
					max_y = y;
				}
			}
			(max_x, max_y)
		};
		for y in num::range_step_inclusive(num::zero(), max_y, num::one()) {
			for x in num::range_step_inclusive(num::zero(), max_x, num::one()) {
				f.write_str(if self.dots.contains(&amp;Point(x, y)) {
					"█" // unicode "full block" 0x2588
				} else {
					" "
				})?;
			}
			f.write_str("\n")?;
		}

		Ok(())
	}
}

fn pt2&lt;T: Integer + CheckedAdd + Clone + Copy, F: std::borrow::Borrow&lt;Fold&lt;T&gt;&gt;&gt;(
	paper: &amp;Paper&lt;T&gt;,
	folds: impl Iterator&lt;Item = F&gt;,
) -&gt; String {
	let ans = paper.do_folds(folds);
	println!("{}", ans);
	ans.to_string()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For once, the input is actually interesting!
It&#8217;s not enough to just “get the answer” (say, the positions of the dots at the end of the folding procedure); we have to print them out too so that we can read them.
Here was my output: <code>PGHZBFJC</code>.</p>
</div>
<div class="listingblock code-as-text">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">███   ██  █  █ ████ ███  ████   ██  ██
█  █ █  █ █  █    █ █  █ █       █ █  █
█  █ █    ████   █  ███  ███     █ █
███  █ ██ █  █  █   █  █ █       █ █
█    █  █ █  █ █    █  █ █    █  █ █  █
█     ███ █  █ ████ ███  █     ██   ██</code></pre>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/swift.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>