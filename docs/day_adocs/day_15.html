<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Day 15: Chiton</title>
<link rel="stylesheet" href="./../aoc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<!-- <script defer src="https://use.fontawesome.com/releases/v5.0.4/js/all.js"></script> -->
<link rel="preconnect" href="https://fonts.googleapis.com" /><link
	rel="preconnect"
	href="https://fonts.gstatic.com"
	crossorigin
/><link
	href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&family=Source+Serif+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap"
	rel="stylesheet"
/>

<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"
	integrity="sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw"
	crossorigin="anonymous"
/>

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js"
	integrity="sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH"
	crossorigin="anonymous"
></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js"
	integrity="sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v"
	crossorigin="anonymous"
	onload="renderMathInElement(document.body);"
></script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p><a href="../advent_of_code_2021.html#_problems_and_solutions" class="header-nav-link first"><span class="icon"><i class="fa fa-list-ol"></i></span> Back to Home</a>
<a href="././day_14.html" class="header-nav-link"><span class="icon"><i class="fa fa-chevron-left"></i></span> Previous (Day 14)</a>
<a href="././day_16.html" class="header-nav-link">Next (Day 16) <span class="icon"><i class="fa fa-chevron-right"></i></span></a></p>
</div>
<div class="sect1">
<h2 id="_day_15_chiton">Day 15: Chiton</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/15" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day 15 problem description</a> │ <a href="../../src/day_15/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>Given a grid of numbers, this problem asks us to find the path from the grid&#8217;s top left corner to its bottom right corner that minimizes the sum of all numbers used in the path, which we will call the path&#8217;s <em>cost</em>.
This is a classic CS problem which can be solved with the <a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="noopener">A* Algorithm</a>.
My initial solution used a (max-) <a href="https://docs.rs/priority-queue/latest/priority_queue/" target="_blank" rel="noopener">priority queue</a> to choose the next node to examine, with priority equal to the (negative of the) total cost of the path up to that node.
While this solution worked, it took an inordinate amount of time on the larger input, which was 500×500.
(I suspect that this was due to the fact that the implementation of that priority queue uses a <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" target="_blank" rel="noopener"><code>HashMap</code></a> instead of a (perhaps) more optimal structure such as a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html" target="_blank" rel="noopener"><code>BTreeMap</code></a>.
I also didn&#8217;t really feel like seeing if I could speed it up with a faster hasher.
And I definitely didn&#8217;t want to implement my own priority queue with a <code>BTreeMap</code> instead.)</p>
</div>
<div class="paragraph">
<p>Despite being theoretically suboptimal, my second solution performed much faster.
This new solution was simply to maintain a grid of tentative costs to reach each number on the grid.
This grid of tentative costs was initially set to <code>u32::MAX</code>, except for the top left corner which was set to <code>0</code>.
On each iteration, for each node \(P\) in the grid, we examine \(P\)’s four neighbors.
If the cost to reach a neighbor through \(P\) is cheaper than the neighbor&#8217;s current tentative cost, we replace the latter cost with the former cost.
We repeat this process until no modifications are made to any tentative cost, at which point the answer is simply the cost of reaching the bottom right corner.</p>
</div>
<hr>
<div class="sect2">
<h3 id="_setup">Setup</h3>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use crate::Answer;
use ndarray::prelude::*;

type Cost = u32;
type Grid = Array2&lt;Cost&gt;;
type Coords = (usize, usize);

fn read_input(input: &amp;str) -&gt; Option&lt;Grid&gt; {
	let mut lines = input.lines();

	let mut grid = vec![];

	let first_line = lines.next()?;
	for c in first_line.chars() {
		grid.push(c.to_digit(10)? as Cost);
	}
	let n_cols = grid.len();

	for line in lines {
		for c in line.chars() {
			grid.push(c.to_digit(10)? as Cost);
		}
	}

	let n_rows = grid.len() / n_cols;
	assert_eq!(n_rows * n_cols, grid.len());

	Array2::from_shape_vec((n_rows, n_cols), grid).ok()
}

enum Direction {
	N,
	S,
	E,
	W,
}

impl Direction {
	fn stepping_from(&amp;self, grid: &amp;Grid, (from_row, from_col): Coords) -&gt; Option&lt;Coords&gt; {
		use Direction::*;

		let (min_row, min_col) = (0, 0);
		let (n_rows, n_cols) = grid.dim();
		let max_row = n_rows - 1;
		let max_col = n_cols - 1;

		let new_row = match self {
			N if from_row == min_row =&gt; return None,
			N =&gt; from_row - 1,
			S if from_row == max_row =&gt; return None,
			S =&gt; from_row + 1,
			_ =&gt; from_row,
		};

		let new_col = match self {
			W if from_col == min_col =&gt; return None,
			W =&gt; from_col - 1,
			E if from_col == max_col =&gt; return None,
			E =&gt; from_col + 1,
			_ =&gt; from_col,
		};

		Some((new_row, new_col))
	}
}

fn traversal_cost(entry_costs: &amp;Grid) -&gt; Cost {
	use Direction::*;

	let (n_rows, n_cols) = entry_costs.dim();
	let max_row = n_rows - 1;
	let max_col = n_cols - 1;

	let mut net_travel_costs = Grid::from_shape_simple_fn((n_rows, n_cols), || Cost::MAX);
	net_travel_costs[(0, 0)] = 0;

	let max_dist = max_row + max_col;
	loop {
		let mut did_modify = false;

		for dist in 0..=max_dist {
			let r_min = if dist &lt; max_col { 0 } else { dist - max_col };
			let r_max = dist.min(max_row);

			for r in r_min..=r_max {
				let c = dist - r;

				let net_cost_to_travel_here = net_travel_costs[(r, c)];

				// One of the perks of moving diagonally, down and to the right, is that
				// this assertion holds (which means the following (necessary) loop isn't
				// pointless)
				assert_ne!(net_cost_to_travel_here, Cost::MAX);

				for dir in [N, S, E, W] {
					let nghbr_coords = match dir.stepping_from(entry_costs, (r, c)) {
						Some(nghbr_coords) =&gt; nghbr_coords,
						None =&gt; continue,
					};

					let net_cost_to_travel_to_nghbr_thru_here =
						net_cost_to_travel_here + entry_costs[nghbr_coords];

					if net_cost_to_travel_to_nghbr_thru_here &lt; net_travel_costs[nghbr_coords] {
						net_travel_costs[nghbr_coords] = net_cost_to_travel_to_nghbr_thru_here;
						did_modify = true;
					}
				}
			}
		}

		if !did_modify {
			return net_travel_costs[(max_row, max_col)];
		}
	}
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;Cost, Cost&gt; {
	let grid = read_input(input).unwrap();
	(15, (pt1(&amp;grid), pt2(&amp;grid))).into()
}

pub fn ans() -&gt; Answer&lt;Cost, Cost&gt; {
	ans_for_input(include_str!("input.txt"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_1">Part 1</h3>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt1(grid: &amp;Grid) -&gt; Cost {
	traversal_cost(grid)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_2">Part 2</h3>
<div class="paragraph">
<p>Part 2 asked us not just to traverse the grid, but to construct a larger grid to use as our input, which was formed by concatenating modified copies of Part 1&#8217;s input.
This falls under “boring array manipulation”, so I won&#8217;t discuss it further.</p>
</div>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn expand_grid(grid: &amp;Grid, k: usize) -&gt; Grid {
	let (n_rows, n_cols) = grid.dim();
	let mut new_grid = Array2::from_shape_simple_fn((k * n_rows, k * n_cols), || 0);

	// Arrays are in row major order, so that's the order we iterate in (for cache-friendliness)
	for outer_r in 0..k {
		for inner_r in 0..n_rows {
			for outer_c in 0..k {
				for inner_c in 0..n_cols {
					let old_cost = grid[(inner_r, inner_c)];

					let d_cost = Cost::try_from(outer_r + outer_c).unwrap();
					let new_cost = (old_cost + d_cost - 1) % 9 + 1;

					let new_grid_r = outer_r * n_rows + inner_r;
					let new_grid_c = outer_c * n_cols + inner_c;

					new_grid[(new_grid_r, new_grid_c)] = new_cost;
				}
			}
		}
	}

	new_grid
}

fn pt2(grid: &amp;Grid) -&gt; Cost {
	let grid = expand_grid(grid, 5);
	traversal_cost(&amp;grid)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/swift.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>