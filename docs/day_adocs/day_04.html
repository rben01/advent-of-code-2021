<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Day 4: Giant Squid</title>
<link rel="stylesheet" href="./../aoc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<!-- <script defer src="https://use.fontawesome.com/releases/v5.0.4/js/all.js"></script> -->
<link rel="preconnect" href="https://fonts.googleapis.com" /><link
	rel="preconnect"
	href="https://fonts.gstatic.com"
	crossorigin
/><link
	href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&family=Source+Serif+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap"
	rel="stylesheet"
/>

<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"
	integrity="sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw"
	crossorigin="anonymous"
/>

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js"
	integrity="sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH"
	crossorigin="anonymous"
></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js"
	integrity="sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v"
	crossorigin="anonymous"
	onload="renderMathInElement(document.body);"
></script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p><a href="../advent_of_code_2021.html#_problems_and_solutions" class="header-nav-link first"><span class="icon"><i class="fa fa-list-ol"></i></span> Back to Home</a>
<a href="././day_03.html" class="header-nav-link"><span class="icon"><i class="fa fa-chevron-left"></i></span> Previous (Day 3)</a>
<a href="././day_05.html" class="header-nav-link">Next (Day 5) <span class="icon"><i class="fa fa-chevron-right"></i></span></a></p>
</div>
<div class="sect1">
<h2 id="_day_4_giant_squid">Day 4: Giant Squid</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/4" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day 4 problem description</a> â”‚ <a href="../../src/day_04/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>The game is represented as a list of boards and a list of drawn numbers.
Each board has:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A dictionary <code>grid</code> that maps undrawn numbers on the board to their Cartesian coordinates (a pair <code>(row, col)</code>) on the board.
When a number is drawn, its Cartesian coordinates are used to update <code>progress</code> (below), and then the number is removed from the dictionary.</p>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The only reason drawn numbers are removed from a board&#8217;s dictionary is that Advent of Code asks for the sum of the board&#8217;s undrawn numbers to compute the answer, so we need to keep track of which numbers on a given board haven&#8217;t been drawn yet.
Otherwise, we&#8217;d have had no reason to mutate the dictionary at all.</p>
</div>
</div>
</div>
</li>
<li>
<p><code>progress</code>, which stores for each row and column the count of numbers in that row/column have not yet been drawn.
If one of those counts hit zero, then every number in that row/column has been drawn, and so the board has a "Bingo" (i.e., has won).</p>
<div class="paragraph">
<p>The row and column indices have the same meaning as the Cartesian coordinates in the dictionary described above: if number 25 is drawn, and 25&#8217;s position on a particular board is <code>(2, 3)</code>, then <code>progress.rows[2]</code> and <code>progress.cols[3]</code> each get decremented.</p>
</div>
</li>
</ol>
</div>
<hr>
<div class="sect2">
<h3 id="_setup">Setup</h3>
<div class="paragraph">
<p>Reading the input text into a game (numbers and boards) is in <code>read_input_into_game</code>, whose (not particularly interesting) implementation should serve as its docs.
<code>get_answer_from_final_game_state</code> is just used to prove to Advent of Code that we actually got the solution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use crate::Answer;
use num::{integer::div_mod_floor, Integer};
use std::{
	collections::{BTreeMap as Map, BTreeSet as Set},
	str::FromStr,
};

#[derive(Debug)]
struct BoardProgress {
	rows: Vec&lt;usize&gt;,
	cols: Vec&lt;usize&gt;,
	has_won: bool,
}

impl BoardProgress {
	fn new(n_rows: usize, n_cols: usize) -&gt; Self {
		let rows = vec![n_cols; n_rows];
		let cols = vec![n_rows; n_cols];
		Self {
			rows,
			cols,
			has_won: false,
		}
	}

	fn handle_entry(&amp;mut self, row: usize, col: usize) {
		if self.has_won {
			return;
		}

		self.rows[row] -= 1;
		self.cols[col] -= 1;

		if self.rows[row] == 0 || self.cols[col] == 0 {
			self.has_won = true;
		}
	}
}

#[derive(Debug)]
struct Board&lt;T: Integer&gt; {
	grid: Map&lt;T, (usize, usize)&gt;,
	progress: BoardProgress,
}

impl&lt;T: Integer + std::iter::Sum + Copy&gt; Board&lt;T&gt; {
	fn new(nums: &amp;[T], n_cols: usize) -&gt; Self {
		let n_rows = nums.len() / n_cols;
		assert_eq!(n_rows * n_cols, nums.len());

		let mut grid = Map::new();
		for (i, &amp;x) in nums.iter().enumerate() {
			let (r, c) = div_mod_floor(i, n_cols);
			grid.insert(x, (r, c));
		}
		Self {
			grid,
			progress: BoardProgress::new(n_rows, n_cols),
		}
	}

	fn play_number(&amp;mut self, n: T) {
		let (r, c) = match self.grid.remove(&amp;n) {
			Some(coords) =&gt; coords,
			None =&gt; return,
		};
		self.progress.handle_entry(r, c);
	}

	fn has_won(&amp;self) -&gt; bool {
		self.progress.has_won
	}

	fn get_ans(&amp;self, winning_num: T) -&gt; T {
		let unmarked_sum = self.grid.keys().copied().sum::&lt;T&gt;();
		winning_num * unmarked_sum
	}
}

struct Game&lt;T: Integer&gt; {
	boards: Vec&lt;Board&lt;T&gt;&gt;,
	numbers: Vec&lt;T&gt;,
}

impl&lt;T: Integer + std::iter::Sum + Copy + FromStr + std::fmt::Debug&gt; Game&lt;T&gt; {
	fn from_str(s: &amp;str) -&gt; Option&lt;Self&gt; {
		let mut lines = s.lines().chain(std::iter::once(""));
		let nums = lines
			.next()?
			.split(',')
			.map(|s| s.parse::&lt;T&gt;().ok())
			.collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()?;

		let mut boards = vec![];
		let mut this_board = vec![];

		let mut n_cols = None;

		for line in lines {
			if line.is_empty() {
				if !this_board.is_empty() {
					let board = Board::new(this_board.as_slice(), n_cols.unwrap());
					boards.push(board);
					this_board.clear();
				}
			} else {
				for num in line.split_whitespace().map(|s| s.parse::&lt;T&gt;().ok()) {
					let num = num?;
					this_board.push(num);
				}
				if matches!(n_cols, None) {
					n_cols = Some(this_board.len());
				}
			}
		}

		Some(Self {
			boards,
			numbers: nums,
		})
	}
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;i32, i32&gt; {
	let [game1, game2] = [0; 2].map(|_| Game::from_str(input).unwrap());
	(4, (pt1(game1), pt2(game2))).into()
}

pub fn ans() -&gt; Answer&lt;i32, i32&gt; {
	ans_for_input(include_str!("input.txt"))
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_1">Part 1</h3>
<div class="paragraph">
<p>We simply draw numbers until a board has won, then get the answer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt1(mut game: Game&lt;i32&gt;) -&gt; i32 {
	for &amp;num in &amp;game.numbers {
		for board in &amp;mut game.boards {
			board.play_number(num);
			if board.has_won() {
				return board.get_ans(num);
			}
		}
	}
	unreachable!();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_2">Part 2</h3>
<div class="paragraph">
<p>This time, we keep track of all of the boards that haven&#8217;t won yet.
When the last un-won boards wins, we use it to compute the answer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt2(mut game: Game&lt;i32&gt;) -&gt; i32 {
	let mut ongoing_game_idxs = (0..game.boards.len()).collect::&lt;Set&lt;_&gt;&gt;();

	for &amp;num in &amp;game.numbers {
		for (board_idx, board) in game.boards.iter_mut().enumerate() {
			let already_won = !ongoing_game_idxs.contains(&amp;board_idx);
			if already_won {
				continue;
			}

			board.play_number(num);
			if board.has_won() {
				if ongoing_game_idxs.len() == 1 {
					return board.get_ans(num);
				}

				ongoing_game_idxs.remove(&amp;board_idx);
			}
		}
	}
	unreachable!();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/swift.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>