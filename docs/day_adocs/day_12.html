<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Day 12: Passage Pathing</title>
<link rel="stylesheet" href="./../aoc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<!-- <script defer src="https://use.fontawesome.com/releases/v5.0.4/js/all.js"></script> -->
<link rel="preconnect" href="https://fonts.googleapis.com" /><link
	rel="preconnect"
	href="https://fonts.gstatic.com"
	crossorigin
/><link
	href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Source+Code+Pro:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
	rel="stylesheet"
/>

<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"
	integrity="sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw"
	crossorigin="anonymous"
/>

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js"
	integrity="sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH"
	crossorigin="anonymous"
></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js"
	integrity="sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v"
	crossorigin="anonymous"
	onload="renderMathInElement(document.body);"
></script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p><a href="../advent_of_code_2021.html#_problems_and_solutions" class="header-nav-link first"><span class="icon"><i class="fa fa-list-ol"></i></span> Back to Home</a>
<a href="././day_11.html" class="header-nav-link"><span class="icon"><i class="fa fa-chevron-left"></i></span> Previous (Day 11)</a>
<a href="././day_13.html" class="header-nav-link">Next (Day 13) <span class="icon"><i class="fa fa-chevron-right"></i></span></a></p>
</div>
<div class="sect1">
<h2 id="_day_12_passage_pathing">Day 12: Passage Pathing</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/12" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day 12 problem description</a> | <a href="../../src/day_12/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>Finally, a problem that isn&#8217;t just about array manipulation.
This problem asks us to count the number of paths from the origin node of an undirected graph to the destination node, with constraints on how many times we may visit certain nodes, but no constraints on how many times we may use an edge.
(Note that the problem has us exploring an underwater cave system, so the source code below refers to nodes as “caves”.)
Nodes are classified as either “big” or “small”, depending on the case of their name in the input.
A big node can be visited arbitrarily many times, whereas a small node can only be visited a limited number of times.
(If two big nodes were adjacent, then there would be infinitely many paths through the graph since because we could just bounce back and forth between them forever.)</p>
</div>
<div class="paragraph">
<p>First, we must build the graph.
We ingest the list of edges into a dictionary mapping each node to the set of nodes reachable from it.
After doing this we traverse the graph.
We maintain a stack representing the current path; we push onto the stack from the choices in the current node&#8217;s entry in the dictionary, and when we&#8217;ve exhausted all of the edges available from the current node, we pop the current node.
We don&#8217;t actually maintain a stack in the code; we merely use the call stack.</p>
</div>
<hr>
<div class="openblock">
<div class="title">Setup</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use crate::Answer;
use std::collections::BTreeMap as Map;

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
enum CaveKind {
	Big,
	Small,
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
struct Cave&lt;'a&gt; {
	name: &amp;'a str,
	kind: CaveKind,
}

impl&lt;'a&gt; Cave&lt;'a&gt; {
	fn new(name: &amp;'a str) -&gt; Self {
		let is_small = name.chars().map(|c| c.is_ascii_lowercase()).all(|b| b);
		let kind = if is_small {
			CaveKind::Small
		} else {
			CaveKind::Big
		};
		Self { name, kind }
	}
}

#[derive(Debug)]
struct CaveSystem&lt;'a&gt; {
	edges: Map&lt;&amp;'a str, Vec&lt;Cave&lt;'a&gt;&gt;&gt;,
}

impl&lt;'a&gt; CaveSystem&lt;'a&gt; {
	fn from_str(input: &amp;'a str) -&gt; Option&lt;Self&gt; {
		let mut edges = Map::new();
		for line in input.lines() {
			let mut splat = line.split('-');
			let left = splat.next()?;
			let right = splat.next()?;

			for (orig, dest) in [(left, right), (right, left)] {
				if orig != "end" &amp;&amp; dest != "start" {
					edges
						.entry(orig)
						.or_insert_with(Vec::new)
						.push(Cave::new(dest));
				}
			}
		}

		Some(Self { edges })
	}
}

impl&lt;'a&gt; CaveSystem&lt;'a&gt; {
	fn traverse_helper(
		&amp;'a self,
		curr_cave: &amp;'a str,
		n_finished: &amp;mut usize,
		cave_visit_counts: &amp;mut Map&lt;&amp;'a str, usize&gt;,
		can_visit_one_small_cave_twice: bool,
		has_visited_a_small_cave_twice: bool,
	) {
		for next_cave in &amp;self.edges[curr_cave] {
			if next_cave.name == "end" {
				*n_finished += 1;
				continue;
			}

			let this_dest_n_visits = cave_visit_counts.entry(next_cave.name).or_insert(0);

			let is_small_cave = next_cave.kind == CaveKind::Small;
			if is_small_cave
				&amp;&amp; (*this_dest_n_visits &gt;= 1
					&amp;&amp; (!can_visit_one_small_cave_twice || has_visited_a_small_cave_twice))
			{
				continue;
			}

			*this_dest_n_visits += 1;
			let n_visits = *this_dest_n_visits;

			self.traverse_helper(
				next_cave.name,
				n_finished,
				cave_visit_counts,
				can_visit_one_small_cave_twice,
				has_visited_a_small_cave_twice || is_small_cave &amp;&amp; n_visits &gt;= 2,
			);

			// "un-visit" this cave for the next loop iteration
			cave_visit_counts
				.entry(next_cave.name)
				.and_modify(|v| *v -= 1);
		}
	}

	fn traverse(&amp;'a self, can_visit_one_small_cave_twice: bool) -&gt; usize {
		let mut n_finished = 0;
		let mut cave_visit_counts = Map::new();

		self.traverse_helper(
			"start",
			&amp;mut n_finished,
			&amp;mut cave_visit_counts,
			can_visit_one_small_cave_twice,
			false,
		);

		n_finished
	}
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;usize, usize&gt; {
	let cave_system = CaveSystem::from_str(input).unwrap();
	(12, (pt1(&amp;cave_system), pt2(&amp;cave_system))).into()
}

pub fn ans() -&gt; Answer&lt;usize, usize&gt; {
	ans_for_input(include_str!("input.txt"))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="title">Parts 1 and 2</div>
<p>In Part 1, we may only visit each small node at most once.
Part 2 is slightly more relaxed; in addition to the paths visiting each small node at most once, valid paths now include those in which a single small node is visited a second time.
But this wrinkle was already handled in the Setup section; we switch the behavior with a single boolean argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt1(cave: &amp;CaveSystem) -&gt; usize {
	cave.traverse(false)
}

fn pt2(cave: &amp;CaveSystem) -&gt; usize {
	cave.traverse(true)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/swift.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>