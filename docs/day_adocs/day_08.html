<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Day 8: Seven Segment Search</title>
<link rel="stylesheet" href="./../aoc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<!-- <script defer src="https://use.fontawesome.com/releases/v5.0.4/js/all.js"></script> -->
<link rel="preconnect" href="https://fonts.googleapis.com" /><link
	rel="preconnect"
	href="https://fonts.gstatic.com"
	crossorigin
/><link
	href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Source+Code+Pro:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
	rel="stylesheet"
/>

<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"
	integrity="sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw"
	crossorigin="anonymous"
/>

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js"
	integrity="sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH"
	crossorigin="anonymous"
></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js"
	integrity="sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v"
	crossorigin="anonymous"
	onload="renderMathInElement(document.body);"
></script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p><a href="../advent_of_code_2021.html#_problems_and_solutions" class="header-nav-link first"><span class="icon"><i class="fa fa-list-ol"></i></span> Back to Home</a>
<a href="././day_7.html" class="header-nav-link"><span class="icon"><i class="fa fa-chevron-left"></i></span> Previous (Day 7)</a>
<a href="././day_9.html" class="header-nav-link">Next (Day 9) <span class="icon"><i class="fa fa-chevron-right"></i></span></a></p>
</div>
<div class="sect1">
<h2 id="_day_8_seven_segment_search">Day 8: Seven Segment Search</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/8" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day 8 problem description</a> │ <a href="../../src/day_08/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>What an interesting problem!
We are asked to deduce the manner in which a computer has been incorrectly hooked up to a <a href="https://en.wikipedia.org/wiki/Seven-segment_display" target="_blank" rel="noopener">seven-segment display</a> (7SD):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Seven_segment_01_Pengo.jpg/485px-Seven_segment_01_Pengo.jpg" alt="A seven-segment display chip with pins showing" width="300">
</div>
</div>
<div class="paragraph">
<p>We will use the following display schematic, with the segments labeled A–G:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">  0:      1:      2:      3:      4:
 AAAA            AAAA    AAAA
B    C       C       C       C  B    C
B    C       C       C       C  B    C
                 DDDD    DDDD    DDDD
E    F       F  E            F       F
E    F       F  E            F       F
 GGGG            GGGG    GGGG

  5:      6:      7:      8:      9:
 AAAA    AAAA    AAAA    AAAA    AAAA
B       B            C  B    C  B    C
B       B            C  B    C  B    C
 DDDD    DDDD            DDDD    DDDD
     F  E    F       F  E    F       F
     F  E    F       F  E    F       F
 GGGG    GGGG            GGGG    GGGG</code></pre>
</div>
</div>
<div class="paragraph">
<p>The computer sends a stream of digits that we see as various patterns of lit segments on the 7SD.
The computer has the correct logic to display digits, but its wires to the 7SD got crossed during setup, so the digits it attempts to display end up looking like gibberish to us.
But because the computer&#8217;s underlying logic still holds, we can still deduce things from its output.
For instance, if it lights up only two segments, we know that it is trying to display a 1 (because 1 is the only digit made of exactly two segments), and so the two segments it lit up <em>should</em> be rewired to the two segments <code>CF</code> (although we still don&#8217;t know in which order).
If it lights up five segments, then it could be trying to display either a 2 (<code>ACDEG</code>), 3 (<code>ACDFG</code>), or 5 (<code>ABDFG</code>).
By observing the patterns it lights up, and using our knowledge of how the digits 0–9 should have been displayed, we can deduce the full wiring scheme and how the computer must be rewired to the display in order to function correctly.</p>
</div>
<div class="paragraph">
<p>The only other wrinkle is we don&#8217;t even get to tell the computer which digits to attempt to display; that is entirely up to it.
We simply receive a stream of <em>some</em> digits, and from that must deduce the wiring scheme.</p>
</div>
<div class="paragraph">
<div class="title">The Solution</div>
<p>The strategy is as follows: for each garbled digit we see, record its pattern and the list of candidate digits (those having the same number of segments turned on).
Then, by taking set differences and intersections between the patterns seen and their candidates, we can derive more specific information about the rewiring.
For instance:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Suppose the computer sends two digits and lights up <code>ABD</code> and <code>AB</code>.
<code>ABD</code> only has one candidate, 7 (<code>ACF</code>), because only 7 has three segments turned on.
<code>AB</code> only has one candidate, 1 (<code>CF</code>), because only 1 has two segments turned on.
Then we take the difference of the displayed segments — <code>ABD − AB = D</code> — and all pairwise differences between their corresponding candidates (just one in this case) — <code>ACF − CF = A</code> — to deduce that <code>D</code> must be rewired to <code>A</code>.
We continue this logic, subtracting (say) the map <code>D ➜ A</code> from other display-candidate pairs to narrow <em>them</em> down.
We are done when we know the one segment that each segment needs to be rewired to.</p>
</li>
<li>
<p>Suppose the computer sends <code>ABCDE</code>; its candidates would be 2 (<code>ACDEG</code>), 3 (<code>ACDFG</code>), and 5 (<code>ABDFG</code>).
If it then sends <code>DEF</code>, its candidates would be just 7 (<code>ACF</code>).
The intersection of the two sent digits is <code>DE</code>.
Taking the pairwise intersections between the candidates, and keeping only those with the same length as <code>DE</code>, we see that the candidates for <code>DE</code> are <code>AC</code> and <code>AF</code>.
Subtracting <code>D ➜ A</code> from this, we deduce that <code>E</code> must be mapped to either <code>C</code> or <code>F</code>.
Subtracting <code>D ➜ A</code> and <code>E ➜ C|F</code> from <code>DEF ➜ ACF</code>, we see that <code>F ➜ C|F</code> as well.</p>
</li>
<li>
<p>Continuing this way, we can eventually deduce all the mappings.</p>
</li>
</ol>
</div>
<hr>
<div class="paragraph">
<div class="title">Setup</div>
<p>First, we model the notion of a digit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct Digit {
	segments: [bool; N_SEGMENTS],
	n_on: usize,
}

impl Digit {
	fn new(segments: [bool; N_SEGMENTS]) -&gt; Self {
		Self {
			segments,
			n_on: segments.iter().filter(|&amp;&amp;b| b).count(),
		}
	}

	fn from_str(s: &amp;str) -&gt; Self {
		let mut segments = [false; N_SEGMENTS];
		for c in s.bytes() {
			let i = c - b'a';
			segments[usize::from(i)] = true;
		}
		Self::new(segments)
	}

	fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -&gt; bool) -&gt; Self {
		Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y)))
	}
}

impl std::ops::BitOr for Digit {
	type Output = Self;
	fn bitor(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x | y)
	}
}

impl std::ops::BitAnd for Digit {
	type Output = Self;
	fn bitand(self, rhs: Self) -&gt; Self::Output {
		self._bin_op(rhs, |x, y| x &amp; y)
	}
}

impl std::ops::Not for Digit {
	type Output = Self;
	fn not(self) -&gt; Self::Output {
		Self::new(self.segments.map(|b| !b))
	}
}

impl From&lt;usize&gt; for Digit {
	fn from(n: usize) -&gt; Self {
		let segments = match n {
			/*
			-----[A, B, C, D, E, F, G]
			*/
			0 =&gt; [1, 1, 1, 0, 1, 1, 1],
			1 =&gt; [0, 0, 1, 0, 0, 1, 0],
			2 =&gt; [1, 0, 1, 1, 1, 0, 1],
			3 =&gt; [1, 0, 1, 1, 0, 1, 1],
			4 =&gt; [0, 1, 1, 1, 0, 1, 0],
			5 =&gt; [1, 1, 0, 1, 0, 1, 1],
			6 =&gt; [1, 1, 0, 1, 1, 1, 1],
			7 =&gt; [1, 0, 1, 0, 0, 1, 0],
			8 =&gt; [1, 1, 1, 1, 1, 1, 1],
			9 =&gt; [1, 1, 1, 1, 0, 1, 1],
			_ =&gt; panic!("Cannot make digit for n={}", n),
		};
		let segments = segments.map(|i| i != 0);
		Self::new(segments)
	}
}

impl From&lt;Digit&gt; for usize {
	fn from(digit: Digit) -&gt; Self {
		let segments = digit.segments.map(u8::from);
		match segments {
			/*
			[A, B, C, D, E, F, G]
			*/
			[1, 1, 1, 0, 1, 1, 1] =&gt; 0,
			[0, 0, 1, 0, 0, 1, 0] =&gt; 1,
			[1, 0, 1, 1, 1, 0, 1] =&gt; 2,
			[1, 0, 1, 1, 0, 1, 1] =&gt; 3,
			[0, 1, 1, 1, 0, 1, 0] =&gt; 4,
			[1, 1, 0, 1, 0, 1, 1] =&gt; 5,
			[1, 1, 0, 1, 1, 1, 1] =&gt; 6,
			[1, 0, 1, 0, 0, 1, 0] =&gt; 7,
			[1, 1, 1, 1, 1, 1, 1] =&gt; 8,
			[1, 1, 1, 1, 0, 1, 1] =&gt; 9,
			_ =&gt; panic!("Digit {:?} is not valid", digit),
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">The Algorithm</div>
<p>We repeatedly take the intersection and set-differences between digits, getting a more and more refined mapping until finally we are left with a 1:1 mapping.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use crate::Answer;
use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set};

const N_SEGMENTS: usize = 7;
fn get_mapping_from_garbled_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	garbled_digits: impl Iterator&lt;Item = D&gt;,
) -&gt; Result&lt;Map&lt;Digit, Digit&gt;, Map&lt;Digit, Set&lt;Digit&gt;&gt;&gt; {
	let mut mappings = Map::new();

	{
		let mut grouped_by_n_on = Map::new();
		for n in 0..=9 {
			let digit = Digit::from(n);
			grouped_by_n_on
				.entry(digit.n_on)
				.or_insert_with(Set::new)
				.insert(digit);
		}

		for gd in garbled_digits {
			let gd = *gd.borrow();
			let digits_w_same_n_segments = &amp;grouped_by_n_on[&amp;gd.n_on];
			mappings.insert(gd, digits_w_same_n_segments.clone());
		}
	}

	let identity: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| x);
	let bitwise_not: &amp;dyn Fn(Digit) -&gt; _ = &amp;(|x| !x);

	loop {
		let mut new_mappings = Map::new();

		for (i, (&amp;garbled1, choices1)) in mappings.iter().enumerate() {
			for (&amp;garbled2, choices2) in mappings.iter().skip(i + 1) {
				for (op1, op2) in [
					(identity, identity),
					(identity, bitwise_not),
					(bitwise_not, identity),
				] {
					let new_garbled = op1(garbled1) &amp; op2(garbled2);

					if new_garbled.n_on == 0 {
						continue;
					}

					let mut new_good_candidates = Set::new();
					for &amp;good_digit1 in choices1 {
						for &amp;good_digit2 in choices2 {
							let candidate = op1(good_digit1) &amp; op2(good_digit2);
							if candidate.n_on == new_garbled.n_on {
								new_good_candidates.insert(candidate);
							}
						}
					}

					match new_mappings.entry(new_garbled) {
						MapEntry::Vacant(v) =&gt; {
							v.insert(new_good_candidates);
						}
						MapEntry::Occupied(mut o) =&gt; {
							o.insert(o.get() &amp; &amp;new_good_candidates);
						}
					}
				}
			}
		}

		// Remove all keys that can be written as the disjoint-bitwise-or of two other
		// keys, as they're redundant. This means if e.g., A and BC are present, then
		// remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB
		// and BC are not disjoint)
		let mut redundant_keys = Set::new();
		let new_garbled_keys = new_mappings.keys().copied().collect::&lt;Set&lt;_&gt;&gt;();
		for (i, &amp;garbled1) in new_garbled_keys.iter().enumerate() {
			for &amp;garbled2 in new_garbled_keys.iter().skip(i + 1) {
				if (garbled1 &amp; garbled2).n_on != 0 {
					continue;
				}
				let segment_union = garbled1 | garbled2;
				if new_garbled_keys.contains(&amp;segment_union) {
					redundant_keys.insert(segment_union);
				}
			}
		}

		for k in &amp;redundant_keys {
			new_mappings.remove(k);
		}

		if mappings.len() == N_SEGMENTS &amp;&amp; mappings.values().all(|m| m.len() == 1) {
			return Ok(mappings
				.into_iter()
				.map(|(k, v)| (k, v.iter().next().copied().unwrap()))
				.collect());
		} else if mappings == new_mappings {
			return Err(mappings);
		}

		mappings = new_mappings;
	}
}

fn apply_mapping_to_garbled_digit(mapping: &amp;Map&lt;Digit, Digit&gt;, garbled_digit: Digit) -&gt; usize {
	let mut result = Digit::new([false; 7]);
	for (&amp;k, &amp;v) in mapping {
		if (garbled_digit &amp; k).n_on &gt; 0 {
			result = result | v;
		}
	}
	result.into()
}

fn read_input(input: &amp;str) -&gt; Vec&lt;(Vec&lt;Digit&gt;, Vec&lt;Digit&gt;)&gt; {
	fn whitespace_sepd_strs_to_digits(strs: &amp;str) -&gt; Vec&lt;Digit&gt; {
		strs.trim()
			.split_ascii_whitespace()
			.map(Digit::from_str)
			.collect()
	}
	input
		.lines()
		.filter_map(|line| {
			let line = line.trim();
			if line.is_empty() {
				return None;
			}
			let mut in_out = line.split('|');
			let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?);
			Some((in_digits, out_digits))
		})
		.collect()
}

fn translate_line_to_digits&lt;D: std::borrow::Borrow&lt;Digit&gt;&gt;(
	idod: (impl Iterator&lt;Item = D&gt;, impl Iterator&lt;Item = D&gt;),
) -&gt; Option&lt;Vec&lt;usize&gt;&gt; {
	let (in_digits, out_digits) = idod;

	let mapping = get_mapping_from_garbled_digits(in_digits).ok()?;
	Some(
		out_digits
			.map(|d| apply_mapping_to_garbled_digit(&amp;mapping, *d.borrow()))
			.collect(),
	)
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;usize, usize&gt; {
	let in_out_lines = read_input(input);

	let output_digits = in_out_lines
		.iter()
		.map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter())))
		.collect::&lt;Option&lt;Vec&lt;_&gt;&gt;&gt;()
		.unwrap();
	(8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into()
}

pub fn ans() -&gt; Answer&lt;usize, usize&gt; {
	ans_for_input(include_str!("input.txt"))
}</code></pre>
</div>
</div>
<div class="openblock">
<div class="title">Part 1</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt1&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.filter(|&amp;n| [1, 4, 7, 8].contains(n))
				.count()
		})
		.sum()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">Part 2</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt2&lt;Nums: AsRef&lt;[usize]&gt;&gt;(out_digits: impl Iterator&lt;Item = Nums&gt;) -&gt; usize {
	out_digits
		.map(|v| {
			v.as_ref()
				.iter()
				.rev()
				.enumerate()
				.map(|(pow10, &amp;val)| val * 10_usize.pow(u32::try_from(pow10).unwrap()))
				.sum::&lt;usize&gt;()
		})
		.sum()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/swift.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>