<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Snailfish</title>
<link rel="stylesheet" href="./../aoc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<!-- <script defer src="https://use.fontawesome.com/releases/v5.0.4/js/all.js"></script> -->
<link rel="preconnect" href="https://fonts.googleapis.com" /><link
	rel="preconnect"
	href="https://fonts.gstatic.com"
	crossorigin
/><link
	href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Source+Code+Pro:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
	rel="stylesheet"
/>

<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"
	integrity="sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw"
	crossorigin="anonymous"
/>

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js"
	integrity="sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH"
	crossorigin="anonymous"
></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script
	defer
	src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js"
	integrity="sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v"
	crossorigin="anonymous"
	onload="renderMathInElement(document.body);"
></script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p><a href="../advent_of_code_2021.html#_problems_and_solutions"><span class="icon"><i class="fa fa-list-ol"></i></span> Back to Home</a></p>
</div>
<div class="sect1">
<h2 id="_snailfish">Snailfish</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://adventofcode.com/2021/day/18" target="^"><span class="icon"><i class="fa fa-star-half-o"></i></span> Day 18 problem description</a> │ <a href="/src/day_18/input.txt" target="^"><span class="icon"><i class="fa fa-file-text-o"></i></span> Problem input</a></p>
</div>
<div class="paragraph">
<p>This problem asks us to parse a nested structure of pairs into a binary tree and then split or combine nodes according to a set of rules.
Rather than store the tree as an actual tree, which would be easy (maybe) but would suffer from poor cache locality, we store the nodes in a <code>Vec</code> and record the depth of each node.
This makes traversing and manipulating the tree much easier than if they were stored in a “real” tree; the nodes to the left and right of index <code>i</code> are simply those at <code>i-1</code> and <code>i+1</code>, respectively (if they exist).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#[derive(Debug, Clone, Copy, Eq, PartialEq)]
struct Elem {
	value: u32,
	depth: usize,
}

#[derive(Debug, PartialEq, Eq)]
struct SnailNum&lt;Elems: AsRef&lt;[Elem]&gt;&gt; {
	elems: Elems,
	depth: usize,
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The operations are performed as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Exploding</dt>
<dd>
<p>A pair is exploded by finding the first flat pair of depth at least four and storing the two values; the first is added to the node to the left and the second is added to the node to the right.
The second element of the pair is then deleted.</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">/// Explodes the first explode-able pair in the list. \
/// Returns the `Option` pair of `Option` indices of the elements to the left and right
/// (the ones being modified), in that order. `None` means there was no pair to explode;
/// `(None, Some(2))` means the exploded pair had no elements to the left of it (it
/// was at index 0), and the element to its right was added to
fn explode_first(&amp;mut self) -&gt; Option&lt;(Option&lt;usize&gt;, Option&lt;usize&gt;)&gt; {
	let elems = &amp;mut self.elems;

	let ((l_idx, l_elem), (r_idx, r_elem)) = elems
		.iter()
		.enumerate()
		.zip(elems.iter().enumerate().skip(1))
		.find_map(|((i1, &amp;e1), (i2, &amp;e2))| {
			if e1.depth &gt; 4 &amp;&amp; e1.depth == e2.depth {
				Some(((i1, e1), (i2, e2)))
			} else {
				None
			}
		})?;

	elems[l_idx] = Elem {
		value: 0,
		depth: l_elem.depth - 1,
	};

	let changed_l_idx = if l_idx &gt; 0 {
		let idx = l_idx - 1;
		elems[idx].value += l_elem.value;
		Some(idx)
	} else {
		None
	};

	elems.remove(r_idx);

	let changed_r_idx = if r_idx &lt; elems.len() {
		elems[r_idx].value += r_elem.value;
		Some(r_idx)
	} else {
		None
	};

	Some((changed_l_idx, changed_r_idx))
}</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Splitting</dt>
<dd>
<p>An element is split by simply dividing it by 2 twice, rounding down the first time and up the second time, and replacing the element with those two values.</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">/// Splits the first splittable pair in the list. \
/// Returns the index at which the split occurred, which is now the first element of the
/// resulting pair
fn split_first(&amp;mut self) -&gt; Option&lt;usize&gt; {
	let elems = &amp;mut self.elems;

	let (split_idx, Elem { value, depth }) =
		elems.iter().enumerate().find_map(|(i, &amp;elem)| {
			if elem.value &gt;= 10 {
				Some((i, elem))
			} else {
				None
			}
		})?;

	let new_l_value = value / 2;
	let new_r_value = (value + 1) / 2;

	let new_elem = Elem {
		value: new_l_value,
		depth: depth + 1,
	};
	elems[split_idx] = new_elem;

	elems.insert(
		split_idx + 1,
		Elem {
			value: new_r_value,
			depth: new_elem.depth,
		},
	);

	Some(split_idx)
}</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Adding</dt>
<dd>
<p>Two pairs are added by placing them in a containing pair.
This is manifested as simply concatenating the two vectors and then incrementing all the depths.
Notably, <em>addition is not associative</em>.</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn add(&amp;self, other: &amp;Self) -&gt; SnailNumOwned {
	let elems = self
		.elems
		.as_ref()
		.iter()
		.chain(other.elems.as_ref())
		.map(|&amp;Elem { value, depth }| Elem {
			value,
			depth: depth + 1,
		})
		.collect();

	let mut ans = SnailNumOwned::owning(elems);
	ans.reduce();
	ans
}</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Finding Pairs in the Vector</dt>
<dd>
<p>The only somewhat tricky part is determining the tree structure from the vector of depths.
A singleton is returned as an <code>Err</code> containing its value.
A “flat” pair (a pair whose elements are both atomic) appears as two consecutive elements of the same depth.
Non-flat pairs can be found by traversing the nodes from left to right, maintaining a stack of node depths, and, whenever the top two elements of the stack have the same depth \(d\), collapsing them into a single element with a depth of \(d-1\).
When a pair with elements of depth 1 is found, we have split the tree into its two top-level pairs.
If desired, we can then recurse on these to split the descendants into deeper pairs.</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn as_pair(&amp;self) -&gt; Result&lt;(SnailNumBorrowed, SnailNumBorrowed), u32&gt; {
	let elems = self.elems.as_ref();
	assert_ne!(elems.len(), 0, "{}", self.depth);

	if elems.len() == 1 {
		return Err(self.elems.as_ref()[0].value);
	}

	let mut depth_stack = vec![];
	for (i, &amp;Elem { depth, .. }) in elems.iter().enumerate() {
		depth_stack.push(depth);

		loop {
			match depth_stack.pop() {
				None =&gt; break,
				Some(curr_depth) =&gt; {
					if curr_depth == self.depth + 1 {
						let (left, right) = elems.split_at(i + 1);

						return Ok((
							SnailNum::borrowing(left, curr_depth),
							SnailNum::borrowing(right, curr_depth),
						));
					}

					match depth_stack.pop() {
						None =&gt; {
							depth_stack.push(curr_depth);
							break;
						}
						Some(prev_depth) =&gt; {
							if prev_depth == curr_depth {
								depth_stack.push(curr_depth - 1);
							} else {
								depth_stack.extend([prev_depth, curr_depth]);
								break;
							}
						}
					}
				}
			}
		}
	}
	unreachable!()
}</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Magnitude of a Pair</dt>
<dd>
<p>Self explanatory:</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn magnitude(&amp;self) -&gt; u32 {
	match self.as_pair() {
		Ok((left, right)) =&gt; 3 * left.magnitude() + 2 * right.magnitude(),
		Err(val) =&gt; val,
	}
}</code></pre>
</div>
</div>
</div>
</div>
</dd>
</dl>
</div>
<hr>
<div class="paragraph">
<div class="title">Setup</div>
<p>Functions listed above are omitted here.</p>
</div>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">use crate::Answer;
use std::fmt::{Debug, Display};

type SnailNumOwned = SnailNum&lt;Vec&lt;Elem&gt;&gt;;
type SnailNumBorrowed&lt;'a&gt; = SnailNum&lt;&amp;'a [Elem]&gt;;

impl SnailNumOwned {
	fn from_line(line: &amp;str) -&gt; Self {
		let mut addends = Vec::&lt;Elem&gt;::new();
		let mut depth = 0;
		let mut prev_was_digit = false;

		for c in line.trim().chars() {
			let mut c_is_digit = false;
			match c {
				'[' =&gt; depth += 1,
				']' =&gt; depth -= 1,
				'0'..='9' =&gt; {
					let digit = c.to_digit(10).unwrap();
					if prev_was_digit {
						let val = addends.last_mut().unwrap();
						val.value = 10 * val.value + digit;
					} else {
						addends.push(Elem {
							value: digit,
							depth,
						});
					}
					c_is_digit = true;
				}
				',' =&gt; {}
				_ =&gt; {
					panic!("Unexpected character {:?}", c);
				}
			}

			prev_was_digit = c_is_digit;
		}
		SnailNum::owning(addends)
	}

	fn by_adding_lines_in&lt;S: AsRef&lt;str&gt;, I: IntoIterator&lt;Item = S&gt;&gt;(lines: I) -&gt; Self {
		let mut lines = lines.into_iter();
		let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref());
		for line in lines {
			ans = ans.add(&amp;SnailNumOwned::from_line(line.as_ref()));
		}
		ans
	}

	fn from_str(input: &amp;str) -&gt; Self {
		Self::by_adding_lines_in(input.lines())
	}

	fn owning(elems: Vec&lt;Elem&gt;) -&gt; Self {
		Self { elems, depth: 0 }
	}

	fn reduce_once(&amp;mut self) -&gt; bool {
		self.explode_first().is_some() || self.split_first().is_some()
	}

	fn reduce(&amp;mut self) {
		while self.reduce_once() {}
	}

	// Contains explode_first and split_first, which only operate on owned snail nums
}

impl&lt;'a&gt; SnailNumBorrowed&lt;'a&gt; {
	fn borrowing(elems: &amp;'a [Elem], base_depth: usize) -&gt; Self {
		Self {
			elems,
			depth: base_depth,
		}
	}
}

impl&lt;E: AsRef&lt;[Elem]&gt;&gt; SnailNum&lt;E&gt; {
	// Contains add, as_pair, and magnitude
}

fn ans_for_input(input: &amp;str) -&gt; Answer&lt;u32, u32&gt; {
	let snail_num = SnailNumOwned::from_str(input);
	(18, (pt1(&amp;snail_num), pt2(input))).into()
}

pub fn ans() -&gt; Answer&lt;u32, u32&gt; {
	ans_for_input(include_str!("input.txt"))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="title">Part 1</div>
<p>Part 1 simply asks to perform addition on the input numbers.</p>
</div>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt1&lt;E: AsRef&lt;[Elem]&gt;&gt;(snail_num: &amp;SnailNum&lt;E&gt;) -&gt; u32 {
	snail_num.magnitude()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="title">Part 2</div>
<p>Part 2 asks to find the maximum pairwise sum of the input numbers.</p>
</div>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">fn pt2(input: &amp;str) -&gt; u32 {
	let mut max_mag = u32::MIN;
	let snail_nums = input
		.lines()
		.map(SnailNumOwned::from_line)
		.collect::&lt;Vec&lt;_&gt;&gt;();

	for (i, sn1) in snail_nums.iter().enumerate() {
		for sn2 in snail_nums.iter().skip(i + 1) {
			let mag1 = sn1.add(sn2).magnitude();
			let mag2 = sn2.add(sn1).magnitude();

			max_mag = max_mag.max(mag1).max(mag2);
		}
	}

	max_mag
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/languages/swift.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>