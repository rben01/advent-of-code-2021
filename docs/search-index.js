antoraSearch.initSearch(lunr, {"index":{"version":"2.3.9","fields":["title","name","text","component"],"fieldVectors":[["title/1-1",[0,14.432]],["name/1-1",[]],["text/1-1",[]],["component/1-1",[]],["title/1-2",[1,13.203,2,22.489]],["name/1-2",[]],["text/1-2",[]],["component/1-2",[]],["title/1-3",[3,54.234]],["name/1-3",[]],["text/1-3",[]],["component/1-3",[]],["title/1",[4,27.404,5,22.814,6,29.662]],["name/1",[7,1.166]],["text/1",[1,1.717,2,3.336,4,5.743,5,4.939,6,3.335,8,3.675,9,4.191,10,4.191,11,7.051,12,5.744,13,5.43,14,5.744,15,2.439,16,2.878,17,2.273,18,1.832,19,3.081,20,3.714,21,4.191,22,3.335,23,2.049,24,4.191,25,2.348,26,2.565,27,5.037,28,2.326,29,3.081,30,4.191,31,2.878,32,3.945,33,4.011,34,4.191,35,2.326,36,4.191,37,3.714,38,4.191,39,3.335,40,2.439,41,4.191,42,3.335,43,3.335,44,4.191,45,4.191,46,5.037,47,5.215,48,4.191,49,4.191,50,3.675,51,4.191,52,2.878,53,4.191,54,4.191,55,4.191,56,4.191,57,4.191,58,3.081,59,4.191,60,3.335,61,3.675,62,4.191,63,3.335,64,4.191,65,4.191,66,2.565,67,1.329,68,2.225,69,4.191,70,3.081,71,3.188,72,3.335,73,4.191,74,4.191,75,2.225,76,2.565,77,4.191,78,3.335,79,3.945,80,2.878,81,3.081,82,4.571,83,5.744,84,4.191,85,5.747,86,3.675,87,3.675,88,2.565,89,4.191,90,3.335,91,4.191,92,4.191,93,4.191,94,4.191,95,4.191,96,3.675,97,2.759,98,3.675,99,3.335,100,3.675,101,1.832,102,4.191,103,1.768,104,4.191,105,4.191,106,4.191,107,4.191,108,4.191,109,4.191,110,4.191,111,4.191,112,4.191,113,4.191,114,4.191,115,4.191,116,4.191,117,3.675,118,3.714,119,7.051,120,1.768,121,4.191,122,4.191,123,5.744,124,5.744,125,4.191,126,4.191,127,4.191,128,1.768,129,4.191,130,4.191,131,4.191,132,4.191,133,4.191,134,4.191,135,4.191,136,4.191,137,4.191,138,4.191,139,4.191,140,4.191,141,4.191,142,4.191,143,4.191,144,4.191,145,4.191,146,4.191,147,4.191,148,4.191,149,4.191,150,4.191,151,4.191,152,4.191,153,4.191,154,4.191,155,4.191,156,1.709,157,2.049,158,1.971,159,1.501,160,1.299,161,2.342,162,6.331,163,5.744,164,5.743,165,5.744,166,1.994,167,2.273,168,2.565,169,2.439,170,1.29,171,2.565,172,2.439,173,2.585,174,3.335,175,0.695,176,0.848,177,0.903,178,4.191,179,4.191,180,4.191,181,4.191,182,3.675,183,6.554,184,4.191,185,1.29,186,5.744,187,5.744,188,4.191,189,4.191,190,4.191,191,4.191,192,4.191,193,4.191,194,2.808,195,2.878,196,5.744,197,5.037,198,2.424,199,5.037,200,3.516,201,5.744,202,5.744,203,4.191,204,4.191,205,5.744,206,4.869,207,5.744,208,4.191,209,3.675,210,4.191,211,4.191,212,4.191,213,4.191,214,3.675,215,3.675,216,3.675,217,1.832,218,2.71,219,3.675,220,2.049,221,3.675,222,2.133,223,3.675,224,3.675,225,2.565,226,3.675,227,2.225,228,3.675,229,3.675,230,2.439,231,3.081,232,3.335,233,3.335,234,2.049,235,3.675,236,3.675,237,2.225,238,3.675,239,3.081,240,3.081,241,3.675,242,3.675,243,2.71,244,3.675,245,2.878,246,2.878,247,3.335,248,3.675,249,3.081,250,3.675,251,3.675,252,2.878,253,3.675,254,3.081,255,3.335,256,3.675,257,3.081,258,3.675,259,3.675,260,3.081,261,3.675,262,2.878,263,3.335,264,3.335,265,3.081,266,3.675,267,2.225,268,3.081,269,3.675,270,3.335,271,3.081,272,3.675,273,3.675,274,3.081,275,3.335,276,3.081,277,3.335,278,3.335,279,3.675,280,2.878,281,3.675,282,3.675,283,5.037,284,3.335,285,4.191,286,4.191,287,2.565,288,2.71,289,2.326,290,3.675,291,2.133,292,3.675]],["component/1",[293,0.599]],["title/2-1",[0,14.432]],["name/2-1",[]],["text/2-1",[]],["component/2-1",[]],["title/2-2",[175,4.511,176,5.502,177,5.858]],["name/2-2",[]],["text/2-2",[]],["component/2-2",[]],["title/2",[160,4.758,176,4.758,214,28.266,215,28.266]],["name/2",[294,0.635]],["text/2",[1,1.917,2,2.516,15,2.876,17,1.521,25,2.318,42,3.934,67,2.033,76,3.026,97,2.772,103,2.608,120,1.974,128,1.974,160,1.152,161,2.536,167,2.624,170,2.318,175,0.912,176,1.251,177,1.008,185,2.462,217,2.161,222,3.264,227,3.405,287,3.026,295,1.567,296,2.615,297,3.78,298,5.171,299,6.696,300,6.605,301,7.533,302,5.669,303,4.035,304,4.87,305,4.944,306,3.294,307,4.944,308,4.944,309,4.944,310,3.196,311,4.944,312,4.335,313,4.944,314,4.335,315,2.161,316,3.196,317,3.634,318,4.944,319,2.906,320,6.413,321,4.944,322,3.026,323,3.395,324,4.944,325,4.944,326,2.095,327,2.371,328,6.413,329,7.999,330,2.617,331,6.413,332,6.413,333,6.413,334,6.413,335,6.413,336,6.413,337,6.413,338,6.413,339,6.413,340,2.227,341,7.533,342,5.624,343,2.227,344,2.095,345,2.033,346,5.624,347,2.095,348,2.16,349,5.624,350,6.413,351,2.095,352,2.033,353,2.536,354,2.033,355,2.16,356,3.732,357,2.371,358,6.413,359,6.413]],["component/2",[293,0.599]],["title/3-1",[0,14.432]],["name/3-1",[]],["text/3-1",[]],["component/3-1",[]],["title/3-2",[175,5.348,176,6.521]],["name/3-2",[]],["text/3-2",[]],["component/3-2",[]],["title/3-3",[175,5.348,177,6.943]],["name/3-3",[]],["text/3-3",[]],["component/3-3",[]],["title/3",[160,5.502,177,5.858,216,32.685]],["name/3",[294,0.635]],["text/3",[1,1.44,17,1.008,25,2.164,26,2.004,67,2.229,70,2.407,97,2.791,103,2.555,120,1.76,128,1.76,159,2.518,160,1.073,166,2.758,167,2.614,170,2.555,177,1.217,185,2.343,194,4.153,198,2.967,290,7.151,295,1.038,298,2.117,326,1.868,327,2.114,330,2.414,340,1.986,343,1.986,344,1.868,345,1.813,347,1.868,348,1.926,351,1.868,352,1.813,353,2.414,354,1.813,355,1.926,356,3.328,357,2.114,360,2.249,361,2.605,362,3.274,363,3.274,364,2.407,365,2.249,366,2.117,367,4.622,368,7.375,369,5.367,370,5.015,371,5.719,372,5.719,373,2.911,374,6.436,375,3.987,376,4.991,377,3.036,378,3.697,379,3.697,380,2.413,381,2.69,382,2.499,383,5.199,384,7.676,385,3.928,386,3.697,387,3.928,388,5.719,389,5.719,390,5.719,391,5.719,392,5.719,393,2.255,394,2.911,395,5.719,396,5.719,397,5.015,398,3.113,399,2.867,400,7.032,401,5.015,402,6.965,403,5.719,404,5.719,405,5.719,406,5.719,407,5.719]],["component/3",[293,0.599]],["title/4-1",[0,14.432]],["name/4-1",[]],["text/4-1",[]],["component/4-1",[]],["title/4-2",[175,5.348,176,6.521]],["name/4-2",[]],["text/4-2",[]],["component/4-2",[]],["title/4-3",[175,5.348,177,6.943]],["name/4-3",[]],["text/4-3",[]],["component/4-3",[]],["title/4",[160,4.758,217,14.088,218,20.841,219,28.266]],["name/4",[294,0.635]],["text/4",[0,0.896,1,1.47,7,4.133,17,1.789,25,2.257,28,1.87,33,2.061,40,1.96,66,4.347,67,1.843,81,2.476,88,2.061,97,2.789,103,1.968,120,1.037,128,1.789,160,0.858,161,1.843,166,2.018,167,2.552,170,2.36,176,1.179,177,0.773,185,2.093,195,5.267,198,2.453,200,4.347,217,3.104,218,2.178,220,1.647,230,1.96,254,3.617,262,2.313,295,1.068,303,3.586,306,2.453,319,1.526,326,1.1,330,2.027,340,2.018,343,2.018,344,1.899,345,1.843,347,1.899,348,1.958,351,1.1,352,1.068,353,1.843,354,1.068,355,1.134,356,1.96,357,1.245,367,1.96,382,3.104,394,2.959,398,2.87,408,2.68,409,3.368,410,1.96,411,3.368,412,1.96,413,1.714,414,2.476,415,2.68,416,3.368,417,2.504,418,2.313,419,3.368,420,3.368,421,2.68,422,5.039,423,4.742,424,3.72,425,1.87,426,2.68,427,2.476,428,1.87,429,3.368,430,2.68,431,3.368,432,5.038,433,3.368,434,2.313,435,2.953,436,2.953,437,3.368,438,2.313,439,2.061,440,3.368,441,2.953,442,2.178,443,1.87,444,2.928,445,4.274,446,5.813,447,3.993,448,5.098,449,4.626,450,7.67,451,5.813,452,5.813,453,2.997,454,5.813,455,5.813,456,5.813,457,5.813,458,5.813,459,5.813,460,5.813,461,6.228,462,5.813,463,5.813,464,5.813,465,4.959,466,7.103,467,5.813,468,5.813,469,5.813,470,5.813,471,5.813,472,5.813,473,5.813,474,5.813,475,5.813,476,7.103,477,5.813,478,5.813,479,7.67,480,5.813,481,7.103,482,5.813,483,5.813,484,5.813,485,5.813,486,2.842,487,5.873,488,5.813,489,4.626,490,7.67,491,5.813,492,5.813,493,3.383,494,5.652,495,5.813,496,7.103,497,5.098,498,4.126,499,5.813,500,5.813,501,7.103,502,5.813,503,5.813,504,5.813,505,5.813,506,3.993,507,5.813,508,5.813,509,5.813,510,5.813,511,5.813,512,6.394,513,6.394,514,4.463,515,3.368,516,3.368,517,2.953,518,3.368,519,3.368,520,3.368,521,3.368]],["component/4",[293,0.599]],["title/5-1",[0,14.432]],["name/5-1",[]],["text/5-1",[]],["component/5-1",[]],["title/5-2",[175,5.348,176,6.521]],["name/5-2",[]],["text/5-2",[]],["component/5-2",[]],["title/5-3",[175,5.348,177,6.943]],["name/5-3",[]],["text/5-3",[]],["component/5-3",[]],["title/5",[85,28.266,160,4.758,220,15.76,221,28.266]],["name/5",[294,0.635]],["text/5",[1,1.175,2,1.275,4,2.89,5,2.406,8,2.196,15,1.457,17,1.21,18,2.12,23,1.224,25,2.171,28,1.39,32,1.72,35,1.39,40,1.457,61,3.446,67,1.538,75,1.33,86,2.196,97,2.789,103,2.449,120,1.493,128,1.493,156,2.583,159,2.527,160,0.978,161,2.46,166,2.449,167,2.617,170,2.495,173,3.138,176,1.041,177,0.394,185,2.171,217,1.095,220,3.529,267,3.517,280,1.72,291,2.469,295,0.794,296,1.021,303,1.224,306,2.047,310,2.541,319,3.606,322,1.533,326,1.585,327,1.793,330,2.008,340,1.684,343,1.684,344,1.585,345,1.538,347,1.585,348,1.633,351,1.585,352,1.538,353,2.236,354,1.538,355,1.633,356,2.823,357,1.793,365,1.72,367,1.457,369,4.096,370,4.254,377,2.576,381,3.518,382,3.083,393,1.913,398,2.693,399,1.978,413,2.001,422,4.096,423,5.374,424,2.823,428,2.693,438,2.699,439,1.533,444,2.855,453,3.156,486,3.097,494,3.128,498,2.372,522,7.068,523,2.196,524,2.406,525,7.441,526,6.624,527,5.235,528,5.306,529,3.93,530,4.254,531,3.86,532,4.749,533,5.209,534,6.859,535,2.699,536,3.93,537,1.533,538,2.699,539,3.93,540,2.196,541,2.196,542,2.504,543,1.619,544,3.93,545,1.178,546,2.196,547,2.196,548,5.495,549,2.196,550,1.72,551,2.196,552,1.72,553,2.504,554,1.993,555,2.504,556,2.504,557,2.196,558,2.196,559,2.504,560,2.504,561,1.72,562,1.619,563,2.504,564,2.504,565,2.196,566,4.851,567,2.576,568,3.86,569,3.86,570,3.332,571,2.372,572,3.86,573,7.054,574,3.743,575,6.335,576,4.851,577,4.851,578,4.851,579,4.851,580,6.335,581,6.335,582,6.335,583,4.851,584,4.352,585,5.555,586,3.86,587,3.136,588,4.851,589,4.105,590,4.851,591,4.851,592,4.851,593,4.851,594,4.851,595,4.851,596,3.86,597,4.851,598,4.851,599,4.851,600,6.335,601,6.335,602,4.851,603,4.254,604,5.241,605,3.136,606,4.254,607,6.335,608,4.851,609,3.86,610,4.851,611,4.851,612,4.851,613,4.851,614,4.851,615,4.851,616,4.851,617,4.851,618,4.851,619,2.823,620,4.851,621,4.851,622,4.851,623,4.851,624,4.851,625,4.851,626,4.254,627,6.335,628,4.851,629,6.335,630,6.335,631,6.335,632,4.351,633,4.254,634,4.851,635,4.851,636,4.851,637,4.851,638,6.335,639,4.851,640,2.372,641,4.851,642,4.851,643,4.851,644,4.851,645,4.851,646,4.851,647,1.33,648,2.504,649,1.841,650,1.39,651,1.72,652,2.196,653,2.196]],["component/5",[293,0.599]],["title/6-1",[0,14.432]],["name/6-1",[]],["text/6-1",[]],["component/6-1",[]],["title/6-2",[175,5.348,176,6.521]],["name/6-2",[]],["text/6-2",[]],["component/6-2",[]],["title/6-3",[175,5.348,177,6.943]],["name/6-3",[]],["text/6-3",[]],["component/6-3",[]],["title/6",[160,4.758,222,16.408,223,28.266,224,28.266]],["name/6",[294,0.635]],["text/6",[1,1.364,17,2.247,18,1.995,25,2.107,40,1.771,67,1.737,71,4.287,75,1.616,88,1.863,97,2.786,101,2.394,103,2.528,120,1.686,128,1.686,156,2.234,157,2.678,158,2.576,159,2.452,160,1.048,161,2.48,167,2.615,170,2.298,175,0.663,176,1.189,177,1.116,185,2.298,194,3.347,198,1.284,206,4.345,217,2.394,222,4.026,243,3.541,267,3.635,295,0.965,296,1.861,303,2.678,304,1.968,315,1.33,326,1.789,327,2.025,330,2.17,340,2.377,344,1.789,345,1.737,347,1.789,348,1.844,351,1.789,352,1.737,353,2.368,354,1.737,355,1.844,356,3.187,357,2.025,369,4.426,381,1.432,383,3.352,387,3.762,393,2.16,398,2.091,408,2.422,410,1.771,413,3.319,414,3.356,415,2.422,417,1.549,425,3.04,439,2.794,444,3.019,498,3.347,514,3.983,524,1.863,530,2.669,545,1.432,567,2.424,572,4.359,584,3.187,587,4.426,640,3.347,647,1.616,650,2.534,654,3.378,655,3.044,656,2.422,657,5.717,658,6.52,659,6.52,660,6.52,661,2.669,662,2.669,663,6.52,664,3.044,665,4.474,666,3.632,667,3.044,668,5.477,669,5.477,670,5.477,671,4.803,672,3.187,673,3.187,674,4.803,675,5.477,676,7.823,677,5.477,678,5.477,679,5.477,680,5.477,681,4.803,682,5.477,683,5.49,684,6.039,685,6.053,686,6.682,687,4.803,688,5.477,689,5.477,690,7.468,691,5.477,692,8.214,693,5.477,694,6.548,695,5.477,696,5.477,697,5.477,698,4.803,699,6.846,700,7.823,701,6.846,702,7.302,703,6.086,704,6.846,705,6.846,706,5.477,707,5.477,708,6.846,709,5.477,710,5.477,711,6.086,712,5.477,713,6.846,714,5.477,715,6.846,716,3.541,717,5.477,718,5.477,719,5.477,720,5.477,721,2.951,722,4.565,723,4.803,724,4.359,725,2.238,726,3.044,727,4.803,728,3.044,729,1.968,730,2.238,731,3.044,732,5.477,733,3.044,734,3.044,735,2.238,736,2.669,737,3.044,738,4.565,739,3.044,740,4.565,741,3.044,742,2.669,743,2.669,744,1.968]],["component/6",[293,0.599]],["title/7-1",[0,14.432]],["name/7-1",[]],["text/7-1",[]],["component/7-1",[]],["title/7-2",[175,4.511,176,5.502,177,5.858]],["name/7-2",[]],["text/7-2",[]],["component/7-2",[]],["title/7",[160,5.502,225,22.814,226,32.685]],["name/7",[294,0.635]],["text/7",[1,2.068,17,2.13,23,2.281,25,2.267,67,1.958,76,2.856,97,2.782,101,2.699,103,2.423,120,1.9,128,1.9,160,1.131,161,2.68,167,2.65,170,2.423,176,1.162,185,2.423,225,4.915,230,2.715,234,3.601,267,2.477,295,1.479,316,3.017,326,2.017,327,2.282,330,2.335,340,2.144,344,2.017,345,1.958,347,2.017,348,2.079,351,2.017,352,1.958,353,2.496,354,1.958,355,2.079,356,3.593,357,2.282,380,2.606,393,2.435,394,3.143,398,2.642,410,2.715,412,2.715,425,3.427,443,3.427,543,3.017,545,2.195,562,3.992,567,2.477,604,5.09,605,3.992,606,5.414,666,3.713,745,4.666,746,4.914,747,3.713,748,6.175,749,6.175,750,6.175,751,4.666,752,4.666,753,3.713,754,4.666,755,3.713,756,3.017,757,4.914,758,7.872,759,8.803,760,5.414,761,5.414,762,6.175,763,6.175,764,6.175,765,5.09,766,6.175,767,6.175,768,7.366,769,6.175,770,6.175,771,3.019,772,6.175,773,6.175,774,6.175,775,6.175,776,6.175,777,6.175,778,6.175,779,6.175,780,7.366,781,6.175,782,6.175,783,6.175,784,6.175,785,6.175,786,6.175]],["component/7",[293,0.599]],["title/8-1",[0,14.432]],["name/8-1",[]],["text/8-1",[]],["component/8-1",[]],["title/8-2",[175,5.348,176,6.521]],["name/8-2",[]],["text/8-2",[]],["component/8-2",[]],["title/8-3",[175,5.348,177,6.943]],["name/8-3",[]],["text/8-3",[]],["component/8-3",[]],["title/8",[160,4.758,227,17.115,228,28.266,229,28.266]],["name/8",[294,0.635]],["text/8",[1,2.171,2,3.071,16,2.47,17,1.588,25,2.399,33,2.201,40,2.093,47,5.954,67,1.913,71,3.349,79,2.47,97,2.784,103,2.434,120,1.857,128,1.857,160,0.973,161,2.624,167,2.617,170,1.857,175,0.73,176,1.205,177,1.282,185,2.236,194,3.552,198,1.518,227,3.973,277,5.246,287,3.158,289,1.996,295,1.14,296,2.104,297,2.739,303,4.111,306,2.782,315,2.255,316,2.325,319,3.163,322,2.201,326,1.971,330,2.303,340,2.095,343,2.095,344,1.971,345,1.913,347,1.971,348,2.032,351,1.971,352,1.913,353,2.471,354,1.913,355,2.032,357,2.23,375,1.758,376,2.201,385,4.144,393,2.38,394,3.071,398,2.303,402,3.154,498,1.758,537,2.201,541,3.154,550,5.685,554,2.862,567,3.857,585,6.37,604,5.436,605,3.901,647,2.739,716,2.093,721,2.325,729,2.325,742,3.154,744,2.325,787,5.16,788,6.561,789,3.596,790,2.862,791,3.596,792,3.596,793,2.862,794,3.154,795,2.201,796,2.47,797,3.154,798,5.16,799,3.596,800,3.596,801,3.596,802,6.034,803,5.291,804,6.034,805,6.034,806,6.034,807,6.034,808,6.034,809,6.034,810,6.034,811,6.034,812,7.265,813,6.034,814,7.265,815,6.034,816,7.483,817,6.034,818,7.265,819,6.034,820,6.034,821,6.034,822,6.034,823,6.034,824,6.835,825,6.034,826,6.034,827,7.094,828,6.034,829,7.265,830,6.034,831,6.034,832,6.034,833,6.034,834,5.16,835,5.16,836,3.596,837,3.596,838,2.862,839,3.154,840,3.596,841,4.436,842,4.524,843,3.544,844,3.596,845,3.154,846,3.596,847,3.596,848,3.154,849,2.862,850,2.862,851,3.154,852,3.596,853,5.16,854,3.596,855,3.596,856,3.596,857,3.596,858,2.325,859,5.781,860,3.154,861,3.596,862,3.596,863,3.154,864,2.644,865,5.16,866,3.596,867,2.862,868,3.596,869,3.596,870,3.154,871,2.862,872,3.596,873,2.862,874,3.596,875,3.154,876,3.596,877,3.596,878,2.862,879,5.16,880,3.596]],["component/8",[293,0.599]],["title/9-1",[0,14.432]],["name/9-1",[]],["text/9-1",[]],["component/9-1",[]],["title/9-2",[175,5.348,176,6.521]],["name/9-2",[]],["text/9-2",[]],["component/9-2",[]],["title/9-3",[175,5.348,177,6.943]],["name/9-3",[]],["text/9-3",[]],["component/9-3",[]],["title/9",[160,4.191,230,16.523,231,20.876,232,22.596,233,22.596]],["name/9",[294,0.635]],["text/9",[0,0.3,1,0.81,2,0.573,15,1.166,16,2.257,17,1.16,18,0.876,20,2.125,25,1.487,29,1.473,35,0.625,39,1.595,42,2.156,58,0.828,66,2.012,67,1.042,68,3.355,70,0.828,75,1.064,76,0.689,79,1.377,88,0.689,90,0.896,97,2.788,101,2.505,103,2.014,118,3.585,120,1.012,128,1.012,156,1.34,157,1.607,158,1.546,159,1.177,160,0.556,161,2.308,166,2.76,167,2.556,169,4.345,170,2.298,173,3.135,176,1.325,177,0.871,185,1.487,194,2.802,198,3.151,199,2.882,200,2.012,206,4.31,217,2.423,220,2.885,222,2.822,225,3.121,227,3.738,230,3.807,231,0.828,232,6.211,234,2.493,267,4.065,278,2.156,288,0.728,289,0.625,295,0.357,296,0.459,303,2.802,304,0.728,306,2.667,310,0.728,315,2.423,319,0.51,326,1.579,327,1.215,330,2.003,340,1.141,343,1.141,344,1.579,345,1.042,347,1.074,348,1.107,351,1.074,352,1.042,353,1.817,354,1.042,355,1.107,357,1.215,375,2.363,376,0.689,377,1.745,380,2.667,381,2.696,382,1.436,393,2.656,398,3.36,399,2.337,413,1.673,417,0.573,418,0.773,424,1.912,426,0.896,428,1.824,432,5.573,434,2.257,438,3.11,443,2.683,444,1.845,453,3.169,486,3.09,487,4.45,498,3.651,506,2.257,514,4.097,524,0.689,535,3.937,537,0.689,545,1.546,550,2.257,561,0.773,570,2.257,571,2.043,574,2.696,587,3.706,609,2.615,640,2.608,647,0.598,649,0.828,654,1.824,672,1.912,673,1.912,716,3.335,753,3.846,757,2.615,771,1.607,797,0.987,858,1.751,867,0.896,881,4.529,882,0.896,883,1.126,884,1.126,885,2.709,886,1.377,887,1.126,888,1.126,889,1.126,890,4.833,891,4.529,892,5.737,893,4.529,894,3.287,895,1.595,896,1.126,897,3.287,898,2.004,899,2.709,900,1.126,901,1.126,902,1.595,903,0.689,904,1.126,905,1.126,906,1.126,907,1.126,908,4.053,909,1.473,910,3.287,911,1.992,912,0.987,913,0.987,914,3.769,915,2.709,916,0.987,917,1.126,918,2.004,919,2.004,920,2.004,921,1.126,922,1.126,923,0.987,924,2.004,925,0.896,926,0.828,927,0.987,928,1.126,929,1.126,930,1.126,931,0.896,932,1.126,933,1.992,934,2.615,935,2.615,936,0.987,937,0.987,938,0.896,939,1.126,940,2.004,941,2.709,942,5.544,943,3.287,944,0.773,945,4.338,946,1.595,947,1.992,948,1.126,949,0.773,950,1.126,951,2.004,952,1.126,953,2.709,954,1.126,955,1.126,956,2.004,957,0.689,958,1.126,959,0.987,960,1.126,961,3.287,962,3.287,963,2.882,964,6.734,965,3.287,966,1.607,967,4.833,968,3.287,969,3.287,970,3.287,971,3.287,972,3.287,973,3.287,974,4.833,975,3.287,976,5.732,977,3.287,978,3.287,979,3.287,980,3.287,981,3.287,982,4.214,983,4.833,984,3.287,985,3.287,986,3.287,987,3.287,988,3.287,989,2.882,990,4.833,991,2.882,992,3.287,993,3.287,994,3.287,995,3.287,996,2.882,997,3.287,998,3.287,999,6.319,1000,4.833,1001,3.287,1002,3.287,1003,3.287,1004,3.287,1005,3.287,1006,4.833,1007,3.287,1008,3.287,1009,3.287,1010,3.287,1011,3.287,1012,5.358,1013,4.833,1014,4.833,1015,5.732,1016,2.012,1017,5.732,1018,6.319,1019,4.833,1020,3.287,1021,5.732,1022,4.833,1023,3.287,1024,3.287,1025,3.287,1026,3.287,1027,3.287,1028,3.287,1029,4.833,1030,4.833,1031,3.319,1032,3.287,1033,3.287,1034,3.287,1035,3.287,1036,3.287,1037,3.287,1038,3.287,1039,3.287,1040,3.287,1041,3.287,1042,3.287,1043,3.287,1044,3.287,1045,4.238,1046,3.287,1047,3.287,1048,3.287,1049,3.287,1050,5.732,1051,4.833,1052,4.833,1053,4.833,1054,3.287,1055,3.287,1056,3.287,1057,3.287,1058,3.287,1059,3.287,1060,3.287,1061,3.287,1062,3.287,1063,3.287,1064,3.287,1065,3.287,1066,3.287,1067,2.615,1068,3.287,1069,3.287,1070,3.287,1071,3.287,1072,3.287,1073,3.287,1074,3.287,1075,3.287,1076,3.287,1077,3.287,1078,3.287,1079,2.416,1080,3.287,1081,2.125,1082,4.833,1083,4.833,1084,7.041,1085,3.287,1086,3.287,1087,4.833,1088,3.287,1089,3.287,1090,3.287,1091,3.287,1092,4.833,1093,3.287,1094,3.287,1095,3.287,1096,3.287,1097,3.287,1098,3.287,1099,3.287,1100,3.287,1101,4.238,1102,4.833,1103,3.287,1104,3.287,1105,3.287,1106,3.287,1107,3.553,1108,3.287,1109,3.287,1110,3.287,1111,0.987,1112,1.126,1113,1.126,1114,0.773,1115,0.625,1116,1.126]],["component/9",[293,0.599]],["title/10-1",[0,14.432]],["name/10-1",[]],["text/10-1",[]],["component/10-1",[]],["title/10-2",[175,5.348,176,6.521]],["name/10-2",[]],["text/10-2",[]],["component/10-2",[]],["title/10-3",[175,5.348,177,6.943]],["name/10-3",[]],["text/10-3",[]],["component/10-3",[]],["title/10",[160,4.758,234,15.76,235,28.266,236,28.266]],["name/10",[294,0.635]],["text/10",[1,1.344,17,0.918,25,2.091,26,1.826,67,2.154,97,2.791,103,2.47,120,1.666,128,1.666,156,2.207,159,1.938,160,0.889,161,2.596,166,2.359,167,2.587,170,2.558,175,0.544,176,1.071,177,1.189,185,2.091,220,2.646,234,3.758,295,0.946,297,2.388,303,2.646,326,1.768,327,2.001,330,1.716,340,1.879,343,1.879,344,1.768,345,1.716,347,1.768,348,1.822,351,1.768,352,1.716,353,2.355,354,1.716,355,1.822,357,2.001,380,2.867,386,3.499,393,2.134,399,2.771,418,2.049,422,5.295,423,5.295,439,1.826,442,3.499,444,2.066,447,5.101,453,3.507,465,3.499,486,2.646,489,4.307,506,3.717,532,4.159,533,3.717,571,2.646,574,3.196,589,4.533,619,3.149,640,3.631,654,1.656,666,2.374,795,1.826,843,4.667,878,2.374,886,2.049,1031,3.717,1079,3.979,1107,3.979,1117,2.984,1118,2.616,1119,2.616,1120,4.746,1121,2.049,1122,2.984,1123,2.984,1124,2.616,1125,2.984,1126,2.193,1127,1.826,1128,2.984,1129,2.984,1130,2.374,1131,2.374,1132,2.616,1133,4.746,1134,8.025,1135,5.91,1136,5.412,1137,3.979,1138,5.412,1139,4.667,1140,4.746,1141,4.746,1142,3.499,1143,4.307,1144,4.746,1145,4.746,1146,5.412,1147,4.746,1148,4.746,1149,5.412,1150,5.412,1151,5.412,1152,5.412,1153,5.412,1154,6.517,1155,7.427,1156,6.513,1157,5.958,1158,6.795,1159,6.795,1160,5.958,1161,5.958,1162,5.407,1163,5.412,1164,5.412,1165,5.412,1166,5.412,1167,5.412,1168,5.412,1169,5.412,1170,7.427,1171,5.412,1172,4.746,1173,4.746,1174,5.412,1175,5.412,1176,5.412,1177,6.795,1178,5.412,1179,5.412,1180,4.746,1181,5.412,1182,5.412,1183,6.795,1184,7.427,1185,5.412,1186,5.412,1187,5.412,1188,5.412,1189,5.412,1190,5.412,1191,5.412,1192,5.412,1193,5.412,1194,5.412,1195,5.412,1196,5.412]],["component/10",[293,0.599]],["title/11-1",[0,14.432]],["name/11-1",[]],["text/11-1",[]],["component/11-1",[]],["title/11-2",[175,5.348,176,6.521]],["name/11-2",[]],["text/11-2",[]],["component/11-2",[]],["title/11-3",[175,5.348,177,6.943]],["name/11-3",[]],["text/11-3",[]],["component/11-3",[]],["title/11",[160,4.758,237,17.115,238,28.266,239,23.698]],["name/11",[294,0.635]],["text/11",[1,1.222,17,1.881,20,1.703,25,1.991,31,1.809,35,1.462,60,2.096,63,2.096,67,2.051,68,2.66,97,2.793,101,2.19,103,2.574,120,1.542,128,1.542,157,3.503,158,3.37,159,1.794,160,0.833,161,2.051,166,2.722,167,2.596,170,2.205,173,3.091,176,0.739,177,1.017,185,1.991,198,3.195,217,2.827,220,2.449,222,2.55,237,3.584,239,5.566,287,1.612,295,0.835,303,2.449,322,1.612,326,1.637,327,1.852,330,2.051,340,1.74,343,1.74,344,1.637,345,1.588,347,1.637,348,1.687,351,1.637,352,1.588,353,2.271,354,1.588,355,1.687,357,1.852,360,1.809,373,3.647,378,3.239,380,2.114,381,3.37,382,3.309,387,3.441,393,2.986,394,2.55,399,3.128,434,2.808,443,2.781,444,2.469,447,3.441,453,2.114,584,2.915,589,4.405,619,2.915,771,3.503,864,5.763,895,3.253,903,2.502,911,1.936,949,1.809,1079,3.683,1101,4.393,1115,4.594,1142,4.182,1197,2.634,1198,8.027,1199,3.683,1200,8.336,1201,2.096,1202,3.585,1203,2.634,1204,2.634,1205,2.634,1206,2.096,1207,2.31,1208,2.634,1209,4.385,1210,4.169,1211,7.838,1212,7.838,1213,7.838,1214,7.395,1215,4.394,1216,6.469,1217,4.393,1218,5.01,1219,5.01,1220,5.01,1221,5.01,1222,6.469,1223,5.01,1224,5.01,1225,6.469,1226,5.01,1227,5.01,1228,6.469,1229,5.01,1230,5.01,1231,5.01,1232,5.01,1233,5.01,1234,5.01,1235,5.01,1236,5.01,1237,5.01,1238,5.01,1239,5.01,1240,2.66,1241,5.01,1242,5.01,1243,5.01,1244,5.01,1245,5.01,1246,5.01,1247,5.01,1248,6.469,1249,5.01,1250,6.469,1251,5.01,1252,5.01,1253,5.01,1254,5.01,1255,5.01,1256,5.01,1257,5.01,1258,4.393,1259,6.469,1260,5.01,1261,5.01,1262,5.01,1263,5.01,1264,5.01]],["component/11",[293,0.599]],["title/12-1",[0,14.432]],["name/12-1",[]],["text/12-1",[]],["component/12-1",[]],["title/12-2",[175,5.348,176,6.521]],["name/12-2",[]],["text/12-2",[]],["component/12-2",[]],["title/12-3",[175,5.348,177,6.943]],["name/12-3",[]],["text/12-3",[]],["component/12-3",[]],["title/12",[160,4.758,240,23.698,241,28.266,242,28.266]],["name/12",[294,0.635]],["text/12",[1,1.729,17,1.028,25,2.179,52,3.973,67,1.834,70,2.455,97,2.79,103,2.518,120,1.78,128,1.78,159,2.072,160,0.94,161,2.594,166,2.009,167,2.62,170,2.454,173,2.282,176,1.177,185,2.179,237,3.072,240,5.378,288,2.159,295,1.059,300,5.073,306,3.365,326,1.89,327,2.138,330,2.245,340,2.009,343,2.009,344,1.89,345,1.834,347,1.89,348,1.948,351,1.89,352,1.834,353,2.426,354,1.834,355,1.948,357,2.138,365,2.294,366,3.162,377,3.072,380,2.441,386,3.74,393,2.282,398,3.123,412,2.845,422,3.74,423,3.74,442,3.74,444,2.208,447,3.973,453,2.988,465,3.74,493,3.366,498,2.828,532,3.541,550,4.864,561,2.294,589,3.366,619,3.366,633,5.073,735,4.253,843,4.864,1016,3.541,1079,4.253,1107,5.863,1135,6.346,1137,4.253,1139,4.864,1140,5.073,1141,5.073,1142,3.74,1143,4.604,1144,5.073,1145,5.073,1147,5.073,1148,5.073,1154,4.604,1156,5.073,1162,4.604,1172,5.073,1173,5.073,1209,3.541,1210,3.366,1215,3.072,1265,3.34,1266,2.658,1267,3.34,1268,3.34,1269,2.928,1270,3.34,1271,8.512,1272,5.785,1273,5.785,1274,5.785,1275,5.073,1276,7.975,1277,7.653,1278,3.973,1279,5.073,1280,5.073,1281,5.785,1282,5.785,1283,8.325,1284,7.081,1285,5.785,1286,5.785,1287,5.785,1288,5.785,1289,5.785,1290,7.081,1291,7.081,1292,5.785,1293,5.785,1294,5.785,1295,5.785,1296,5.785,1297,5.785,1298,5.785,1299,4.604,1300,7.081,1301,5.785,1302,5.785,1303,4.604,1304,5.785,1305,5.785,1306,5.785]],["component/12",[293,0.599]],["title/13-1",[0,14.432]],["name/13-1",[]],["text/13-1",[]],["component/13-1",[]],["title/13-2",[175,4.511,176,5.502,177,5.858]],["name/13-2",[]],["text/13-2",[]],["component/13-2",[]],["title/13",[160,4.758,243,20.841,244,28.266,245,22.139]],["name/13",[294,0.635]],["text/13",[0,0.886,1,2.023,5,2.987,17,1.502,18,2.525,23,1.629,25,1.957,32,2.288,39,2.651,46,2.921,67,1.547,75,1.769,76,2.039,97,2.784,103,2.393,120,1.502,128,1.502,156,2.885,157,3.109,158,2.991,159,2.278,160,1.129,161,2.377,166,2.456,167,2.561,170,2.533,173,2.956,175,0.591,176,1.129,177,0.908,185,2.393,194,2.386,198,2.06,206,2.987,237,2.591,243,5.095,245,4.65,262,3.352,267,3.881,291,2.484,295,1.056,296,1.358,298,4.112,315,1.456,316,2.154,319,2.212,326,1.594,327,1.804,330,2.465,340,1.695,343,1.695,344,1.594,345,1.547,347,1.594,348,1.643,351,1.594,352,1.547,353,2.243,354,1.547,355,1.643,357,1.804,360,2.288,373,2.484,398,1.863,412,1.938,413,1.696,417,1.696,428,2.709,435,2.921,444,1.863,445,3.588,486,3.459,523,2.921,524,2.039,527,4.28,571,1.629,587,4.112,619,2.84,640,3.109,650,3.758,652,4.28,654,1.849,672,3.701,673,3.701,721,4.112,735,2.449,795,2.039,858,2.154,903,3.893,925,2.651,996,2.921,1016,2.987,1081,3.156,1114,2.288,1115,3.927,1121,2.288,1130,5.817,1199,4.676,1202,2.921,1215,3.756,1278,2.288,1279,2.921,1307,2.288,1308,2.449,1309,6.508,1310,3.331,1311,5.577,1312,2.921,1313,3.884,1314,7.496,1315,3.331,1316,5.793,1317,2.154,1318,2.921,1319,3.331,1320,7.496,1321,3.331,1322,3.331,1323,2.288,1324,3.331,1325,6.771,1326,2.921,1327,6.771,1328,2.921,1329,3.331,1330,2.651,1331,2.651,1332,3.331,1333,2.449,1334,3.331,1335,2.651,1336,2.921,1337,3.331,1338,3.331,1339,2.921,1340,2.651,1341,3.352,1342,2.921,1343,2.651,1344,2.921,1345,3.331,1346,2.449,1347,3.331,1348,3.331,1349,2.921,1350,4.28,1351,6.36,1352,5.201,1353,4.881,1354,6.36,1355,4.881,1356,4.881,1357,6.36,1358,4.881,1359,7.774,1360,3.884,1361,3.884,1362,5.577,1363,6.36,1364,6.36,1365,4.368,1366,4.881,1367,4.881,1368,4.881,1369,4.881,1370,4.881,1371,7.971,1372,7.774,1373,7.774,1374,7.075,1375,4.881,1376,4.881,1377,6.36,1378,7.496,1379,4.881,1380,7.075,1381,4.881,1382,6.36,1383,6.36,1384,4.881,1385,4.881,1386,4.881,1387,4.881,1388,4.881,1389,4.881,1390,4.881,1391,4.881,1392,4.881,1393,4.881,1394,4.881,1395,4.881,1396,4.881,1397,4.881,1398,4.881,1399,4.881,1400,4.881,1401,4.881,1402,4.881,1403,4.881,1404,3.352,1405,3.331,1406,3.331,1407,2.449,1408,2.921,1409,2.84,1410,2.288,1411,2.651,1412,3.331,1413,3.331,1414,3.331]],["component/13",[293,0.599]],["title/14-1",[0,14.432]],["name/14-1",[]],["text/14-1",[]],["component/14-1",[]],["title/14-2",[175,5.348,176,6.521]],["name/14-2",[]],["text/14-2",[]],["component/14-2",[]],["title/14-3",[175,5.348,177,6.943]],["name/14-3",[]],["text/14-3",[]],["component/14-3",[]],["title/14",[160,4.758,246,22.139,247,25.651,248,28.266]],["name/14",[294,0.635]],["text/14",[1,1.334,17,1.094,23,1.079,25,1.94,26,1.351,37,1.428,40,2.069,67,1.901,68,1.172,71,3.328,97,2.796,99,1.757,103,2.227,118,2.886,120,1.374,128,1.374,157,2.182,158,2.1,159,2.147,160,0.755,161,1.415,164,3.282,166,2.757,167,2.584,168,2.732,169,2.597,170,2.517,171,2.732,172,2.597,173,2.854,175,0.43,176,0.326,177,0.347,182,3.914,185,2.227,198,2.53,246,4.33,247,1.757,257,3.282,284,1.757,295,0.7,296,0.9,306,3.28,315,0.965,322,1.351,326,1.162,327,1.314,330,2.146,340,1.55,343,1.55,344,1.458,345,1.415,347,1.458,348,1.503,351,1.458,352,1.415,353,2.146,354,1.415,355,1.503,367,1.285,373,1.81,375,1.079,377,2.37,378,2.886,380,1.884,381,2.1,382,1.951,387,3.066,393,1.761,399,1.82,418,1.516,425,2.478,443,2.478,444,2.503,445,3.282,498,3.965,514,4.915,538,1.516,545,1.672,561,1.516,567,1.888,571,2.743,572,2.829,574,2.1,584,2.597,672,2.597,673,2.597,674,3.914,698,3.914,723,1.936,724,2.829,729,1.428,755,1.757,790,1.757,841,1.623,903,1.351,908,1.516,923,3.914,966,2.743,1031,3.066,1081,2.886,1115,2.478,1127,1.351,1209,2.732,1210,3.489,1215,1.172,1240,2.37,1404,1.516,1409,1.285,1415,7.706,1416,2.829,1417,8.556,1418,2.208,1419,8.617,1420,2.208,1421,1.936,1422,3.118,1423,3.556,1424,1.623,1425,1.936,1426,2.208,1427,2.208,1428,2.208,1429,3.556,1430,2.208,1431,3.118,1432,3.914,1433,3.914,1434,2.886,1435,4.464,1436,6.77,1437,4.464,1438,4.464,1439,4.464,1440,5.995,1441,4.464,1442,4.464,1443,4.464,1444,4.464,1445,4.92,1446,4.464,1447,6.77,1448,4.464,1449,4.464,1450,6.77,1451,4.464,1452,4.464,1453,5.995,1454,6.77,1455,4.464,1456,4.464,1457,4.464,1458,4.464,1459,3.282,1460,5.995,1461,4.464,1462,4.464,1463,4.464,1464,4.464,1465,4.464,1466,4.464,1467,4.464,1468,4.464,1469,4.464,1470,3.552,1471,5.995,1472,4.464,1473,4.464,1474,4.464,1475,4.464,1476,4.464,1477,4.464,1478,5.995,1479,4.464,1480,4.464,1481,4.464,1482,4.464,1483,7.773,1484,7.773,1485,5.995,1486,5.995,1487,5.995,1488,4.464,1489,4.464,1490,4.464,1491,3.914,1492,4.464,1493,4.464,1494,3.282,1495,4.464,1496,3.552,1497,4.464,1498,4.464,1499,4.464,1500,4.464,1501,4.464,1502,4.464,1503,2.176,1504,3.556,1505,3.118,1506,3.556,1507,2.208,1508,2.208,1509,1.936,1510,3.556,1511,2.208,1512,1.757,1513,2.208,1514,2.208,1515,2.208]],["component/14",[293,0.599]],["title/15-1",[0,14.432]],["name/15-1",[]],["text/15-1",[]],["component/15-1",[]],["title/15-2",[175,4.511,176,5.502,177,5.858]],["name/15-2",[]],["text/15-2",[]],["component/15-2",[]],["title/15",[160,4.758,249,23.698,250,28.266,251,28.266]],["name/15",[294,0.635]],["text/15",[1,2.054,4,2.036,5,2.601,7,2.473,15,1.612,17,1.308,18,3.1,20,1.791,23,2.078,25,1.925,28,1.537,33,1.695,35,4.306,37,1.791,47,2.204,58,2.036,67,1.347,68,2.256,75,1.471,76,1.695,82,5.253,97,2.784,103,2.413,120,1.308,128,1.308,156,1.733,157,2.078,158,1.999,159,1.522,160,0.923,161,2.353,166,1.476,167,2.491,170,2.491,173,1.676,176,1.115,177,1.143,185,2.285,194,3.629,198,2.786,200,2.601,237,2.256,249,5.053,267,4.269,292,2.429,295,0.878,296,2.109,302,2.919,304,1.791,306,2.447,310,1.791,315,1.857,317,2.036,319,2.991,326,1.388,327,1.571,330,1.839,340,1.476,343,1.476,344,1.388,345,1.347,347,1.388,348,1.431,351,1.388,352,1.347,353,2.179,354,1.347,355,1.431,356,2.473,357,1.571,367,4.864,373,2.163,375,1.354,377,2.256,380,3.132,382,1.857,383,1.695,386,2.748,393,2.287,398,2.52,399,2.892,413,4.315,417,3.36,427,6.101,434,1.902,438,1.902,444,2.52,449,3.382,453,2.64,506,2.919,535,1.902,538,1.902,543,1.791,545,2.728,567,1.471,587,4.268,647,1.471,650,3.472,651,3.551,654,2.359,672,2.473,673,2.473,716,2.473,729,1.791,753,5.253,755,3.382,756,2.748,765,1.791,795,1.695,838,2.204,902,3.382,903,4.954,926,2.036,938,3.382,947,2.036,957,2.601,959,2.429,966,2.078,1067,3.382,1081,2.748,1114,3.551,1115,2.359,1121,1.902,1127,1.695,1142,3.749,1206,2.204,1210,2.473,1215,3.649,1278,2.919,1299,3.382,1308,2.036,1317,1.791,1330,3.382,1336,2.429,1341,2.919,1350,3.727,1361,3.382,1365,5.593,1404,3.551,1409,1.612,1410,2.919,1445,3.727,1494,5.951,1503,1.695,1516,2.036,1517,2.204,1518,2.036,1519,5.171,1520,3.727,1521,2.77,1522,2.77,1523,2.204,1524,2.429,1525,2.77,1526,5.171,1527,2.036,1528,2.204,1529,2.77,1530,4.534,1531,2.77,1532,2.77,1533,2.429,1534,2.77,1535,5.085,1536,6.876,1537,7.179,1538,6.602,1539,3.727,1540,3.727,1541,2.204,1542,2.77,1543,2.77,1544,2.429,1545,3.727,1546,2.429,1547,2.204,1548,2.77,1549,3.125,1550,2.429,1551,5.799,1552,6.876,1553,2.429,1554,4.25,1555,4.25,1556,4.534,1557,2.77,1558,2.204,1559,2.77,1560,2.77,1561,2.77,1562,2.77,1563,2.77,1564,2.77,1565,2.77,1566,2.204,1567,2.429,1568,2.77,1569,2.77,1570,2.204,1571,2.429,1572,2.77,1573,2.77,1574,2.204,1575,2.77,1576,2.77,1577,2.77,1578,2.77,1579,7.661,1580,7.092,1581,4.25,1582,4.25,1583,4.25,1584,5.799,1585,5.799,1586,4.25,1587,4.25,1588,4.25,1589,4.25,1590,5.799,1591,5.799,1592,4.25,1593,4.25,1594,4.25,1595,4.25,1596,6.602,1597,4.25,1598,5.799,1599,4.25,1600,4.25,1601,4.25,1602,4.25,1603,4.25,1604,4.25,1605,4.25,1606,4.25,1607,4.25,1608,4.25,1609,4.25,1610,6.602,1611,5.799,1612,4.25,1613,4.25,1614,5.799,1615,5.799,1616,5.799,1617,5.799,1618,4.25,1619,7.092,1620,5.799,1621,4.25,1622,4.25,1623,4.25,1624,4.25,1625,4.25,1626,4.25,1627,4.25,1628,4.25,1629,4.25,1630,4.25,1631,4.25]],["component/15",[293,0.599]],["title/16-1",[0,14.432]],["name/16-1",[]],["text/16-1",[]],["component/16-1",[]],["title/16-2",[175,5.348,176,6.521]],["name/16-2",[]],["text/16-2",[]],["component/16-2",[]],["title/16-3",[175,5.348,177,6.943]],["name/16-3",[]],["text/16-3",[]],["component/16-3",[]],["title/16",[160,5.502,252,25.601,253,32.685]],["name/16",[294,0.635]],["text/16",[1,1.618,2,2.756,17,1.666,18,2.083,25,2.018,28,1.353,29,4.604,33,1.492,50,2.138,52,1.674,67,1.986,71,1.353,72,1.94,80,1.674,97,2.788,99,3.062,101,3.057,103,2.497,120,1.467,128,1.467,160,0.968,161,2.217,166,1.655,167,2.521,170,2.375,173,2.47,175,0.466,176,1.234,177,0.383,185,2.153,195,3.274,198,2.284,222,2.426,234,2.331,245,3.274,252,4.919,288,1.576,291,1.241,295,0.773,296,1.569,297,1.294,298,1.576,303,1.192,306,2.951,319,2.16,323,1.674,326,1.557,327,1.762,330,1.511,343,1.655,344,1.557,345,1.511,347,1.557,348,1.605,351,1.557,352,1.511,353,2.217,354,1.511,355,1.605,356,2.774,357,1.762,361,1.94,373,2.426,374,5.461,375,1.881,379,4.522,380,2.643,381,3.494,382,3.372,384,5.492,394,2.426,398,2.974,399,2.554,412,3.15,422,5.295,423,5.483,428,2.646,434,1.674,442,3.082,443,2.646,444,2.67,445,3.505,448,4.18,449,3.793,453,2.643,465,3.082,489,3.793,528,6.279,532,2.918,562,2.488,571,1.881,574,2.242,586,3.793,596,4.984,640,2.331,647,2.043,649,1.792,650,1.353,656,1.94,716,3.644,725,1.792,730,1.792,744,1.576,747,1.94,765,2.488,771,1.192,788,2.138,795,1.492,849,6.614,858,1.576,892,6.133,912,2.138,963,3.374,1016,2.918,1115,2.136,1131,1.94,1157,3.374,1162,3.793,1201,3.062,1215,2.043,1275,2.138,1307,1.674,1309,3.793,1340,1.94,1341,1.674,1349,2.138,1410,1.674,1422,4.747,1459,2.829,1503,1.492,1530,4.18,1567,3.374,1632,2.438,1633,2.438,1634,2.138,1635,2.138,1636,1.94,1637,4.747,1638,4.18,1639,2.438,1640,3.848,1641,2.438,1642,2.438,1643,2.138,1644,2.438,1645,2.829,1646,2.438,1647,2.438,1648,2.138,1649,2.438,1650,3.848,1651,2.138,1652,2.438,1653,2.138,1654,2.438,1655,2.138,1656,3.848,1657,2.438,1658,2.138,1659,2.138,1660,2.138,1661,2.438,1662,5.414,1663,4.18,1664,2.438,1665,2.438,1666,1.792,1667,2.438,1668,2.438,1669,1.94,1670,2.438,1671,2.438,1672,2.138,1673,2.138,1674,2.138,1675,4.767,1676,6.263,1677,6.994,1678,4.767,1679,4.18,1680,4.767,1681,6.133,1682,4.767,1683,7.919,1684,7.919,1685,6.263,1686,6.263,1687,6.263,1688,7.428,1689,7.428,1690,4.767,1691,6.263,1692,4.767,1693,4.767,1694,4.767,1695,4.767,1696,4.767,1697,4.767,1698,4.767,1699,4.767,1700,4.767,1701,4.767,1702,4.767,1703,4.767,1704,6.263,1705,4.767,1706,4.767,1707,4.767,1708,4.767,1709,4.767,1710,4.767,1711,6.263,1712,6.263,1713,4.767,1714,4.767,1715,4.767,1716,4.18,1717,4.767,1718,6.263,1719,6.263,1720,6.263,1721,6.263,1722,6.994,1723,6.263,1724,4.767,1725,6.263,1726,4.767,1727,4.767,1728,6.263,1729,4.767,1730,6.263,1731,4.767,1732,4.767,1733,4.767,1734,4.767,1735,4.767,1736,4.767,1737,2.138,1738,2.138,1739,2.438,1740,2.438,1741,2.438,1742,2.438,1743,2.438,1744,2.138,1745,2.438]],["component/16",[293,0.599]],["title/17-1",[0,14.432]],["name/17-1",[]],["text/17-1",[]],["component/17-1",[]],["title/17-2",[175,5.348,176,6.521]],["name/17-2",[]],["text/17-2",[]],["component/17-2",[]],["title/17-3",[175,5.348,177,6.943]],["name/17-3",[]],["text/17-3",[]],["component/17-3",[]],["title/17",[160,4.758,254,23.698,255,25.651,256,28.266]],["name/17",[294,0.635]],["text/17",[1,1.198,2,0.761,5,2.454,6,2.688,17,1.715,18,0.653,22,2.044,23,1.96,25,1.859,26,2.764,31,4.15,37,0.966,43,2.044,58,1.889,60,1.19,66,3.018,67,1.563,68,1.793,72,1.19,76,0.915,88,0.915,97,2.792,100,2.962,101,1.476,103,2.432,120,1.04,128,1.04,156,2.994,158,1.589,159,2.293,160,0.221,161,1.846,162,3.924,164,4.281,166,2.469,167,2.523,170,2.4,172,1.966,173,2.525,175,0.547,176,1.162,177,0.875,185,1.04,206,2.067,209,5.614,217,2.545,218,4.03,220,2.411,222,2.51,225,3.564,227,2.618,234,1.652,243,3.188,254,4.442,255,6.665,274,2.483,283,1.311,288,0.966,289,0.83,291,0.761,295,0.474,296,1.048,298,0.966,299,6.602,303,2.847,304,3.602,306,2.702,315,1.123,319,3.677,322,0.915,323,1.027,326,1.104,330,2.159,340,1.173,343,1.173,344,1.104,345,1.071,347,1.104,348,1.137,351,1.104,352,1.071,353,1.846,354,1.071,355,1.137,360,1.027,361,1.19,364,2.483,366,2.184,373,3.466,374,1.099,375,2.208,379,1.661,380,1.425,398,2.962,399,3.069,408,1.19,410,0.87,413,0.761,417,1.719,425,4.404,427,1.099,432,3.999,438,1.027,443,2.737,453,2.081,486,1.652,493,1.966,498,3.589,514,4.137,517,5.971,538,1.027,540,1.311,545,1.208,552,2.32,557,1.311,562,0.966,571,0.731,574,3.203,605,0.966,632,2.32,640,1.96,650,0.83,651,1.027,661,2.962,727,5.106,730,1.889,744,2.184,746,1.19,756,2.184,790,1.19,843,4.593,848,1.311,858,1.661,886,1.764,895,1.19,903,2.067,913,1.311,926,1.099,944,1.027,947,4.281,957,0.915,989,2.962,1115,0.83,1127,0.915,1131,1.19,1132,1.311,1199,4.442,1215,2.398,1240,1.793,1280,2.962,1308,1.099,1333,1.099,1335,1.19,1341,1.764,1342,3.516,1343,1.19,1346,1.099,1352,4.707,1409,0.87,1410,3.387,1424,5.491,1434,0.966,1459,2.483,1494,2.483,1520,1.311,1636,4.808,1643,1.311,1660,2.962,1746,1.495,1747,1.495,1748,2.253,1749,2.253,1750,2.569,1751,1.495,1752,1.495,1753,4.885,1754,1.311,1755,1.099,1756,1.311,1757,2.044,1758,1.495,1759,2.962,1760,1.311,1761,1.495,1762,2.569,1763,2.569,1764,4.009,1765,1.495,1766,1.495,1767,1.495,1768,1.495,1769,1.495,1770,5.823,1771,2.569,1772,1.495,1773,5.298,1774,1.311,1775,1.495,1776,1.311,1777,1.495,1778,5.215,1779,4.516,1780,2.253,1781,4.009,1782,1.311,1783,1.19,1784,1.495,1785,1.495,1786,1.311,1787,1.495,1788,1.495,1789,5.345,1790,2.253,1791,1.495,1792,3.378,1793,2.688,1794,2.32,1795,2.962,1796,3.378,1797,3.378,1798,3.378,1799,3.378,1800,3.378,1801,3.378,1802,4.324,1803,3.378,1804,3.378,1805,5.823,1806,3.378,1807,3.378,1808,3.378,1809,3.378,1810,3.378,1811,3.378,1812,4.931,1813,3.378,1814,5.823,1815,3.378,1816,3.378,1817,3.378,1818,3.378,1819,3.378,1820,3.378,1821,3.378,1822,3.378,1823,6.403,1824,3.378,1825,4.931,1826,3.378,1827,3.378,1828,3.378,1829,4.931,1830,6.809,1831,4.931,1832,4.931,1833,7.526,1834,4.931,1835,3.378,1836,5.823,1837,3.378,1838,3.378,1839,3.378,1840,3.378,1841,3.378,1842,4.931,1843,7.11,1844,6.403,1845,4.931,1846,3.378,1847,3.378,1848,4.931,1849,3.378,1850,3.378,1851,3.378,1852,4.931,1853,3.378,1854,4.931,1855,3.378,1856,3.378,1857,3.378,1858,2.483,1859,3.378,1860,3.378,1861,4.931,1862,3.378,1863,4.931,1864,3.378,1865,3.378,1866,3.378,1867,3.378,1868,3.378,1869,3.378,1870,3.378,1871,3.378,1872,3.378,1873,4.931,1874,3.378,1875,3.378,1876,3.378,1877,3.378,1878,3.378,1879,3.378,1880,3.378,1881,3.378,1882,6.067,1883,5.298,1884,3.378,1885,3.378,1886,3.378,1887,3.378,1888,3.378,1889,3.378,1890,6.403,1891,4.931,1892,4.931,1893,2.962,1894,3.378,1895,4.931,1896,3.378,1897,3.378,1898,3.378,1899,3.378,1900,3.378,1901,3.378,1902,3.378,1903,3.378,1904,3.378,1905,6.403,1906,3.378,1907,4.931,1908,6.809,1909,3.378,1910,4.931,1911,3.378,1912,3.378,1913,5.823,1914,3.378,1915,3.378,1916,4.324,1917,3.378,1918,4.931,1919,4.931,1920,3.378,1921,3.378,1922,3.378,1923,3.378,1924,3.378,1925,3.378,1926,3.378,1927,3.378,1928,3.378,1929,3.378,1930,3.378,1931,3.378,1932,3.378,1933,3.378,1934,3.378,1935,3.378,1936,3.378,1937,3.378,1938,3.378,1939,3.378,1940,3.378,1941,1.495,1942,1.311,1943,1.495,1944,1.099,1945,1.495,1946,1.495,1947,1.19,1948,1.495,1949,1.495,1950,1.311,1951,1.495,1952,1.19]],["component/17",[293,0.599]],["title/18-1",[0,14.432]],["name/18-1",[]],["text/18-1",[]],["component/18-1",[]],["title/18-2",[175,5.348,176,6.521]],["name/18-2",[]],["text/18-2",[]],["component/18-2",[]],["title/18-3",[175,5.348,177,6.943]],["name/18-3",[]],["text/18-3",[]],["component/18-3",[]],["title/18",[160,4.758,257,23.698,258,28.266,259,28.266]],["name/18",[294,0.635]],["text/18",[1,1.185,2,0.46,13,0.664,17,0.278,18,1.733,19,0.664,23,0.441,25,1.748,28,0.501,32,0.62,33,3.284,35,2.012,52,0.62,63,0.718,66,3.175,67,2.121,71,1.546,78,0.718,79,0.62,80,1.913,90,1.307,97,2.791,101,2.267,103,2.201,120,1.115,128,1.115,156,2.698,157,2.537,158,2.44,159,2.369,160,0.792,161,1.921,166,1.801,167,2.242,170,1.597,175,0.199,176,1.217,177,1.313,185,2.036,194,1.772,198,2.792,200,0.553,217,3.413,220,2.963,222,3.563,225,4.59,227,3.717,230,3.849,234,2.963,237,1.924,240,2.664,246,2.489,252,2.489,257,4.535,260,3.814,265,2.664,268,4.864,271,2.664,280,2.489,284,0.718,289,0.912,291,2.641,293,0.27,295,0.286,296,1.136,297,3.329,302,0.62,306,2.264,310,0.584,315,1.982,317,0.664,319,0.745,326,1.184,327,1.34,330,1.149,343,1.258,344,1.184,345,1.149,351,1.184,352,1.149,353,1.645,354,1.149,355,1.22,367,3.704,374,1.208,376,1.006,381,2.44,382,3.183,383,2.218,393,1.429,394,1.845,398,3.157,399,1.617,410,0.525,413,0.46,415,2.884,417,0.46,425,1.546,443,2.012,444,1.383,493,2.109,498,4.006,514,4.879,531,0.718,537,2.612,545,1.865,546,2.442,552,1.553,554,0.718,562,0.584,565,0.792,567,3.38,571,1.939,574,3.112,584,5.023,589,2.483,604,3.918,640,3.449,647,1.2,649,1.208,650,3.97,654,0.912,662,1.441,681,3.178,683,4.864,684,4.455,685,4.822,686,4.822,687,3.178,721,2.933,724,1.799,725,2.916,729,1.062,744,0.584,765,1.8,771,3.234,793,1.307,796,1.913,827,3.178,845,2.442,858,0.584,859,4.848,864,3.335,870,0.792,882,0.718,886,0.62,909,0.664,911,0.664,916,0.792,934,0.718,937,1.441,945,3.814,957,0.553,966,3.234,1114,0.62,1115,0.501,1118,0.792,1126,0.664,1133,3.178,1139,0.62,1206,1.307,1215,0.479,1240,1.924,1266,0.718,1269,0.792,1278,3.686,1308,0.664,1313,0.718,1316,0.664,1317,1.062,1331,3.396,1335,1.307,1344,3.178,1346,0.664,1404,0.62,1408,0.792,1431,2.836,1432,0.792,1433,0.792,1434,2.343,1518,2.916,1527,0.664,1566,0.718,1570,0.718,1571,3.178,1645,1.208,1651,0.792,1655,0.792,1658,0.792,1659,0.792,1663,3.178,1757,0.718,1759,0.792,1760,2.442,1778,0.718,1795,4.549,1947,1.307,1953,0.903,1954,0.903,1955,0.903,1956,0.903,1957,1.643,1958,4.267,1959,0.903,1960,0.903,1961,0.792,1962,6.616,1963,4.536,1964,6.169,1965,2.785,1966,0.792,1967,0.903,1968,0.903,1969,0.903,1970,0.792,1971,1.643,1972,2.785,1973,0.792,1974,0.903,1975,0.903,1976,0.903,1977,0.792,1978,0.792,1979,0.903,1980,0.903,1981,0.903,1982,1.643,1983,0.903,1984,1.643,1985,4.848,1986,0.903,1987,0.903,1988,0.903,1989,0.903,1990,3.624,1991,3.624,1992,6.726,1993,7.924,1994,8.02,1995,8.172,1996,6.616,1997,6.06,1998,6.06,1999,5.188,2000,5.188,2001,7.72,2002,5.188,2003,5.188,2004,3.624,2005,3.624,2006,3.624,2007,3.624,2008,3.624,2009,3.624,2010,6.06,2011,3.624,2012,3.624,2013,3.624,2014,3.624,2015,6.616,2016,3.624,2017,6.06,2018,6.06,2019,3.624,2020,7.284,2021,7.284,2022,3.624,2023,3.624,2024,6.06,2025,3.624,2026,3.624,2027,3.624,2028,3.624,2029,3.624,2030,6.06,2031,3.624,2032,3.624,2033,3.624,2034,7.85,2035,5.678,2036,5.942,2037,3.624,2038,6.06,2039,5.188,2040,3.624,2041,7.5,2042,3.624,2043,6.06,2044,6.06,2045,3.178,2046,6.06,2047,3.624,2048,3.624,2049,3.624,2050,3.624,2051,5.188,2052,3.624,2053,3.624,2054,3.624,2055,3.624,2056,2.884,2057,3.624,2058,5.188,2059,3.624,2060,3.624,2061,3.178,2062,5.188,2063,5.188,2064,3.624,2065,3.624,2066,3.624,2067,5.188,2068,3.624,2069,5.188,2070,3.624,2071,3.624,2072,3.624,2073,3.624,2074,4.549,2075,5.188,2076,5.188,2077,3.624,2078,3.624,2079,3.624,2080,3.624,2081,3.178,2082,0.792,2083,2.785,2084,4.536,2085,4.776,2086,1.643,2087,0.903,2088,0.903,2089,0.903,2090,2.261,2091,0.903,2092,0.903,2093,0.903,2094,0.903,2095,1.643,2096,0.903,2097,0.903,2098,0.903,2099,0.792,2100,0.903,2101,0.903,2102,2.785,2103,1.643,2104,0.903,2105,1.208,2106,0.903,2107,0.903,2108,0.903,2109,0.903,2110,0.903,2111,0.903,2112,0.903,2113,0.903,2114,1.643,2115,0.903,2116,0.792,2117,1.643,2118,0.903,2119,0.903,2120,0.903,2121,0.903,2122,1.643,2123,1.643,2124,0.903,2125,0.903,2126,0.903,2127,0.903,2128,0.903,2129,0.903,2130,0.903,2131,0.903,2132,1.643,2133,0.903,2134,0.903,2135,0.792,2136,0.903,2137,0.903,2138,0.903,2139,2.261,2140,0.792,2141,0.903,2142,0.792,2143,0.903,2144,0.792,2145,0.718,2146,0.903,2147,0.903,2148,0.792]],["component/18",[293,0.599]],["title/19-1",[0,14.432]],["name/19-1",[]],["text/19-1",[]],["component/19-1",[]],["title/19-2",[175,5.348,176,6.521]],["name/19-2",[]],["text/19-2",[]],["component/19-2",[]],["title/19-3",[175,5.348,177,6.943]],["name/19-3",[]],["text/19-3",[]],["component/19-3",[]],["title/19",[160,5.502,260,27.404,261,32.685]],["name/19",[294,0.635]],["text/19",[1,0.411,7,3.312,15,0.562,17,1.96,18,0.223,20,0.33,23,0.249,25,1.449,26,0.312,29,2.331,31,0.35,35,3.786,52,2.178,67,2.343,68,2.499,75,0.513,88,0.312,97,2.792,101,2.057,103,1.728,117,2.781,118,3.043,120,0.976,128,0.976,156,1.919,157,2.301,158,2.64,159,1.686,160,0.075,161,1.78,166,2.156,167,2.605,168,1.941,169,3.266,170,2.477,171,1.941,172,1.845,173,3.116,174,3.746,175,0.167,176,1.247,177,1.293,185,2.139,194,2.744,195,4.266,197,4.127,198,2.369,200,1.941,217,3.545,218,0.33,220,4.111,222,4.059,225,2.881,227,3.297,230,2.739,237,2.499,246,3.233,252,2.178,260,2.494,287,0.312,295,0.162,296,0.561,297,0.73,299,6.639,303,0.249,315,1.168,319,0.438,326,1.036,327,1.172,330,2.436,340,1.101,342,2.781,343,1.101,344,1.036,345,1.005,347,1.036,348,1.068,349,2.781,351,1.036,352,1.492,353,2.204,354,1.005,375,0.249,376,0.312,380,1.338,381,2.947,382,3.23,393,2.214,398,2.933,399,2.706,414,4.525,417,1.929,424,1.845,425,4.396,427,2.331,428,2.613,430,1.095,432,3.855,439,0.312,444,2.371,453,2.369,486,1.55,493,3.266,524,2.076,543,1.129,545,1.492,549,4.922,550,3.233,552,0.35,571,0.249,574,3.139,584,3.266,604,2.05,605,1.347,632,2.178,647,0.927,650,0.536,730,0.375,736,0.847,746,0.406,747,2.524,756,2.05,771,1.55,839,0.447,850,0.406,860,0.447,878,0.406,886,0.35,931,0.406,945,0.71,946,0.406,966,1.55,1016,1.941,1107,3.461,1115,3.534,1127,3.027,1154,2.524,1180,2.781,1199,0.71,1201,0.769,1215,3.737,1240,2.499,1307,0.35,1309,2.333,1340,0.769,1341,0.35,1360,2.524,1407,0.71,1409,0.297,1410,0.945,1425,0.447,1503,0.591,1518,0.375,1545,0.447,1546,0.447,1547,0.406,1549,0.375,1558,0.406,1653,0.847,1666,0.375,1669,0.406,1716,0.447,1738,0.447,1753,2.344,1754,0.447,1755,0.375,1757,0.406,1782,0.447,1786,0.447,1789,2.494,1790,0.447,1858,2.917,1882,4.922,1916,4.922,1970,0.447,2074,6.481,2081,2.781,2145,0.406,2149,0.51,2150,0.447,2151,0.51,2152,0.51,2153,0.51,2154,0.51,2155,3.171,2156,7.346,2157,6.951,2158,3.171,2159,6.635,2160,4.707,2161,2.781,2162,3.171,2163,2.781,2164,5.613,2165,3.171,2166,5.613,2167,3.171,2168,3.171,2169,3.171,2170,4.707,2171,3.171,2172,3.171,2173,3.171,2174,3.171,2175,3.171,2176,3.171,2177,3.171,2178,3.171,2179,3.171,2180,3.171,2181,3.171,2182,3.171,2183,3.171,2184,3.171,2185,3.171,2186,3.171,2187,3.171,2188,3.171,2189,3.171,2190,3.171,2191,6.317,2192,3.171,2193,3.171,2194,4.707,2195,5.613,2196,3.171,2197,4.707,2198,3.171,2199,3.171,2200,3.171,2201,4.707,2202,4.707,2203,4.707,2204,4.707,2205,3.171,2206,3.171,2207,3.171,2208,3.171,2209,3.171,2210,3.171,2211,3.171,2212,3.171,2213,3.171,2214,4.707,2215,3.171,2216,3.171,2217,2.781,2218,4.707,2219,4.707,2220,4.707,2221,3.171,2222,3.171,2223,3.171,2224,3.171,2225,3.171,2226,3.171,2227,4.707,2228,3.171,2229,3.393,2230,3.043,2231,3.171,2232,4.707,2233,3.171,2234,3.171,2235,3.043,2236,3.171,2237,3.171,2238,3.171,2239,3.171,2240,3.171,2241,3.171,2242,3.171,2243,3.171,2244,3.171,2245,3.171,2246,3.171,2247,4.707,2248,3.171,2249,3.171,2250,3.171,2251,3.171,2252,3.171,2253,4.707,2254,3.171,2255,6.635,2256,3.171,2257,3.171,2258,3.171,2259,4.707,2260,3.171,2261,3.171,2262,3.171,2263,3.171,2264,3.171,2265,3.171,2266,4.707,2267,4.707,2268,3.171,2269,3.171,2270,3.171,2271,3.171,2272,3.171,2273,3.171,2274,6.635,2275,3.171,2276,3.171,2277,3.171,2278,3.171,2279,5.613,2280,2.781,2281,3.171,2282,3.171,2283,3.171,2284,3.171,2285,3.171,2286,3.171,2287,3.171,2288,3.171,2289,3.171,2290,3.171,2291,3.171,2292,3.171,2293,3.171,2294,6.095,2295,3.171,2296,3.171,2297,3.171,2298,3.171,2299,3.171,2300,3.171,2301,3.171,2302,3.171,2303,6.951,2304,4.707,2305,3.171,2306,6.211,2307,3.171,2308,3.171,2309,3.171,2310,3.171,2311,3.171,2312,3.171,2313,3.171,2314,3.171,2315,3.171,2316,3.171,2317,3.171,2318,3.171,2319,4.707,2320,4.707,2321,3.171,2322,3.171,2323,3.171,2324,3.171,2325,4.707,2326,3.171,2327,3.171,2328,3.171,2329,4.707,2330,5.613,2331,5.613,2332,3.171,2333,3.171,2334,4.707,2335,4.707,2336,3.171,2337,4.707,2338,3.171,2339,3.171,2340,3.171,2341,3.171,2342,3.171,2343,3.171,2344,3.171,2345,3.171,2346,3.171,2347,3.171,2348,3.171,2349,3.171,2350,3.171,2351,3.171,2352,3.171,2353,3.171,2354,3.171,2355,3.171,2356,3.171,2357,3.171,2358,3.171,2359,3.171,2360,3.171,2361,1.376,2362,0.51,2363,0.51,2364,0.447,2365,0.51,2366,0.51,2367,0.51,2368,0.51,2369,0.447,2370,0.51,2371,0.51,2372,0.51,2373,0.51,2374,0.51,2375,0.447,2376,0.51,2377,0.51]],["component/19",[293,0.599]],["title/20-1",[0,14.432]],["name/20-1",[]],["text/20-1",[]],["component/20-1",[]],["title/20-2",[175,5.348,176,6.521]],["name/20-2",[]],["text/20-2",[]],["component/20-2",[]],["title/20-3",[175,5.348,177,6.943]],["name/20-3",[]],["text/20-3",[]],["component/20-3",[]],["title/20",[160,4.758,262,22.139,263,25.651,264,25.651]],["name/20",[294,0.635]],["text/20",[1,0.954,2,1.227,5,0.85,7,2.753,13,1.021,16,0.954,17,0.742,18,1.886,23,1.864,25,1.456,26,0.85,27,1.217,28,1.338,32,0.954,33,0.85,35,1.338,40,0.808,67,1.787,71,3.546,78,1.105,79,2.964,80,1.655,88,0.85,97,2.79,101,2.068,103,2.343,120,0.983,128,0.983,156,1.929,157,3.253,158,3.13,159,2.383,160,0.75,161,1.976,166,2.773,167,2.634,170,2.328,173,3.307,175,0.292,176,1.166,177,0.599,185,1.918,194,1.561,195,3.25,217,2.463,234,2.313,243,2.065,262,4.025,263,5.469,264,6.571,276,1.772,289,0.771,291,0.707,295,0.44,296,1.302,297,2.025,315,0.607,316,0.898,322,0.85,323,2.193,326,1.043,327,1.18,330,1.5,340,1.109,343,1.109,344,1.043,345,1.012,347,1.043,348,1.075,351,1.043,352,1.012,353,1.976,354,1.012,355,1.075,357,1.18,364,1.021,369,3.059,373,2.408,375,1.178,379,3.644,381,2.225,382,2.068,383,0.85,385,2.193,393,1.26,394,1.626,398,3.223,399,2.298,410,1.858,413,1.941,417,2.738,430,1.105,439,0.85,444,1.219,453,1.348,487,3.478,494,1.105,498,3.526,514,4.478,532,2.896,533,3.871,535,0.954,537,1.475,538,0.954,545,1.794,547,4.149,570,3.25,574,2.651,584,2.219,589,2.753,603,2.8,609,2.541,640,1.561,647,2.025,654,0.771,656,1.918,672,3.872,673,3.872,683,3.478,684,3.478,685,2.541,686,3.765,756,0.898,771,3.407,824,2.8,838,3.765,851,2.113,873,2.541,908,2.193,925,1.918,935,1.105,944,1.655,946,1.105,949,1.655,957,2.896,966,2.313,982,2.348,1012,4.485,1081,2.065,1111,1.217,1120,2.8,1121,3.871,1126,1.772,1209,4.073,1210,4.055,1214,2.8,1316,1.021,1323,0.954,1333,1.021,1343,1.105,1346,1.021,1352,1.021,1365,1.655,1404,0.954,1416,3.434,1434,0.898,1470,2.541,1503,0.85,1512,1.105,1517,6.312,1518,1.772,1540,1.217,1541,1.105,1549,1.021,1550,6.93,1553,1.217,1558,2.541,1645,1.772,1666,1.021,1672,1.217,1783,1.105,1802,4.149,1893,4.149,1950,1.217,1952,2.541,1973,1.217,2056,2.541,2082,1.217,2099,1.217,2142,1.217,2145,1.105,2148,1.217,2156,4.149,2280,2.8,2378,1.217,2379,1.388,2380,3.194,2381,3.813,2382,3.784,2383,1.388,2384,6.528,2385,1.388,2386,4.316,2387,3.813,2388,1.388,2389,1.388,2390,1.388,2391,2.41,2392,1.388,2393,1.388,2394,1.388,2395,1.388,2396,1.388,2397,1.388,2398,1.105,2399,1.217,2400,1.217,2401,6.544,2402,7.773,2403,8.01,2404,1.388,2405,1.388,2406,1.388,2407,1.388,2408,1.388,2409,1.388,2410,1.388,2411,1.388,2412,1.388,2413,1.388,2414,1.388,2415,1.388,2416,3.344,2417,1.388,2418,1.388,2419,3.194,2420,3.194,2421,3.194,2422,3.194,2423,3.194,2424,4.731,2425,3.194,2426,6.633,2427,3.194,2428,3.194,2429,3.194,2430,3.194,2431,3.194,2432,3.194,2433,3.194,2434,3.194,2435,3.194,2436,3.194,2437,3.194,2438,3.194,2439,3.194,2440,4.731,2441,4.731,2442,4.942,2443,3.194,2444,3.194,2445,3.194,2446,4.731,2447,4.731,2448,4.731,2449,3.194,2450,3.194,2451,3.194,2452,4.731,2453,4.731,2454,3.194,2455,3.194,2456,3.194,2457,3.194,2458,3.194,2459,2.8,2460,2.541,2461,4.731,2462,6.654,2463,6.654,2464,7.565,2465,6.654,2466,7.565,2467,6.654,2468,3.194,2469,6.232,2470,4.731,2471,4.731,2472,5.636,2473,5.636,2474,3.194,2475,3.194,2476,4.731,2477,3.194,2478,4.731,2479,3.194,2480,3.194,2481,3.194,2482,6.232,2483,3.194,2484,2.8,2485,4.731,2486,3.194,2487,3.194,2488,3.194,2489,3.194,2490,3.194,2491,3.194,2492,3.194,2493,3.194,2494,4.731,2495,4.731,2496,4.731,2497,3.194,2498,3.194,2499,3.194,2500,3.194,2501,3.194,2502,3.194,2503,3.194,2504,3.194,2505,3.194,2506,3.194,2507,3.194,2508,3.194,2509,3.194,2510,3.194,2511,3.194,2512,3.194,2513,3.194,2514,3.194,2515,3.194,2516,4.149,2517,3.194,2518,3.194,2519,3.194,2520,3.194,2521,3.194,2522,3.194,2523,3.194,2524,3.194,2525,3.194,2526,3.194,2527,3.194,2528,3.194,2529,4.731,2530,3.194,2531,3.194,2532,4.731,2533,3.194,2534,3.194,2535,3.194,2536,2.8,2537,3.194,2538,2.8,2539,3.194,2540,3.194,2541,3.194,2542,3.194,2543,3.194,2544,3.194,2545,3.194,2546,3.194,2547,3.194,2548,3.194,2549,3.194,2550,3.194,2551,3.194,2552,3.194,2553,3.194,2554,4.731,2555,3.194,2556,3.194,2557,3.194,2558,3.194,2559,3.194,2560,3.194,2561,3.194,2562,3.194,2563,3.194,2564,3.194,2565,3.194,2566,3.813,2567,3.194,2568,3.194,2569,3.194,2570,3.194,2571,3.194,2572,3.194,2573,3.194,2574,3.194,2575,5.636,2576,3.194,2577,3.194,2578,4.149,2579,3.194,2580,3.194,2581,3.194,2582,4.731,2583,3.194,2584,3.194,2585,3.194,2586,2.8,2587,2.8,2588,2.8,2589,2.8,2590,3.194,2591,3.194,2592,2.41,2593,1.388,2594,1.388,2595,1.388]],["component/20",[293,0.599]],["title/21-1",[0,14.432]],["name/21-1",[]],["text/21-1",[]],["component/21-1",[]],["title/21-2",[175,4.511,176,5.502,177,5.858]],["name/21-2",[]],["text/21-2",[]],["component/21-2",[]],["title/21",[160,4.758,265,23.698,266,28.266,267,17.115]],["name/21",[294,0.635]],["text/21",[1,1.902,7,2.843,15,2.843,17,1.027,18,2.526,19,2.452,23,1.631,25,2.178,28,1.851,37,2.156,67,1.549,68,1.771,75,1.771,97,2.788,101,2.135,103,2.393,118,3.159,120,1.504,128,1.504,156,1.992,159,1.75,160,0.853,161,2.244,166,2.21,167,2.562,168,2.99,169,2.843,170,2.454,171,2.99,172,2.843,173,2.51,175,0.77,176,1.107,177,1.112,185,1.959,218,2.156,265,4.98,287,3.538,289,3.209,291,2.487,295,1.057,296,1.992,306,2.062,312,6.819,319,2.619,326,1.596,330,2.018,340,1.696,343,1.696,344,1.596,345,1.549,347,1.596,348,1.645,351,1.596,352,1.549,353,2.244,354,1.549,355,1.645,357,1.806,365,4.653,366,4.115,377,2.594,380,3.164,383,2.041,386,3.159,393,2.51,399,2.595,410,1.941,412,3.942,413,1.698,414,2.452,422,3.159,423,4.848,424,3.703,428,4.162,439,2.041,441,4.284,442,3.159,444,2.702,453,3.474,461,5.58,465,3.159,486,2.388,543,3.159,574,2.993,586,3.888,589,4.119,619,2.843,632,4.371,716,1.941,843,3.355,863,2.925,882,2.654,911,2.452,966,2.388,1012,2.654,1119,2.925,1142,3.159,1143,3.888,1240,2.594,1299,3.888,1307,2.291,1323,2.291,1326,2.925,1330,5.064,1331,4.6,1365,2.291,1409,1.941,1411,2.654,1424,2.452,1509,4.284,1517,2.654,1566,2.654,1570,2.654,1669,5.064,1679,4.284,1755,2.452,1778,5.633,1783,2.654,1793,3.888,1794,3.355,1944,2.452,1952,2.654,1977,2.925,1985,2.925,2116,2.925,2135,2.925,2144,2.925,2230,3.159,2235,3.159,2364,2.925,2538,2.925,2596,8.324,2597,5.781,2598,3.335,2599,7.313,2600,7.776,2601,3.335,2602,2.925,2603,3.335,2604,2.925,2605,3.335,2606,3.335,2607,3.335,2608,3.335,2609,3.335,2610,7.882,2611,7.078,2612,4.284,2613,4.885,2614,7.499,2615,4.885,2616,4.885,2617,6.364,2618,4.885,2619,3.888,2620,4.885,2621,4.885,2622,4.885,2623,6.364,2624,4.885,2625,4.284,2626,6.364,2627,4.885,2628,4.885,2629,4.885,2630,4.885,2631,4.885,2632,6.364,2633,4.885,2634,6.364,2635,4.885,2636,6.364,2637,4.885,2638,6.364,2639,4.885,2640,4.885,2641,4.885,2642,4.885,2643,4.885,2644,4.885,2645,4.885,2646,4.885,2647,4.885,2648,4.885,2649,4.885,2650,4.284,2651,4.885,2652,4.885,2653,4.885,2654,4.885,2655,4.885,2656,4.885,2657,4.885,2658,7.499,2659,4.885,2660,6.364,2661,6.364,2662,4.885,2663,4.885,2664,4.885,2665,4.885,2666,3.335,2667,3.335]],["component/21",[293,0.599]],["title/22-1",[0,14.432]],["name/22-1",[]],["text/22-1",[]],["component/22-1",[]],["title/22-2",[175,5.348,176,6.521]],["name/22-2",[]],["text/22-2",[]],["component/22-2",[]],["title/22-3",[175,5.348,177,6.943]],["name/22-3",[]],["text/22-3",[]],["component/22-3",[]],["title/22",[160,4.758,268,23.698,269,28.266,270,25.651]],["name/22",[294,0.635]],["text/22",[1,1.56,17,0.704,18,1.997,23,1.118,25,1.874,31,3.138,35,2.536,66,2.797,67,1.449,87,7.661,97,2.79,101,1.997,103,2.108,120,1.406,128,1.406,156,2.483,159,2.617,160,0.771,161,2.762,166,2.114,167,2.593,170,2.554,173,3.151,175,0.553,176,1.217,177,1.128,185,1.874,198,1.928,200,2.797,217,2.794,227,2.426,231,1.681,234,1.118,237,3.637,239,4.477,268,5.165,270,4.155,291,3.1,295,0.725,296,0.932,303,2.792,304,1.478,315,0.999,316,1.478,319,2.366,326,1.493,327,1.689,330,1.931,340,1.587,343,1.587,344,1.493,345,1.449,347,1.493,348,1.539,351,1.493,352,1.449,353,2.172,354,1.449,355,1.539,357,1.689,367,3.544,375,1.118,376,1.399,382,1.997,385,3.138,386,2.954,387,3.138,393,2.402,394,2.326,398,2.904,413,3.254,417,1.164,421,5.451,424,2.659,425,3.38,453,2.89,486,2.234,493,2.659,497,4.007,522,6.16,525,7.446,537,2.238,626,4.007,650,2.536,653,2.005,665,1.681,721,1.478,729,1.478,760,4.007,771,2.977,793,1.819,795,2.238,796,3.138,841,2.688,867,1.819,871,3.636,902,1.819,933,3.839,944,3.922,957,3.727,966,2.234,1016,2.797,1081,2.954,1209,2.797,1240,3.233,1303,1.819,1317,1.478,1516,2.688,1527,2.688,1528,1.819,1533,2.005,1535,5.34,1541,1.819,1574,1.819,1636,5.451,1744,2.005,1748,2.005,1858,1.681,1883,5.34,1992,4.007,2105,1.681,2217,4.007,2668,3.657,2669,2.286,2670,6.394,2671,7.988,2672,3.657,2673,2.286,2674,2.005,2675,2.286,2676,2.286,2677,2.286,2678,2.286,2679,2.286,2680,2.286,2681,3.657,2682,2.286,2683,2.286,2684,2.286,2685,2.286,2686,2.286,2687,2.286,2688,2.286,2689,4.007,2690,4.57,2691,4.846,2692,4.57,2693,4.57,2694,6.85,2695,6.09,2696,4.57,2697,4.57,2698,4.57,2699,7.305,2700,6.09,2701,4.57,2702,4.57,2703,4.57,2704,6.09,2705,4.57,2706,4.57,2707,7.305,2708,4.57,2709,4.57,2710,6.09,2711,4.57,2712,4.57,2713,4.57,2714,6.09,2715,6.09,2716,4.57,2717,4.57,2718,6.09,2719,4.007,2720,4.57,2721,4.57,2722,7.826,2723,7.305,2724,4.57,2725,6.09,2726,6.09,2727,6.09,2728,4.57,2729,4.57,2730,6.09,2731,6.09,2732,4.57,2733,4.57,2734,6.85,2735,6.09,2736,6.09,2737,4.57,2738,4.57,2739,6.09,2740,4.57,2741,4.57,2742,6.09,2743,6.09,2744,6.85,2745,6.09,2746,4.57,2747,4.57,2748,4.57,2749,4.57,2750,4.57,2751,4.57,2752,4.57,2753,4.57,2754,4.57]],["component/22",[293,0.599]],["title/23-1",[0,14.432]],["name/23-1",[]],["text/23-1",[]],["component/23-1",[]],["title/23-2",[175,4.511,176,5.502,177,5.858]],["name/23-2",[]],["text/23-2",[]],["component/23-2",[]],["title/23",[160,4.758,271,23.698,272,28.266,273,28.266]],["name/23",[294,0.635]],["text/23",[1,1.284,15,2.501,17,1.323,18,1.878,25,1.524,67,2.437,68,1.109,75,1.109,81,2.498,97,2.792,101,0.913,103,1.798,118,2.197,120,1.046,128,1.046,156,2.512,159,1.952,160,0.634,161,2.164,166,2.691,167,2.585,168,3.031,169,2.882,170,2.486,171,3.031,172,2.882,173,2.692,174,3.941,175,0.599,176,1.113,177,0.675,185,1.524,198,2.709,206,3.031,217,1.485,271,4.008,289,1.886,291,1.73,295,0.662,296,1.386,297,1.109,306,3.007,315,0.913,326,0.682,327,0.772,330,2.164,340,1.18,343,1.18,344,1.11,345,1.077,346,2.98,347,1.11,348,1.144,351,1.11,352,1.077,353,1.853,354,1.077,355,1.144,357,1.256,366,4.874,369,2.778,373,1.73,375,1.661,377,1.804,378,2.197,379,2.197,380,1.434,381,2.329,382,3.114,383,4.177,393,2.305,394,1.73,397,2.98,399,2.02,401,2.98,417,1.063,426,1.661,443,1.886,444,1.297,453,1.434,493,1.977,506,2.334,524,1.278,528,5.238,531,1.661,535,2.334,537,1.278,543,1.35,545,1.598,567,1.109,571,1.661,574,3.351,596,3.941,605,3.778,619,2.882,640,1.661,654,1.886,657,1.831,683,3.641,684,3.641,694,1.831,716,1.215,743,1.831,771,2.665,796,2.334,909,3.159,931,2.704,933,3.641,935,3.941,944,1.434,947,4.008,949,2.334,966,2.665,1016,2.08,1124,1.831,1126,1.535,1127,3.031,1130,5.283,1161,2.98,1207,1.831,1240,1.804,1266,1.661,1278,1.434,1316,2.498,1317,2.197,1323,2.334,1339,1.831,1407,1.535,1409,1.215,1411,1.661,1416,4.65,1421,4.343,1424,3.159,1434,1.35,1470,2.704,1503,2.08,1512,1.661,1516,4.008,1523,1.661,1536,5.124,1537,5.124,1547,1.661,1549,2.498,1552,2.98,1556,2.98,1574,1.661,1635,2.98,1645,2.498,1673,1.831,1776,1.831,1789,2.498,1793,1.661,1794,1.434,1858,1.535,1944,2.498,1966,1.831,1978,1.831,2150,2.98,2161,2.98,2163,2.98,2230,3.202,2235,3.202,2294,1.831,2378,2.98,2382,2.98,2398,1.661,2399,2.98,2400,2.98,2401,1.831,2416,5.63,2442,2.98,2578,4.343,2604,1.831,2689,2.98,2691,2.704,2755,2.088,2756,7.125,2757,4.953,2758,2.088,2759,2.088,2760,3.398,2761,6.826,2762,2.088,2763,2.088,2764,2.088,2765,3.398,2766,4.953,2767,2.088,2768,2.088,2769,4.297,2770,2.088,2771,2.088,2772,2.088,2773,3.398,2774,7.355,2775,3.398,2776,3.398,2777,8.448,2778,8.281,2779,8.281,2780,8.281,2781,3.398,2782,3.398,2783,3.398,2784,2.704,2785,4.953,2786,3.398,2787,4.953,2788,3.398,2789,4.953,2790,3.398,2791,3.398,2792,3.398,2793,5.843,2794,3.398,2795,3.398,2796,3.398,2797,3.398,2798,3.398,2799,4.953,2800,3.398,2801,4.953,2802,3.398,2803,3.398,2804,4.953,2805,3.398,2806,4.953,2807,3.398,2808,3.398,2809,3.398,2810,3.398,2811,4.953,2812,3.398,2813,4.953,2814,3.398,2815,4.953,2816,7.355,2817,3.398,2818,3.398,2819,3.398,2820,3.398,2821,3.398,2822,4.953,2823,3.398,2824,3.398,2825,3.398,2826,3.398,2827,6.826,2828,4.953,2829,4.953,2830,5.843,2831,3.398,2832,3.398,2833,3.398,2834,6.421,2835,3.398,2836,3.398,2837,4.953,2838,3.398,2839,3.398,2840,3.398,2841,3.398,2842,3.398,2843,3.398,2844,3.398,2845,3.398,2846,3.398,2847,3.398,2848,3.398,2849,3.398,2850,3.398,2851,3.398,2852,3.398,2853,3.398,2854,3.398,2855,3.398,2856,3.398,2857,5.843,2858,3.398,2859,3.398,2860,6.826,2861,3.398,2862,3.398,2863,4.953,2864,4.953,2865,3.398,2866,3.398,2867,3.398,2868,2.98,2869,3.398,2870,3.398,2871,6.16,2872,3.398,2873,3.398,2874,3.398,2875,3.398,2876,3.398,2877,3.398,2878,3.398,2879,3.398,2880,4.953,2881,3.398,2882,3.398,2883,4.953,2884,3.398,2885,3.398,2886,3.398,2887,3.398,2888,3.398,2889,3.398,2890,3.398,2891,4.953,2892,3.398,2893,3.398,2894,3.398,2895,3.398,2896,3.398,2897,4.953,2898,4.953,2899,3.398,2900,3.398,2901,3.398,2902,2.088,2903,2.088,2904,2.088,2905,2.088,2906,2.088]],["component/23",[293,0.599]],["title/24-1",[0,14.432]],["name/24-1",[]],["text/24-1",[]],["component/24-1",[]],["title/24-2",[175,4.511,176,5.502,177,5.858]],["name/24-2",[]],["text/24-2",[]],["component/24-2",[]],["title/24",[160,5.502,274,27.404,275,29.662]],["name/24",[294,0.635]],["text/24",[0,0.313,1,1.159,2,0.598,7,3.288,16,0.807,17,0.863,18,1.225,19,0.864,20,1.346,22,0.935,25,1.32,28,0.652,37,0.76,43,0.935,66,1.716,67,1.652,71,2.892,75,0.624,80,0.807,81,1.531,82,0.935,97,2.792,98,1.031,101,2.47,103,2.435,120,0.863,128,0.863,156,2.565,157,3.243,158,2.958,159,2.472,160,0.173,161,2.624,162,3.414,164,2.061,166,2.668,167,2.576,168,2.626,169,3.396,170,2.524,171,2.626,172,2.496,173,2.937,175,0.142,176,1.106,177,1.058,185,0.863,194,2.097,198,1.183,206,4.76,217,2.277,220,2.547,222,2.652,227,2.766,233,0.935,234,2.097,237,1.489,245,2.329,267,1.489,274,2.493,275,6.365,287,0.719,288,0.76,295,0.373,297,1.8,298,1.346,302,0.807,306,2.463,310,0.76,314,1.031,315,0.91,319,0.944,330,0.889,345,0.889,347,0.916,348,0.944,351,0.916,352,0.889,353,1.652,354,0.889,360,0.807,364,0.864,365,4.008,366,4.221,367,0.684,368,2.459,373,2.184,377,1.489,378,1.813,380,2.463,381,3.247,382,2.749,393,1.692,398,2.569,399,2.976,412,1.212,421,0.935,424,1.631,428,2.381,436,1.031,442,1.813,444,1.637,447,1.926,453,3.348,465,1.813,486,1.371,493,1.631,498,2.097,528,0.864,532,4.467,533,5.57,545,0.553,551,1.031,567,0.624,568,2.231,569,2.231,570,2.946,574,0.553,584,1.631,587,2.774,619,1.631,640,1.371,647,0.624,651,0.807,654,0.652,665,2.061,671,5.515,672,3.66,673,3.66,716,1.631,721,1.346,735,0.864,744,0.76,757,5.962,765,1.813,771,3.136,794,1.031,795,0.719,796,1.926,803,2.459,841,5.324,842,1.031,849,5.849,850,0.935,864,0.864,871,3.693,873,0.935,908,1.926,933,0.864,934,0.935,936,5.118,945,5.568,957,0.719,966,2.097,982,3.154,991,3.762,1045,1.031,1067,2.231,1114,3.578,1121,0.807,1135,3.414,1137,3.83,1139,2.946,1142,3.369,1209,3.189,1210,3.396,1217,2.459,1240,2.278,1258,5.118,1303,2.231,1311,1.826,1312,1.826,1313,0.935,1318,1.031,1328,1.031,1333,1.531,1352,4.002,1365,1.926,1407,0.864,1409,1.212,1434,0.76,1496,2.231,1503,1.275,1516,1.531,1523,0.935,1524,1.031,1527,0.864,1528,0.935,1539,1.031,1544,1.031,1634,1.031,1637,1.826,1638,1.826,1648,1.031,1674,1.031,1737,3.762,1749,1.031,1755,0.864,1756,1.031,1774,2.459,1780,1.031,1794,2.946,1942,1.826,1947,0.935,1961,1.031,2230,4.067,2235,4.067,2369,1.031,2375,1.031,2398,1.657,2459,2.459,2460,2.231,2484,1.031,2516,2.459,2602,1.031,2619,3.414,2674,1.031,2691,2.231,2719,2.459,2784,3.414,2907,2.083,2908,2.083,2909,1.175,2910,1.175,2911,1.175,2912,1.175,2913,4.29,2914,1.175,2915,1.175,2916,2.083,2917,1.175,2918,6.003,2919,1.175,2920,1.175,2921,2.083,2922,1.175,2923,5.836,2924,2.083,2925,6.414,2926,1.175,2927,1.175,2928,1.175,2929,1.175,2930,1.175,2931,1.175,2932,1.175,2933,1.175,2934,2.083,2935,1.175,2936,1.175,2937,1.175,2938,1.175,2939,1.175,2940,2.804,2941,2.804,2942,2.804,2943,2.459,2944,2.804,2945,2.804,2946,2.804,2947,2.804,2948,2.804,2949,2.804,2950,2.804,2951,2.804,2952,2.804,2953,2.804,2954,7.574,2955,5.21,2956,2.804,2957,2.804,2958,2.804,2959,4.29,2960,2.804,2961,2.804,2962,6.903,2963,2.804,2964,4.29,2965,2.804,2966,5.21,2967,4.29,2968,2.804,2969,2.804,2970,2.804,2971,2.804,2972,4.29,2973,2.804,2974,2.459,2975,7.86,2976,5.21,2977,2.804,2978,4.29,2979,5.836,2980,7.298,2981,7.12,2982,2.804,2983,2.804,2984,2.804,2985,2.804,2986,2.459,2987,4.29,2988,2.804,2989,2.804,2990,4.29,2991,2.804,2992,2.804,2993,2.804,2994,2.804,2995,2.804,2996,5.21,2997,5.21,2998,4.29,2999,5.21,3000,6.243,3001,2.804,3002,2.804,3003,2.804,3004,2.804,3005,2.804,3006,2.804,3007,5.21,3008,2.804,3009,2.804,3010,2.804,3011,2.804,3012,2.804,3013,4.29,3014,2.804,3015,2.804,3016,2.804,3017,2.804,3018,2.804,3019,2.804,3020,6.29,3021,6.29,3022,6.29,3023,5.836,3024,4.29,3025,4.29,3026,5.21,3027,2.804,3028,2.804,3029,2.804,3030,2.804,3031,5.21,3032,4.29,3033,2.804,3034,2.804,3035,2.804,3036,2.804,3037,2.804,3038,2.804,3039,2.804,3040,2.804,3041,2.804,3042,5.21,3043,2.804,3044,4.29,3045,4.29,3046,2.804,3047,5.21,3048,2.804,3049,2.804,3050,2.804,3051,2.804,3052,2.804,3053,2.804,3054,2.804,3055,2.804,3056,2.804,3057,2.804,3058,2.804,3059,2.804,3060,2.804,3061,5.21,3062,5.21,3063,2.804,3064,5.21,3065,2.804,3066,4.569,3067,4.29,3068,2.804,3069,2.804,3070,2.804,3071,5.21,3072,2.804,3073,2.804,3074,2.804,3075,2.804,3076,2.804,3077,4.29,3078,2.804,3079,2.804,3080,2.804,3081,2.804,3082,2.804,3083,4.29,3084,2.804,3085,2.804,3086,2.804,3087,2.804,3088,2.804,3089,2.804,3090,2.804,3091,2.804,3092,2.804,3093,2.804,3094,4.29,3095,2.804,3096,2.804,3097,2.804,3098,2.804,3099,2.804,3100,2.804,3101,2.804]],["component/24",[293,0.599]],["title/25-1",[0,14.432]],["name/25-1",[]],["text/25-1",[]],["component/25-1",[]],["title/25-2",[175,4.511,176,5.502,177,5.858]],["name/25-2",[]],["text/25-2",[]],["component/25-2",[]],["title/25",[160,4.191,276,20.876,277,22.596,278,22.596,279,24.899]],["name/25",[294,0.635]],["text/25",[0,1.041,1,1.364,7,2.277,13,1.343,17,2.422,25,1.686,40,3.677,67,2.17,68,0.97,96,4.447,97,2.79,101,2.217,103,2.321,120,2.148,128,1.204,156,2.978,159,2.452,160,0.578,161,1.737,166,2.93,167,2.575,170,2.565,173,2.945,176,1.184,177,0.287,185,1.405,220,2.678,230,1.063,234,2.678,249,1.343,267,0.97,276,4.027,289,1.014,291,0.93,295,0.579,296,0.745,297,0.97,302,1.254,306,1.651,315,0.798,317,1.343,323,2.687,326,0.597,327,0.675,330,2.213,340,1.359,343,1.359,344,1.278,345,1.241,347,1.278,348,1.318,351,0.597,352,0.579,353,1.447,354,0.579,355,0.615,357,0.675,369,1.181,373,2.957,375,0.893,377,3.084,378,4.086,379,3.541,380,2.311,381,2.576,382,2.992,385,2.687,394,1.992,398,2.851,399,2.234,410,1.063,418,1.254,425,4.185,432,5.786,444,2.217,486,1.913,487,2.877,498,3.523,514,3.794,524,1.118,545,0.859,552,1.254,558,1.602,562,1.181,567,0.97,568,1.453,569,1.453,570,1.254,571,0.893,574,3.22,589,4.552,604,5.163,651,2.687,665,1.343,725,1.343,756,4.426,761,3.431,765,1.181,771,2.975,875,1.602,903,2.395,908,4.794,909,1.343,926,2.877,927,1.602,938,1.453,949,2.687,966,3.188,982,4.027,1031,3.762,1127,2.395,1160,3.431,1210,1.063,1317,1.181,1323,2.09,1361,3.114,1362,3.431,1491,7.161,1494,1.343,1496,3.114,1666,1.343,1681,6.549,1773,1.602,1789,5.298,1794,1.254,1944,1.343,2045,1.602,2056,3.114,2061,3.431,2105,1.343,2140,1.602,2230,2.53,2235,2.53,2426,6.67,2460,3.114,2536,6.723,2586,1.602,2587,1.602,2588,1.602,2589,1.602,2868,3.431,2974,3.431,3102,1.826,3103,8.486,3104,3.044,3105,1.826,3106,1.826,3107,1.826,3108,1.826,3109,1.826,3110,1.826,3111,5.072,3112,1.826,3113,1.826,3114,1.826,3115,4.565,3116,7.91,3117,1.826,3118,4.565,3119,3.913,3120,3.913,3121,7.206,3122,6.846,3123,6.846,3124,6.846,3125,5.478,3126,6.32,3127,5.478,3128,5.478,3129,7.824,3130,5.478,3131,3.913,3132,3.913,3133,3.913,3134,3.913,3135,5.478,3136,3.913,3137,3.913,3138,3.913,3139,3.913,3140,3.913,3141,6.32,3142,3.913,3143,3.913,3144,3.913,3145,5.478,3146,3.913,3147,3.913,3148,3.913,3149,3.913,3150,3.913,3151,3.913,3152,3.913,3153,3.913,3154,3.913,3155,3.913,3156,7.95,3157,3.913,3158,3.913,3159,3.913,3160,3.913,3161,3.913,3162,3.913,3163,5.478,3164,6.846,3165,5.478,3166,3.913,3167,3.913,3168,3.913,3169,6.32,3170,3.913,3171,3.913,3172,3.913,3173,3.913,3174,6.846,3175,3.913,3176,6.846,3177,3.913,3178,3.913,3179,3.913,3180,3.913,3181,3.913,3182,3.913,3183,3.913,3184,3.913,3185,3.913,3186,5.478,3187,3.913,3188,3.913,3189,3.913,3190,3.913,3191,5.478,3192,3.913,3193,3.913,3194,6.846,3195,5.478,3196,3.913,3197,6.32,3198,3.913,3199,3.913,3200,3.913,3201,3.913,3202,5.478,3203,5.478,3204,3.913,3205,3.913,3206,3.913,3207,3.913,3208,3.913,3209,3.913,3210,3.913,3211,3.913,3212,3.913,3213,1.826,3214,1.826]],["component/25",[293,0.599]],["title/26-1",[0,7.556,175,5.243,176,4.191,177,4.462]],["name/26-1",[]],["text/26-1",[]],["component/26-1",[]],["title/26",[160,4.758,280,22.139,281,28.266,282,28.266]],["name/26",[294,0.635]],["text/26",[1,1.869,17,1.464,25,1.925,71,4.478,97,2.788,103,2.284,120,1.464,128,1.464,156,1.94,157,2.325,158,2.237,159,2.24,160,0.923,161,2.509,166,2.171,167,2.519,168,2.911,169,2.768,170,2.592,171,2.911,172,2.768,173,2.927,176,1.138,185,1.925,194,3.057,280,4.798,295,1.508,306,2.948,326,1.554,327,1.758,330,1.983,340,1.651,343,1.651,344,1.554,345,1.508,347,1.554,352,1.508,353,2.215,354,1.508,355,1.602,357,1.758,376,4.276,380,2.007,398,2.667,399,1.94,412,2.768,424,3.639,428,2.64,444,1.815,453,2.639,486,2.325,532,5.155,533,5.785,561,3.267,571,3.416,632,3.267,640,2.325,672,2.768,673,2.768,771,2.325,966,2.325,1031,5.097,1137,5.456,1139,5.097,1209,2.911,1210,2.768,1215,3.709,1240,2.525,1307,3.267,1360,3.785,1459,3.497,1505,4.171,2105,3.497,2230,3.075,2235,3.075,2612,4.171,2619,3.785,2625,4.171,2650,4.171,2784,3.785,2943,4.171,2986,4.171,3000,4.171,3066,5.483,3215,7.422,3216,6.254,3217,6.254,3218,4.756,3219,4.756,3220,4.756,3221,4.756,3222,4.756,3223,4.756,3224,4.756,3225,4.756,3226,4.756,3227,7.422,3228,7.422,3229,6.254,3230,6.254,3231,4.756,3232,6.254,3233,4.756,3234,4.756,3235,6.254,3236,6.254,3237,4.756,3238,4.756,3239,4.756,3240,4.756,3241,6.254,3242,4.756,3243,4.756,3244,4.756,3245,4.756,3246,4.756,3247,4.756]],["component/26",[293,0.599]]],"invertedIndex":[["",{"_index":97,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["0",{"_index":398,"title":{},"name":{},"text":{"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"12":{},"13":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"22":{},"24":{},"25":{},"26":{}},"component":{}}],["0'..='9",{"_index":2167,"title":{},"name":{},"text":{"19":{}},"component":{}}],["0)).into",{"_index":3244,"title":{},"name":{},"text":{"26":{}},"component":{}}],["0,7],4],[15,[0,13]]],[1,1",{"_index":2324,"title":{},"name":{},"text":{"19":{}},"component":{}}],["0,7],4],[[7,8],[0,13]]],[1,1",{"_index":2325,"title":{},"name":{},"text":{"19":{}},"component":{}}],["0,7],4],[[7,8],[0,[6,7]]]],[1,1",{"_index":2327,"title":{},"name":{},"text":{"19":{}},"component":{}}],["0,7],4],[[7,8],[6,0]]],[8,1",{"_index":2357,"title":{},"name":{},"text":{"19":{}},"component":{}}],["0,9],2],3],4",{"_index":2312,"title":{},"name":{},"text":{"19":{}},"component":{}}],["0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5",{"_index":2343,"title":{},"name":{},"text":{"19":{}},"component":{}}],["0..(n_timer",{"_index":767,"title":{},"name":{},"text":{"7":{}},"component":{}}],["0..3",{"_index":2446,"title":{},"name":{},"text":{"20":{}},"component":{}}],["0..3).filter_map(|_",{"_index":2854,"title":{},"name":{},"text":{"23":{}},"component":{}}],["0..3).map(|_",{"_index":2701,"title":{},"name":{},"text":{"22":{}},"component":{}}],["0..3).map(|i",{"_index":2452,"title":{},"name":{},"text":{"20":{}},"component":{}}],["0..=9",{"_index":1001,"title":{},"name":{},"text":{"9":{}},"component":{}}],["0..=max_dist",{"_index":1701,"title":{},"name":{},"text":{"16":{}},"component":{}}],["0..game.boards.len()).collect",{"_index":635,"title":{},"name":{},"text":{"5":{}},"component":{}}],["0..grown_mat.ncol",{"_index":2639,"title":{},"name":{},"text":{"21":{}},"component":{}}],["0..grown_mat.nrow",{"_index":2637,"title":{},"name":{},"text":{"21":{}},"component":{}}],["0..k",{"_index":1719,"title":{},"name":{},"text":{"16":{}},"component":{}}],["0..n",{"_index":1299,"title":{},"name":{},"text":{"12":{},"15":{},"21":{}},"component":{}}],["0..n_col",{"_index":489,"title":{},"name":{},"text":{"4":{},"10":{},"16":{}},"component":{}}],["0..n_cols).filter_map(mov",{"_index":1173,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["0..n_row",{"_index":1162,"title":{},"name":{},"text":{"10":{},"12":{},"16":{}},"component":{}}],["0..n_time",{"_index":773,"title":{},"name":{},"text":{"7":{}},"component":{}}],["0..self.height",{"_index":3218,"title":{},"name":{},"text":{"26":{}},"component":{}}],["0..self.mat.ncol",{"_index":2616,"title":{},"name":{},"text":{"21":{}},"component":{}}],["0..self.mat.nrow",{"_index":2615,"title":{},"name":{},"text":{"21":{}},"component":{}}],["0..self.width",{"_index":3219,"title":{},"name":{},"text":{"26":{}},"component":{}}],["0..tiles.ncol",{"_index":2997,"title":{},"name":{},"text":{"24":{}},"component":{}}],["0..tiles.nrow",{"_index":2996,"title":{},"name":{},"text":{"24":{}},"component":{}}],["0_usiz",{"_index":1258,"title":{},"name":{},"text":{"11":{},"24":{}},"component":{}}],["0usize].map(|plac",{"_index":1801,"title":{},"name":{},"text":{"17":{}},"component":{}}],["0x2588",{"_index":1492,"title":{},"name":{},"text":{"14":{}},"component":{}}],["0–9",{"_index":922,"title":{},"name":{},"text":{"9":{}},"component":{}}],["1",{"_index":176,"title":{"2":{},"2-2":{},"3-2":{},"4-2":{},"5-2":{},"6-2":{},"7-2":{},"8-2":{},"9-2":{},"10-2":{},"11-2":{},"12-2":{},"13-2":{},"14-2":{},"15-2":{},"16-2":{},"17-2":{},"18-2":{},"19-2":{},"20-2":{},"21-2":{},"22-2":{},"23-2":{},"24-2":{},"25-2":{},"26-1":{}},"name":{},"text":{"1":{},"2":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["1)&t",{"_index":2091,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1).unwrap",{"_index":346,"title":{},"name":{},"text":{"2":{},"23":{}},"component":{}}],["1)/2",{"_index":2029,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1)^2",{"_index":2031,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1)}{2t",{"_index":2107,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1)}{2t}&t\\le",{"_index":2110,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1+2+\\ldots+n=\\frac{1}{2}n(n+1",{"_index":2087,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1,1",{"_index":2338,"title":{},"name":{},"text":{"19":{}},"component":{}}],["1,[[[9,3],9],[[9,0],[0,7",{"_index":2350,"title":{},"name":{},"text":{"19":{}},"component":{}}],["1..=9",{"_index":3179,"title":{},"name":{},"text":{"25":{}},"component":{}}],["1..=die_n_fac",{"_index":2734,"title":{},"name":{},"text":{"22":{}},"component":{}}],["1..=digit).rev",{"_index":3210,"title":{},"name":{},"text":{"25":{}},"component":{}}],["1..=roots::sqrt(&abs_eight_i",{"_index":2042,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1..=sideroom_max_row).all(|row",{"_index":3054,"title":{},"name":{},"text":{"24":{}},"component":{}}],["10",{"_index":237,"title":{"11":{}},"name":{},"text":{"1":{},"11":{},"12":{},"13":{},"15":{},"18":{},"19":{},"22":{},"24":{}},"component":{}}],["100",{"_index":1303,"title":{},"name":{},"text":{"12":{},"22":{},"24":{}},"component":{}}],["1000",{"_index":2719,"title":{},"name":{},"text":{"22":{},"24":{}},"component":{}}],["1000000",{"_index":1987,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1001000",{"_index":1988,"title":{},"name":{},"text":{"18":{}},"component":{}}],["10011",{"_index":437,"title":{},"name":{},"text":{"4":{}},"component":{}}],["103",{"_index":1398,"title":{},"name":{},"text":{"13":{}},"component":{}}],["10707",{"_index":2591,"title":{},"name":{},"text":{"20":{}},"component":{}}],["10_usize.pow(u32::try_from(pow10).unwrap",{"_index":1108,"title":{},"name":{},"text":{"9":{}},"component":{}}],["11",{"_index":240,"title":{"12":{}},"name":{},"text":{"1":{},"12":{},"18":{}},"component":{}}],["112",{"_index":2079,"title":{},"name":{},"text":{"18":{}},"component":{}}],["11931881141161\".to_own",{"_index":3214,"title":{},"name":{},"text":{"25":{}},"component":{}}],["1197",{"_index":1252,"title":{},"name":{},"text":{"11":{}},"component":{}}],["12",{"_index":243,"title":{"13":{}},"name":{},"text":{"1":{},"6":{},"13":{},"17":{},"20":{}},"component":{}}],["120_506",{"_index":1403,"title":{},"name":{},"text":{"13":{}},"component":{}}],["13",{"_index":246,"title":{"14":{}},"name":{},"text":{"1":{},"14":{},"18":{},"19":{}},"component":{}}],["1384",{"_index":2358,"title":{},"name":{},"text":{"19":{}},"component":{}}],["14",{"_index":249,"title":{"15":{}},"name":{},"text":{"1":{},"15":{},"25":{}},"component":{}}],["143",{"_index":2355,"title":{},"name":{},"text":{"19":{}},"component":{}}],["14th",{"_index":3110,"title":{},"name":{},"text":{"25":{}},"component":{}}],["15",{"_index":252,"title":{"16":{}},"name":{},"text":{"1":{},"16":{},"18":{},"19":{}},"component":{}}],["150",{"_index":404,"title":{},"name":{},"text":{"3":{}},"component":{}}],["15561",{"_index":646,"title":{},"name":{},"text":{"5":{}},"component":{}}],["1588",{"_index":1628,"title":{},"name":{},"text":{"15":{}},"component":{}}],["16",{"_index":254,"title":{"17":{}},"name":{},"text":{"1":{},"4":{},"17":{}},"component":{}}],["16016",{"_index":2665,"title":{},"name":{},"text":{"21":{}},"component":{}}],["16157",{"_index":3098,"title":{},"name":{},"text":{"24":{}},"component":{}}],["1617",{"_index":1305,"title":{},"name":{},"text":{"12":{}},"component":{}}],["167_379",{"_index":1263,"title":{},"name":{},"text":{"11":{}},"component":{}}],["1681",{"_index":358,"title":{},"name":{},"text":{"2":{}},"component":{}}],["17",{"_index":257,"title":{"18":{}},"name":{},"text":{"1":{},"14":{},"18":{}},"component":{}}],["1704",{"_index":359,"title":{},"name":{},"text":{"2":{}},"component":{}}],["18",{"_index":260,"title":{"19":{}},"name":{},"text":{"1":{},"18":{},"19":{}},"component":{}}],["18144",{"_index":720,"title":{},"name":{},"text":{"6":{}},"component":{}}],["19",{"_index":262,"title":{"20":{}},"name":{},"text":{"1":{},"4":{},"13":{},"20":{}},"component":{}}],["1924",{"_index":644,"title":{},"name":{},"text":{"5":{}},"component":{}}],["198",{"_index":518,"title":{},"name":{},"text":{"4":{}},"component":{}}],["1:1",{"_index":1116,"title":{},"name":{},"text":{"9":{}},"component":{}}],["1\\pm\\sqrt{1+8x}}{2}&t\\ge",{"_index":2112,"title":{},"name":{},"text":{"18":{}},"component":{}}],["1\\times1\\times1",{"_index":2755,"title":{},"name":{},"text":{"23":{}},"component":{}}],["1_009_098",{"_index":1110,"title":{},"name":{},"text":{"9":{}},"component":{}}],["1_019_700",{"_index":1196,"title":{},"name":{},"text":{"10":{}},"component":{}}],["1_187_742_789_778_677",{"_index":2901,"title":{},"name":{},"text":{"23":{}},"component":{}}],["1_320_534_480",{"_index":407,"title":{},"name":{},"text":{"3":{}},"component":{}}],["1_459_206",{"_index":406,"title":{},"name":{},"text":{"3":{}},"component":{}}],["1_681_503_251_694",{"_index":786,"title":{},"name":{},"text":{"7":{}},"component":{}}],["1st",{"_index":3107,"title":{},"name":{},"text":{"25":{}},"component":{}}],["1usiz",{"_index":492,"title":{},"name":{},"text":{"4":{}},"component":{}}],["1’",{"_index":1739,"title":{},"name":{},"text":{"16":{}},"component":{}}],["2",{"_index":177,"title":{"3":{},"2-2":{},"3-3":{},"4-3":{},"5-3":{},"6-3":{},"7-2":{},"8-3":{},"9-3":{},"10-3":{},"11-3":{},"12-3":{},"13-2":{},"14-3":{},"15-2":{},"16-3":{},"17-3":{},"18-3":{},"19-3":{},"20-3":{},"21-2":{},"22-3":{},"23-2":{},"24-2":{},"25-2":{},"26-1":{}},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"8":{},"9":{},"10":{},"11":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{}},"component":{}}],["2*vi",{"_index":2030,"title":{},"name":{},"text":{"18":{}},"component":{}}],["2,2",{"_index":2330,"title":{},"name":{},"text":{"19":{}},"component":{}}],["2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5",{"_index":2346,"title":{},"name":{},"text":{"19":{}},"component":{}}],["2,9",{"_index":2349,"title":{},"name":{},"text":{"19":{}},"component":{}}],["2,[2,2]],[8,[8,1",{"_index":2348,"title":{},"name":{},"text":{"19":{}},"component":{}}],["2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6",{"_index":2345,"title":{},"name":{},"text":{"19":{}},"component":{}}],["20",{"_index":265,"title":{"21":{}},"name":{},"text":{"1":{},"18":{},"21":{}},"component":{}}],["2021",{"_index":6,"title":{"1":{}},"name":{},"text":{"1":{},"17":{}},"component":{}}],["21",{"_index":268,"title":{"22":{}},"name":{},"text":{"1":{},"18":{},"22":{}},"component":{}}],["22",{"_index":271,"title":{"23":{}},"name":{},"text":{"1":{},"18":{},"23":{}},"component":{}}],["226",{"_index":1400,"title":{},"name":{},"text":{"13":{}},"component":{}}],["23",{"_index":274,"title":{"24":{}},"name":{},"text":{"1":{},"17":{},"24":{}},"component":{}}],["230",{"_index":519,"title":{},"name":{},"text":{"4":{}},"component":{}}],["237",{"_index":1109,"title":{},"name":{},"text":{"9":{}},"component":{}}],["24",{"_index":276,"title":{"25":{}},"name":{},"text":{"1":{},"20":{},"25":{}},"component":{}}],["240",{"_index":1532,"title":{},"name":{},"text":{"15":{}},"component":{}}],["25",{"_index":280,"title":{"26":{}},"name":{},"text":{"1":{},"5":{},"18":{},"26":{}},"component":{}}],["25137",{"_index":1253,"title":{},"name":{},"text":{"11":{}},"component":{}}],["258",{"_index":1306,"title":{},"name":{},"text":{"12":{}},"component":{}}],["25’",{"_index":553,"title":{},"name":{},"text":{"5":{}},"component":{}}],["26",{"_index":2821,"title":{},"name":{},"text":{"23":{}},"component":{}}],["26_984_457_539",{"_index":784,"title":{},"name":{},"text":{"7":{}},"component":{}}],["27",{"_index":2072,"title":{},"name":{},"text":{"18":{}},"component":{}}],["28",{"_index":2073,"title":{},"name":{},"text":{"18":{}},"component":{}}],["2937",{"_index":1630,"title":{},"name":{},"text":{"15":{}},"component":{}}],["2].map(|_",{"_index":622,"title":{},"name":{},"text":{"5":{}},"component":{}}],["2].map(|i",{"_index":2526,"title":{},"name":{},"text":{"20":{}},"component":{}}],["2].map(|j",{"_index":2440,"title":{},"name":{},"text":{"20":{}},"component":{}}],["2_188_189_693_529",{"_index":1629,"title":{},"name":{},"text":{"15":{}},"component":{}}],["2_743_844",{"_index":520,"title":{},"name":{},"text":{"4":{}},"component":{}}],["2_776_842_859",{"_index":1264,"title":{},"name":{},"text":{"11":{}},"component":{}}],["2d",{"_index":1119,"title":{},"name":{},"text":{"10":{},"21":{}},"component":{}}],["2nd",{"_index":3108,"title":{},"name":{},"text":{"25":{}},"component":{}}],["2u32.pow(u32::try_from(n_cols).unwrap",{"_index":482,"title":{},"name":{},"text":{"4":{}},"component":{}}],["2u32.pow(u32::try_from(pow2).unwrap",{"_index":204,"title":{},"name":{},"text":{"1":{}},"component":{}}],["2u64.pow(u32::try_from(pow2).unwrap",{"_index":211,"title":{},"name":{},"text":{"1":{}},"component":{}}],["2v_y+1",{"_index":2125,"title":{},"name":{},"text":{"18":{}},"component":{}}],["2v_y+1)^2",{"_index":2122,"title":{},"name":{},"text":{"18":{}},"component":{}}],["2v_y+1=\\frac{1}{2}(k_1+k_2",{"_index":2131,"title":{},"name":{},"text":{"18":{}},"component":{}}],["3",{"_index":217,"title":{"4":{}},"name":{},"text":{"1":{},"2":{},"4":{},"5":{},"6":{},"9":{},"11":{},"17":{},"18":{},"19":{},"20":{},"22":{},"23":{},"24":{}},"component":{}}],["3).unwrap",{"_index":350,"title":{},"name":{},"text":{"2":{}},"component":{}}],["3,3",{"_index":2331,"title":{},"name":{},"text":{"19":{}},"component":{}}],["3,[2,[1,[7,3]]]],[6,[5,[4,[3,2",{"_index":2322,"title":{},"name":{},"text":{"19":{}},"component":{}}],["3,[2,[8,0]]],[9,[5,[4,[3,2",{"_index":2323,"title":{},"name":{},"text":{"19":{}},"component":{}}],["3040",{"_index":1736,"title":{},"name":{},"text":{"16":{}},"component":{}}],["31",{"_index":1928,"title":{},"name":{},"text":{"17":{}},"component":{}}],["315",{"_index":1734,"title":{},"name":{},"text":{"16":{}},"component":{}}],["328_187",{"_index":832,"title":{},"name":{},"text":{"8":{}},"component":{}}],["3509",{"_index":1401,"title":{},"name":{},"text":{"13":{}},"component":{}}],["36",{"_index":1396,"title":{},"name":{},"text":{"13":{}},"component":{}}],["372_984",{"_index":785,"title":{},"name":{},"text":{"7":{}},"component":{}}],["3738",{"_index":1402,"title":{},"name":{},"text":{"13":{}},"component":{}}],["385",{"_index":2590,"title":{},"name":{},"text":{"20":{}},"component":{}}],["3].map(|_",{"_index":2562,"title":{},"name":{},"text":{"20":{}},"component":{}}],["3].zip([3",{"_index":3052,"title":{},"name":{},"text":{"24":{}},"component":{}}],["3^3=27",{"_index":2680,"title":{},"name":{},"text":{"22":{}},"component":{}}],["3_390_034_818_249",{"_index":1631,"title":{},"name":{},"text":{"15":{}},"component":{}}],["3d",{"_index":2378,"title":{},"name":{},"text":{"20":{},"23":{}},"component":{}}],["3rd",{"_index":3109,"title":{},"name":{},"text":{"25":{}},"component":{}}],["4",{"_index":220,"title":{"5":{}},"name":{},"text":{"1":{},"4":{},"5":{},"9":{},"10":{},"11":{},"17":{},"18":{},"19":{},"24":{},"25":{}},"component":{}}],["4,2],2],6],[8,7",{"_index":2352,"title":{},"name":{},"text":{"19":{}},"component":{}}],["4,4",{"_index":2334,"title":{},"name":{},"text":{"19":{}},"component":{}}],["4,4]\"]).reduc",{"_index":2332,"title":{},"name":{},"text":{"19":{}},"component":{}}],["40",{"_index":1530,"title":{},"name":{},"text":{"15":{},"16":{}},"component":{}}],["43481",{"_index":3101,"title":{},"name":{},"text":{"24":{}},"component":{}}],["445",{"_index":2360,"title":{},"name":{},"text":{"19":{}},"component":{}}],["4512",{"_index":643,"title":{},"name":{},"text":{"5":{}},"component":{}}],["45^\\circ",{"_index":731,"title":{},"name":{},"text":{"6":{}},"component":{}}],["4].map(|i",{"_index":687,"title":{},"name":{},"text":{"6":{},"18":{}},"component":{}}],["5",{"_index":222,"title":{"6":{}},"name":{},"text":{"1":{},"2":{},"6":{},"9":{},"11":{},"16":{},"17":{},"18":{},"19":{},"24":{}},"component":{}}],["5,5",{"_index":2335,"title":{},"name":{},"text":{"19":{}},"component":{}}],["5,[7,4]],7],1",{"_index":2351,"title":{},"name":{},"text":{"19":{}},"component":{}}],["50",{"_index":2676,"title":{},"name":{},"text":{"22":{}},"component":{}}],["500×500",{"_index":1646,"title":{},"name":{},"text":{"16":{}},"component":{}}],["54",{"_index":1934,"title":{},"name":{},"text":{"17":{}},"component":{}}],["5432",{"_index":2664,"title":{},"name":{},"text":{"21":{}},"component":{}}],["557",{"_index":3247,"title":{},"name":{},"text":{"26":{}},"component":{}}],["5576",{"_index":719,"title":{},"name":{},"text":{"6":{}},"component":{}}],["57",{"_index":1251,"title":{},"name":{},"text":{"11":{}},"component":{}}],["575",{"_index":1195,"title":{},"name":{},"text":{"10":{}},"component":{}}],["5934",{"_index":783,"title":{},"name":{},"text":{"7":{}},"component":{}}],["6",{"_index":225,"title":{"7":{}},"name":{},"text":{"1":{},"7":{},"9":{},"17":{},"18":{},"19":{}},"component":{}}],["6,6",{"_index":2339,"title":{},"name":{},"text":{"19":{}},"component":{}}],["6,[5,[4,[3,2]]]],1",{"_index":2317,"title":{},"name":{},"text":{"19":{}},"component":{}}],["6,[5,[7,0]]],3",{"_index":2321,"title":{},"name":{},"text":{"19":{}},"component":{}}],["607_657",{"_index":2900,"title":{},"name":{},"text":{"23":{}},"component":{}}],["6_677_951",{"_index":521,"title":{},"name":{},"text":{"4":{}},"component":{}}],["7",{"_index":227,"title":{"8":{}},"name":{},"text":{"1":{},"2":{},"8":{},"9":{},"17":{},"18":{},"19":{},"22":{},"24":{}},"component":{}}],["7,[5,[[3,8],[1,4",{"_index":2347,"title":{},"name":{},"text":{"19":{}},"component":{}}],["7,[6,[5,[4,[3,2",{"_index":2313,"title":{},"name":{},"text":{"19":{}},"component":{}}],["7,[6,[5,[7,0",{"_index":2316,"title":{},"name":{},"text":{"19":{}},"component":{}}],["7,[[[3,7],[4,3]],[[6,3],[8,8",{"_index":2344,"title":{},"name":{},"text":{"19":{}},"component":{}}],["712_381_680_443_927",{"_index":2754,"title":{},"name":{},"text":{"22":{}},"component":{}}],["72",{"_index":3113,"title":{},"name":{},"text":{"25":{}},"component":{}}],["739",{"_index":1735,"title":{},"name":{},"text":{"16":{}},"component":{}}],["757_770",{"_index":2753,"title":{},"name":{},"text":{"22":{}},"component":{}}],["790",{"_index":1500,"title":{},"name":{},"text":{"14":{}},"component":{}}],["7sd",{"_index":885,"title":{},"name":{},"text":{"9":{}},"component":{}}],["8",{"_index":230,"title":{"9":{}},"name":{},"text":{"1":{},"4":{},"7":{},"9":{},"18":{},"19":{},"25":{}},"component":{}}],["8*i",{"_index":2032,"title":{},"name":{},"text":{"18":{}},"component":{}}],["87456",{"_index":645,"title":{},"name":{},"text":{"5":{}},"component":{}}],["8].contains(n",{"_index":1104,"title":{},"name":{},"text":{"9":{}},"component":{}}],["8y",{"_index":2036,"title":{},"name":{},"text":{"18":{}},"component":{}}],["8y=(m",{"_index":2127,"title":{},"name":{},"text":{"18":{}},"component":{}}],["8y}\\right",{"_index":2120,"title":{},"name":{},"text":{"18":{}},"component":{}}],["9",{"_index":234,"title":{"10":{}},"name":{},"text":{"1":{},"7":{},"9":{},"10":{},"16":{},"17":{},"18":{},"20":{},"22":{},"24":{},"25":{}},"component":{}}],["9).then_some(idx",{"_index":1174,"title":{},"name":{},"text":{"10":{}},"component":{}}],["9,8],1],2],3],4",{"_index":2308,"title":{},"name":{},"text":{"19":{}},"component":{}}],["900",{"_index":405,"title":{},"name":{},"text":{"3":{}},"component":{}}],["91_257_582",{"_index":833,"title":{},"name":{},"text":{"8":{}},"component":{}}],["927",{"_index":1930,"title":{},"name":{},"text":{"17":{}},"component":{}}],["94992992796199\".to_own",{"_index":3213,"title":{},"name":{},"text":{"25":{}},"component":{}}],["9])).unwrap",{"_index":2628,"title":{},"name":{},"text":{"21":{}},"component":{}}],["9_usize]).map(|(i",{"_index":3053,"title":{},"name":{},"text":{"24":{}},"component":{}}],["9s",{"_index":1128,"title":{},"name":{},"text":{"10":{}},"component":{}}],["_",{"_index":380,"title":{},"name":{},"text":{"3":{},"7":{},"9":{},"10":{},"11":{},"12":{},"14":{},"15":{},"16":{},"17":{},"19":{},"21":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["_bin_op(self",{"_index":975,"title":{},"name":{},"text":{"9":{}},"component":{}}],["_po",{"_index":2003,"title":{},"name":{},"text":{"18":{}},"component":{}}],["_t",{"_index":2002,"title":{},"name":{},"text":{"18":{}},"component":{}}],["aaaa",{"_index":890,"title":{},"name":{},"text":{"9":{}},"component":{}}],["ab",{"_index":942,"title":{},"name":{},"text":{"9":{}},"component":{}}],["abc",{"_index":1052,"title":{},"name":{},"text":{"9":{}},"component":{}}],["abcd",{"_index":950,"title":{},"name":{},"text":{"9":{}},"component":{}}],["abd",{"_index":941,"title":{},"name":{},"text":{"9":{}},"component":{}}],["abdfg",{"_index":920,"title":{},"name":{},"text":{"9":{}},"component":{}}],["abov",{"_index":552,"title":{},"name":{},"text":{"5":{},"17":{},"18":{},"19":{},"25":{}},"component":{}}],["abs_diff(a",{"_index":212,"title":{},"name":{},"text":{"1":{}},"component":{}}],["abs_diff(col",{"_index":3082,"title":{},"name":{},"text":{"24":{}},"component":{}}],["abs_diff(n",{"_index":818,"title":{},"name":{},"text":{"8":{}},"component":{}}],["abs_eight_i",{"_index":2039,"title":{},"name":{},"text":{"18":{}},"component":{}}],["absolut",{"_index":834,"title":{},"name":{},"text":{"8":{}},"component":{}}],["abut",{"_index":2822,"title":{},"name":{},"text":{"23":{}},"component":{}}],["ac",{"_index":954,"title":{},"name":{},"text":{"9":{}},"component":{}}],["accept",{"_index":3104,"title":{},"name":{},"text":{"25":{}},"component":{}}],["accord",{"_index":1754,"title":{},"name":{},"text":{"17":{},"19":{}},"component":{}}],["accum",{"_index":2891,"title":{},"name":{},"text":{"23":{}},"component":{}}],["acdeg",{"_index":918,"title":{},"name":{},"text":{"9":{}},"component":{}}],["acdfg",{"_index":919,"title":{},"name":{},"text":{"9":{}},"component":{}}],["acf",{"_index":943,"title":{},"name":{},"text":{"9":{}},"component":{}}],["achiev",{"_index":1947,"title":{},"name":{},"text":{"17":{},"18":{},"24":{}},"component":{}}],["action",{"_index":2295,"title":{},"name":{},"text":{"19":{}},"component":{}}],["action(&mut",{"_index":2300,"title":{},"name":{},"text":{"19":{}},"component":{}}],["actual",{"_index":23,"title":{},"name":{},"text":{"1":{},"5":{},"7":{},"13":{},"14":{},"15":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{}},"component":{}}],["ad",{"_index":1858,"title":{},"name":{},"text":{"17":{},"19":{},"22":{},"23":{}},"component":{}}],["add",{"_index":756,"title":{},"name":{},"text":{"7":{},"15":{},"17":{},"19":{},"20":{},"25":{}},"component":{}}],["add(&self",{"_index":2237,"title":{},"name":{},"text":{"19":{}},"component":{}}],["addend",{"_index":2162,"title":{},"name":{},"text":{"19":{}},"component":{}}],["addends.last_mut().unwrap",{"_index":2169,"title":{},"name":{},"text":{"19":{}},"component":{}}],["addends.push(elem",{"_index":2171,"title":{},"name":{},"text":{"19":{}},"component":{}}],["addit",{"_index":1407,"title":{},"name":{},"text":{"13":{},"19":{},"23":{},"24":{}},"component":{}}],["addition",{"_index":2393,"title":{},"name":{},"text":{"20":{}},"component":{}}],["adjac",{"_index":1330,"title":{},"name":{},"text":{"13":{},"15":{},"21":{}},"component":{}}],["adjoin",{"_index":2386,"title":{},"name":{},"text":{"20":{}},"component":{}}],["advanc",{"_index":1788,"title":{},"name":{},"text":{"17":{}},"component":{}}],["advent",{"_index":4,"title":{"1":{}},"name":{},"text":{"1":{},"5":{},"15":{}},"component":{}}],["af",{"_index":955,"title":{},"name":{},"text":{"9":{}},"component":{}}],["affect",{"_index":1975,"title":{},"name":{},"text":{"18":{}},"component":{}}],["again",{"_index":1281,"title":{},"name":{},"text":{"12":{}},"component":{}}],["against",{"_index":320,"title":{},"name":{},"text":{"2":{}},"component":{}}],["agent",{"_index":2907,"title":{},"name":{},"text":{"24":{}},"component":{}}],["agre",{"_index":2394,"title":{},"name":{},"text":{"20":{}},"component":{}}],["aim",{"_index":402,"title":{},"name":{},"text":{"3":{},"8":{}},"component":{}}],["akin",{"_index":1945,"title":{},"name":{},"text":{"17":{}},"component":{}}],["algo",{"_index":2611,"title":{},"name":{},"text":{"21":{}},"component":{}}],["algorithm",{"_index":288,"title":{},"name":{},"text":{"1":{},"9":{},"12":{},"16":{},"17":{},"24":{}},"component":{}}],["all(|(am",{"_index":3043,"title":{},"name":{},"text":{"24":{}},"component":{}}],["all_count",{"_index":714,"title":{},"name":{},"text":{"6":{}},"component":{}}],["all_next_z",{"_index":3172,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_next_zs[0",{"_index":3177,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_prev_z",{"_index":3171,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_prev_zs[all_prev_zs.len",{"_index":3175,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_valid_zs_rtl",{"_index":3186,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_valid_zs_rtl.iter_mut().enumerate().rev",{"_index":3189,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_zs_ltr",{"_index":3166,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_zs_ltr.first_mut().unwrap().insert(0",{"_index":3168,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_zs_ltr.split_at_mut(digit_idx",{"_index":3173,"title":{},"name":{},"text":{"25":{}},"component":{}}],["all_zs_ltr[digit_idx",{"_index":3192,"title":{},"name":{},"text":{"25":{}},"component":{}}],["allamphipodst",{"_index":3024,"title":{},"name":{},"text":{"24":{}},"component":{}}],["alloc",{"_index":2938,"title":{},"name":{},"text":{"24":{}},"component":{}}],["allow",{"_index":111,"title":{},"name":{},"text":{"1":{}},"component":{}}],["allow(clippy::range_minus_on",{"_index":3074,"title":{},"name":{},"text":{"24":{}},"component":{}}],["allow(dead_cod",{"_index":180,"title":{},"name":{},"text":{"1":{}},"component":{}}],["along",{"_index":2824,"title":{},"name":{},"text":{"23":{}},"component":{}}],["alreadi",{"_index":735,"title":{},"name":{},"text":{"6":{},"12":{},"13":{},"24":{}},"component":{}}],["already_won",{"_index":638,"title":{},"name":{},"text":{"5":{}},"component":{}}],["although",{"_index":916,"title":{},"name":{},"text":{"9":{},"18":{}},"component":{}}],["altogeth",{"_index":2142,"title":{},"name":{},"text":{"18":{},"20":{}},"component":{}}],["alu",{"_index":3129,"title":{},"name":{},"text":{"25":{}},"component":{}}],["alu.run_block(block",{"_index":3140,"title":{},"name":{},"text":{"25":{}},"component":{}}],["alu::from_running_block_on(block",{"_index":3180,"title":{},"name":{},"text":{"25":{}},"component":{}}],["alu::new",{"_index":3138,"title":{},"name":{},"text":{"25":{}},"component":{}}],["alu[register::z",{"_index":3181,"title":{},"name":{},"text":{"25":{}},"component":{}}],["alway",{"_index":2407,"title":{},"name":{},"text":{"20":{}},"component":{}}],["am.index",{"_index":2968,"title":{},"name":{},"text":{"24":{}},"component":{}}],["am.kind",{"_index":2967,"title":{},"name":{},"text":{"24":{}},"component":{}}],["am.kind.dest_col",{"_index":3063,"title":{},"name":{},"text":{"24":{}},"component":{}}],["am.kind.energi",{"_index":3086,"title":{},"name":{},"text":{"24":{}},"component":{}}],["am.kind.to_char",{"_index":3010,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amount",{"_index":1131,"title":{},"name":{},"text":{"10":{},"16":{},"17":{}},"component":{}}],["amphipod",{"_index":275,"title":{"24":{}},"name":{},"text":{"1":{},"24":{}},"component":{}}],["amphipod_kind",{"_index":2987,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipod_kind_count",{"_index":2984,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipod_kind_counts[amphipod_kind",{"_index":2990,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipod_loc",{"_index":2981,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipod_locs.contains_key(&[row",{"_index":3073,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipod_locs.contains_key(&new_loc",{"_index":3076,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipod_locs_map",{"_index":2983,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipod_locs_map.insert",{"_index":2989,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipod_locs_map.len",{"_index":3002,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipodindex",{"_index":2962,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipodindexed([t",{"_index":2961,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipodindexed(amphipod_locs.0.map(|st",{"_index":3088,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipodindexed(initial_locs.0.map(|loc",{"_index":3036,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipodkind",{"_index":2954,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipodkind::from_char(c",{"_index":2988,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipodkind::from_usize(i",{"_index":2971,"title":{},"name":{},"text":{"24":{}},"component":{}}],["amphipodkind::n_kind",{"_index":2964,"title":{},"name":{},"text":{"24":{}},"component":{}}],["an",{"_index":185,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["ancestor",{"_index":1784,"title":{},"name":{},"text":{"17":{}},"component":{}}],["and(&column",{"_index":504,"title":{},"name":{},"text":{"4":{}},"component":{}}],["and(&n_zero",{"_index":474,"title":{},"name":{},"text":{"4":{}},"component":{}}],["and_modify(|v",{"_index":1385,"title":{},"name":{},"text":{"13":{}},"component":{}}],["angl",{"_index":1213,"title":{},"name":{},"text":{"11":{}},"component":{}}],["anoth",{"_index":2398,"title":{},"name":{},"text":{"20":{},"23":{},"24":{}},"component":{}}],["ans.add(&snailnumowned::from_line(line.as_ref",{"_index":2178,"title":{},"name":{},"text":{"19":{}},"component":{}}],["ans.entry((c1",{"_index":1593,"title":{},"name":{},"text":{"15":{}},"component":{}}],["ans.reduc",{"_index":2241,"title":{},"name":{},"text":{"19":{}},"component":{}}],["ans.to_str",{"_index":1497,"title":{},"name":{},"text":{"14":{}},"component":{}}],["ans_for_input(include_str!(\"input.txt",{"_index":343,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"25":{},"26":{}},"component":{}}],["ans_for_input(include_str!(\"sample_input.txt",{"_index":777,"title":{},"name":{},"text":{"7":{}},"component":{}}],["ans_for_input(input",{"_index":340,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"17":{},"19":{},"20":{},"21":{},"22":{},"23":{},"25":{},"26":{}},"component":{}}],["answer",{"_index":25,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["any_cucumbers_did_mov",{"_index":3227,"title":{},"name":{},"text":{"26":{}},"component":{}}],["anymor",{"_index":1269,"title":{},"name":{},"text":{"12":{},"18":{}},"component":{}}],["anyth",{"_index":362,"title":{},"name":{},"text":{"3":{}},"component":{}}],["apex",{"_index":2146,"title":{},"name":{},"text":{"18":{}},"component":{}}],["appear",{"_index":1545,"title":{},"name":{},"text":{"15":{},"19":{}},"component":{}}],["appli",{"_index":1952,"title":{},"name":{},"text":{"17":{},"20":{},"21":{}},"component":{}}],["apply(&self",{"_index":1893,"title":{},"name":{},"text":{"17":{},"20":{}},"component":{}}],["apply(self",{"_index":2477,"title":{},"name":{},"text":{"20":{}},"component":{}}],["apply_mapping_to_garbled_digit(&map",{"_index":1090,"title":{},"name":{},"text":{"9":{}},"component":{}}],["apply_mapping_to_garbled_digit(map",{"_index":1070,"title":{},"name":{},"text":{"9":{}},"component":{}}],["apply_n_times(&self",{"_index":1595,"title":{},"name":{},"text":{"15":{}},"component":{}}],["apply_step(&mut",{"_index":2874,"title":{},"name":{},"text":{"23":{}},"component":{}}],["approxim",{"_index":1525,"title":{},"name":{},"text":{"15":{}},"component":{}}],["arbitrari",{"_index":3112,"title":{},"name":{},"text":{"25":{}},"component":{}}],["arbitrarili",{"_index":1328,"title":{},"name":{},"text":{"13":{},"24":{}},"component":{}}],["area",{"_index":1985,"title":{},"name":{},"text":{"18":{},"21":{}},"component":{}}],["area:\\s*x=([\\d",{"_index":2005,"title":{},"name":{},"text":{"18":{}},"component":{}}],["aren’t",{"_index":1268,"title":{},"name":{},"text":{"12":{}},"component":{}}],["arg",{"_index":1905,"title":{},"name":{},"text":{"17":{}},"component":{}}],["arg_stack",{"_index":1906,"title":{},"name":{},"text":{"17":{}},"component":{}}],["arg_stack.pop",{"_index":1913,"title":{},"name":{},"text":{"17":{}},"component":{}}],["arg_stack.push(arg",{"_index":1910,"title":{},"name":{},"text":{"17":{}},"component":{}}],["argument",{"_index":1414,"title":{},"name":{},"text":{"13":{}},"component":{}}],["aris",{"_index":48,"title":{},"name":{},"text":{"1":{}},"component":{}}],["arithmet",{"_index":277,"title":{"25":{}},"name":{},"text":{"1":{},"8":{}},"component":{}}],["aros",{"_index":1564,"title":{},"name":{},"text":{"15":{}},"component":{}}],["around",{"_index":1533,"title":{},"name":{},"text":{"15":{},"22":{}},"component":{}}],["arr",{"_index":1135,"title":{},"name":{},"text":{"10":{},"12":{},"24":{}},"component":{}}],["arr[am.kind",{"_index":3050,"title":{},"name":{},"text":{"24":{}},"component":{}}],["arr[idx",{"_index":1286,"title":{},"name":{},"text":{"12":{}},"component":{}}],["arrang",{"_index":1507,"title":{},"name":{},"text":{"14":{}},"component":{}}],["array",{"_index":412,"title":{},"name":{},"text":{"4":{},"7":{},"12":{},"13":{},"16":{},"21":{},"24":{},"26":{}},"component":{}}],["array1::::from_shape_simple_fn((n_row",{"_index":488,"title":{},"name":{},"text":{"4":{}},"component":{}}],["array2",{"_index":465,"title":{},"name":{},"text":{"4":{},"10":{},"12":{},"16":{},"21":{},"24":{}},"component":{}}],["array2::from_shape_fn((height",{"_index":2993,"title":{},"name":{},"text":{"24":{}},"component":{}}],["array2::from_shape_fn((self.mat.nrow",{"_index":2631,"title":{},"name":{},"text":{"21":{}},"component":{}}],["array2::from_shape_simple_fn((k",{"_index":1713,"title":{},"name":{},"text":{"16":{}},"component":{}}],["array2::from_shape_simple_fn(grown_mat.dim",{"_index":2635,"title":{},"name":{},"text":{"21":{}},"component":{}}],["array2::from_shape_vec((n_lin",{"_index":459,"title":{},"name":{},"text":{"4":{}},"component":{}}],["array2::from_shape_vec((n_row",{"_index":1679,"title":{},"name":{},"text":{"16":{},"21":{}},"component":{}}],["array2::from_shape_vec((width",{"_index":1147,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["arriv",{"_index":1576,"title":{},"name":{},"text":{"15":{}},"component":{}}],["as_packets(&self",{"_index":1804,"title":{},"name":{},"text":{"17":{}},"component":{}}],["as_pair",{"_index":2228,"title":{},"name":{},"text":{"19":{}},"component":{}}],["as_pair(&self",{"_index":2244,"title":{},"name":{},"text":{"19":{}},"component":{}}],["as_ref",{"_index":197,"title":{},"name":{},"text":{"1":{},"19":{}},"component":{}}],["ascend",{"_index":667,"title":{},"name":{},"text":{"6":{}},"component":{}}],["ascent",{"_index":2054,"title":{},"name":{},"text":{"18":{}},"component":{}}],["ask",{"_index":296,"title":{},"name":{},"text":{"2":{},"5":{},"6":{},"8":{},"9":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"25":{}},"component":{}}],["asref",{"_index":2536,"title":{},"name":{},"text":{"20":{},"25":{}},"component":{}}],["assert",{"_index":2586,"title":{},"name":{},"text":{"20":{},"25":{}},"component":{}}],["assert_eq",{"_index":2074,"title":{},"name":{},"text":{"18":{},"19":{}},"component":{}}],["assert_eq!(ans_for_input($input",{"_index":188,"title":{},"name":{},"text":{"1":{}},"component":{}}],["assert_eq!(n_row",{"_index":586,"title":{},"name":{},"text":{"5":{},"16":{},"21":{}},"component":{}}],["assert_eq!(pt1",{"_index":3097,"title":{},"name":{},"text":{"24":{}},"component":{}}],["assert_eq!(pt1($input",{"_index":190,"title":{},"name":{},"text":{"1":{}},"component":{}}],["assert_eq!(pt1(&pap",{"_index":1499,"title":{},"name":{},"text":{"14":{}},"component":{}}],["assert_eq!(pt1(&snailnumowned::from_line(\"[[1,2],[[3,4],5",{"_index":2354,"title":{},"name":{},"text":{"19":{}},"component":{}}],["assert_eq!(pt2",{"_index":3100,"title":{},"name":{},"text":{"24":{}},"component":{}}],["assert_eq!(pt2($input",{"_index":191,"title":{},"name":{},"text":{"1":{}},"component":{}}],["assert_eq!(result",{"_index":2299,"title":{},"name":{},"text":{"19":{}},"component":{}}],["assert_eq!(snail_num",{"_index":2301,"title":{},"name":{},"text":{"19":{}},"component":{}}],["assert_ne!(elems.len",{"_index":2246,"title":{},"name":{},"text":{"19":{}},"component":{}}],["assert_ne!(i",{"_index":2027,"title":{},"name":{},"text":{"18":{}},"component":{}}],["assign",{"_index":1539,"title":{},"name":{},"text":{"15":{},"24":{}},"component":{}}],["associ",{"_index":850,"title":{},"name":{},"text":{"8":{},"19":{},"24":{}},"component":{}}],["assum",{"_index":9,"title":{},"name":{},"text":{"1":{}},"component":{}}],["astut",{"_index":2137,"title":{},"name":{},"text":{"18":{}},"component":{}}],["atom",{"_index":2369,"title":{},"name":{},"text":{"19":{},"24":{}},"component":{}}],["attempt",{"_index":902,"title":{},"name":{},"text":{"9":{},"15":{},"22":{}},"component":{}}],["attempted_digit_range_ctor",{"_index":3196,"title":{},"name":{},"text":{"25":{}},"component":{}}],["author",{"_index":2395,"title":{},"name":{},"text":{"20":{}},"component":{}}],["avail",{"_index":1348,"title":{},"name":{},"text":{"13":{}},"component":{}}],["away",{"_index":742,"title":{},"name":{},"text":{"6":{},"8":{}},"component":{}}],["awesom",{"_index":2113,"title":{},"name":{},"text":{"18":{}},"component":{}}],["axi",{"_index":2401,"title":{},"name":{},"text":{"20":{},"23":{}},"component":{}}],["axis::it",{"_index":2517,"title":{},"name":{},"text":{"20":{}},"component":{}}],["a–g",{"_index":889,"title":{},"name":{},"text":{"9":{}},"component":{}}],["b",{"_index":206,"title":{},"name":{},"text":{"1":{},"6":{},"9":{},"13":{},"17":{},"23":{},"24":{}},"component":{}}],["b'1",{"_index":456,"title":{},"name":{},"text":{"4":{}},"component":{}}],["b'a",{"_index":972,"title":{},"name":{},"text":{"9":{}},"component":{}}],["b).count",{"_index":970,"title":{},"name":{},"text":{"9":{}},"component":{}}],["b.as_packet",{"_index":1876,"title":{},"name":{},"text":{"17":{}},"component":{}}],["b.burrow.solve(&b.amphipod_locs).0",{"_index":3094,"title":{},"name":{},"text":{"24":{}},"component":{}}],["b_1",{"_index":2766,"title":{},"name":{},"text":{"23":{}},"component":{}}],["b_1,\\ldots,b_n",{"_index":2762,"title":{},"name":{},"text":{"23":{}},"component":{}}],["b_1\\cap",{"_index":2768,"title":{},"name":{},"text":{"23":{}},"component":{}}],["b_2",{"_index":2765,"title":{},"name":{},"text":{"23":{}},"component":{}}],["b_3",{"_index":2769,"title":{},"name":{},"text":{"23":{}},"component":{}}],["b_3\\coloneqq",{"_index":2767,"title":{},"name":{},"text":{"23":{}},"component":{}}],["b_{n+1",{"_index":2763,"title":{},"name":{},"text":{"23":{}},"component":{}}],["back",{"_index":1333,"title":{},"name":{},"text":{"13":{},"17":{},"20":{},"24":{}},"component":{}}],["backtrack",{"_index":2389,"title":{},"name":{},"text":{"20":{}},"component":{}}],["base",{"_index":2672,"title":{},"name":{},"text":{"22":{}},"component":{}}],["base_col",{"_index":1291,"title":{},"name":{},"text":{"12":{}},"component":{}}],["base_depth",{"_index":2227,"title":{},"name":{},"text":{"19":{}},"component":{}}],["base_row",{"_index":1290,"title":{},"name":{},"text":{"12":{}},"component":{}}],["base_row.checked_sub(1",{"_index":1293,"title":{},"name":{},"text":{"12":{}},"component":{}}],["basi",{"_index":2412,"title":{},"name":{},"text":{"20":{}},"component":{}}],["basic",{"_index":1197,"title":{},"name":{},"text":{"11":{}},"component":{}}],["basin",{"_index":236,"title":{"10":{}},"name":{},"text":{"1":{}},"component":{}}],["basin_s",{"_index":1170,"title":{},"name":{},"text":{"10":{}},"component":{}}],["basin_sizes(&self",{"_index":1169,"title":{},"name":{},"text":{"10":{}},"component":{}}],["basin_sizes.into_iter().take(3).product",{"_index":1194,"title":{},"name":{},"text":{"10":{}},"component":{}}],["basin_sizes.push(visited_idxs.len",{"_index":1189,"title":{},"name":{},"text":{"10":{}},"component":{}}],["basin_sizes.sort_unstable_by_key(|&s",{"_index":1192,"title":{},"name":{},"text":{"10":{}},"component":{}}],["bc",{"_index":1050,"title":{},"name":{},"text":{"9":{}},"component":{}}],["be",{"_index":52,"title":{},"name":{},"text":{"1":{},"12":{},"16":{},"18":{},"19":{}},"component":{}}],["beacon",{"_index":263,"title":{"20":{}},"name":{},"text":{"1":{},"20":{}},"component":{}}],["becom",{"_index":2604,"title":{},"name":{},"text":{"21":{},"23":{}},"component":{}}],["befor",{"_index":2294,"title":{},"name":{},"text":{"19":{},"23":{}},"component":{}}],["begin",{"_index":1787,"title":{},"name":{},"text":{"17":{}},"component":{}}],["begin{align",{"_index":2088,"title":{},"name":{},"text":{"18":{}},"component":{}}],["begin{cas",{"_index":2089,"title":{},"name":{},"text":{"18":{}},"component":{}}],["behavior",{"_index":1412,"title":{},"name":{},"text":{"13":{}},"component":{}}],["believ",{"_index":1565,"title":{},"name":{},"text":{"15":{}},"component":{}}],["belong",{"_index":722,"title":{},"name":{},"text":{"6":{}},"component":{}}],["below",{"_index":32,"title":{},"name":{},"text":{"1":{},"5":{},"13":{},"18":{},"20":{}},"component":{}}],["best",{"_index":844,"title":{},"name":{},"text":{"8":{}},"component":{}}],["between",{"_index":654,"title":{},"name":{},"text":{"6":{},"9":{},"10":{},"13":{},"15":{},"18":{},"20":{},"23":{},"24":{}},"component":{}}],["big",{"_index":1325,"title":{},"name":{},"text":{"13":{}},"component":{}}],["bin_bit",{"_index":1835,"title":{},"name":{},"text":{"17":{}},"component":{}}],["bin_bits.extend_from_slice(&chunk[1",{"_index":1839,"title":{},"name":{},"text":{"17":{}},"component":{}}],["binari",{"_index":218,"title":{"4":{}},"name":{},"text":{"1":{},"4":{},"17":{},"19":{},"21":{}},"component":{}}],["binary(vec",{"_index":1796,"title":{},"name":{},"text":{"17":{}},"component":{}}],["binary::as_packet",{"_index":1767,"title":{},"name":{},"text":{"17":{}},"component":{}}],["binary::from_hex(input).unwrap",{"_index":1875,"title":{},"name":{},"text":{"17":{}},"component":{}}],["binary_digits_msbf",{"_index":196,"title":{},"name":{},"text":{"1":{}},"component":{}}],["bingo",{"_index":86,"title":{},"name":{},"text":{"1":{},"5":{}},"component":{}}],["bit",{"_index":1778,"title":{},"name":{},"text":{"17":{},"18":{},"21":{}},"component":{}}],["bit_vec",{"_index":446,"title":{},"name":{},"text":{"4":{}},"component":{}}],["bit_vec).ok",{"_index":460,"title":{},"name":{},"text":{"4":{}},"component":{}}],["bit_vec.len",{"_index":458,"title":{},"name":{},"text":{"4":{}},"component":{}}],["bit_vec.push(c",{"_index":455,"title":{},"name":{},"text":{"4":{}},"component":{}}],["bitand(self",{"_index":985,"title":{},"name":{},"text":{"9":{}},"component":{}}],["bitor(self",{"_index":981,"title":{},"name":{},"text":{"9":{}},"component":{}}],["bitwis",{"_index":1046,"title":{},"name":{},"text":{"9":{}},"component":{}}],["bitwise_not",{"_index":1015,"title":{},"name":{},"text":{"9":{}},"component":{}}],["block",{"_index":1491,"title":{},"name":{},"text":{"14":{},"25":{}},"component":{}}],["block.instr",{"_index":3133,"title":{},"name":{},"text":{"25":{}},"component":{}}],["blocks.as_ref",{"_index":3163,"title":{},"name":{},"text":{"25":{}},"component":{}}],["blocks.iter().enumer",{"_index":3170,"title":{},"name":{},"text":{"25":{}},"component":{}}],["blocks.len",{"_index":3165,"title":{},"name":{},"text":{"25":{}},"component":{}}],["blocks.push(instrblock",{"_index":3147,"title":{},"name":{},"text":{"25":{}},"component":{}}],["board",{"_index":525,"title":{},"name":{},"text":{"5":{},"22":{}},"component":{}}],["board.get_ans(num",{"_index":631,"title":{},"name":{},"text":{"5":{}},"component":{}}],["board.has_won",{"_index":630,"title":{},"name":{},"text":{"5":{}},"component":{}}],["board.play_number(num",{"_index":629,"title":{},"name":{},"text":{"5":{}},"component":{}}],["board.siz",{"_index":2696,"title":{},"name":{},"text":{"22":{}},"component":{}}],["board::new(this_board.as_slic",{"_index":611,"title":{},"name":{},"text":{"5":{}},"component":{}}],["board_idx",{"_index":636,"title":{},"name":{},"text":{"5":{}},"component":{}}],["boardprogress",{"_index":573,"title":{},"name":{},"text":{"5":{}},"component":{}}],["boardprogress::new(n_row",{"_index":592,"title":{},"name":{},"text":{"5":{}},"component":{}}],["boards.push(board",{"_index":613,"title":{},"name":{},"text":{"5":{}},"component":{}}],["board’",{"_index":536,"title":{},"name":{},"text":{"5":{}},"component":{}}],["bookkeep",{"_index":1132,"title":{},"name":{},"text":{"10":{},"17":{}},"component":{}}],["bool",{"_index":486,"title":{},"name":{},"text":{"4":{},"5":{},"9":{},"10":{},"13":{},"17":{},"19":{},"21":{},"22":{},"24":{},"25":{},"26":{}},"component":{}}],["boolean",{"_index":1413,"title":{},"name":{},"text":{"13":{}},"component":{}}],["boost",{"_index":2936,"title":{},"name":{},"text":{"24":{}},"component":{}}],["bore",{"_index":1742,"title":{},"name":{},"text":{"16":{}},"component":{}}],["borrowing(elem",{"_index":2226,"title":{},"name":{},"text":{"19":{}},"component":{}}],["both",{"_index":287,"title":{},"name":{},"text":{"1":{},"2":{},"8":{},"11":{},"19":{},"21":{},"24":{}},"component":{}}],["bother",{"_index":1568,"title":{},"name":{},"text":{"15":{}},"component":{}}],["bottom",{"_index":99,"title":{},"name":{},"text":{"1":{},"14":{},"16":{}},"component":{}}],["bounc",{"_index":1332,"title":{},"name":{},"text":{"13":{}},"component":{}}],["bound",{"_index":2871,"title":{},"name":{},"text":{"23":{}},"component":{}}],["boundari",{"_index":95,"title":{},"name":{},"text":{"1":{}},"component":{}}],["box",{"_index":2761,"title":{},"name":{},"text":{"23":{}},"component":{}}],["brace",{"_index":1200,"title":{},"name":{},"text":{"11":{}},"component":{}}],["break",{"_index":493,"title":{},"name":{},"text":{"4":{},"12":{},"17":{},"18":{},"19":{},"22":{},"23":{},"24":{}},"component":{}}],["bring",{"_index":2687,"title":{},"name":{},"text":{"22":{}},"component":{}}],["brutal",{"_index":1747,"title":{},"name":{},"text":{"17":{}},"component":{}}],["brute",{"_index":1957,"title":{},"name":{},"text":{"18":{}},"component":{}}],["btreemap",{"_index":963,"title":{},"name":{},"text":{"9":{},"16":{}},"component":{}}],["btreeset",{"_index":570,"title":{},"name":{},"text":{"5":{},"9":{},"20":{},"24":{},"25":{}},"component":{}}],["btreeset::new",{"_index":2516,"title":{},"name":{},"text":{"20":{},"24":{}},"component":{}}],["buffer",{"_index":325,"title":{},"name":{},"text":{"2":{}},"component":{}}],["bug",{"_index":1869,"title":{},"name":{},"text":{"17":{}},"component":{}}],["buggi",{"_index":1577,"title":{},"name":{},"text":{"15":{}},"component":{}}],["build",{"_index":1336,"title":{},"name":{},"text":{"13":{},"15":{}},"component":{}}],["burrow",{"_index":2980,"title":{},"name":{},"text":{"24":{}},"component":{}}],["by_adding_lines_in",{"_index":2174,"title":{},"name":{},"text":{"19":{}},"component":{}}],["by_ref",{"_index":1467,"title":{},"name":{},"text":{"14":{}},"component":{}}],["c",{"_index":453,"title":{},"name":{},"text":{"4":{},"5":{},"9":{},"10":{},"11":{},"12":{},"15":{},"16":{},"17":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"26":{}},"component":{}}],["c.is_ascii_lowercase()).all(|b",{"_index":1356,"title":{},"name":{},"text":{"13":{}},"component":{}}],["c.to_digit(10).and_then(|d",{"_index":1144,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["c.to_digit(10).unwrap",{"_index":2168,"title":{},"name":{},"text":{"19":{}},"component":{}}],["c.to_digit(16",{"_index":1800,"title":{},"name":{},"text":{"17":{}},"component":{}}],["c.x_rang",{"_index":2831,"title":{},"name":{},"text":{"23":{}},"component":{}}],["c.y_rang",{"_index":2838,"title":{},"name":{},"text":{"23":{}},"component":{}}],["c.z_rang",{"_index":2843,"title":{},"name":{},"text":{"23":{}},"component":{}}],["c1",{"_index":1536,"title":{},"name":{},"text":{"15":{},"23":{}},"component":{}}],["c1_multipli",{"_index":1615,"title":{},"name":{},"text":{"15":{}},"component":{}}],["c2",{"_index":1537,"title":{},"name":{},"text":{"15":{},"23":{}},"component":{}}],["c2.x_rang",{"_index":2837,"title":{},"name":{},"text":{"23":{}},"component":{}}],["c2.y_rang",{"_index":2828,"title":{},"name":{},"text":{"23":{}},"component":{}}],["c2.z_rang",{"_index":2829,"title":{},"name":{},"text":{"23":{}},"component":{}}],["c2_multipli",{"_index":1616,"title":{},"name":{},"text":{"15":{}},"component":{}}],["c3",{"_index":1538,"title":{},"name":{},"text":{"15":{}},"component":{}}],["c_is_digit",{"_index":2166,"title":{},"name":{},"text":{"19":{}},"component":{}}],["cach",{"_index":1716,"title":{},"name":{},"text":{"16":{},"19":{}},"component":{}}],["call",{"_index":1349,"title":{},"name":{},"text":{"13":{},"16":{}},"component":{}}],["can_continu",{"_index":3200,"title":{},"name":{},"text":{"25":{}},"component":{}}],["can_visit_one_small_cave_twic",{"_index":1373,"title":{},"name":{},"text":{"13":{}},"component":{}}],["candid",{"_index":487,"title":{},"name":{},"text":{"4":{},"9":{},"20":{},"25":{}},"component":{}}],["candidate.n_on",{"_index":1036,"title":{},"name":{},"text":{"9":{}},"component":{}}],["candidatedigit",{"_index":3201,"title":{},"name":{},"text":{"25":{}},"component":{}}],["candidates.len",{"_index":3206,"title":{},"name":{},"text":{"25":{}},"component":{}}],["candidates.mapv(|c",{"_index":491,"title":{},"name":{},"text":{"4":{}},"component":{}}],["candidates.push((transform",{"_index":2534,"title":{},"name":{},"text":{"20":{}},"component":{}}],["candidates[[i",{"_index":499,"title":{},"name":{},"text":{"4":{}},"component":{}}],["candidates_for_merge(&self",{"_index":2515,"title":{},"name":{},"text":{"20":{}},"component":{}}],["can’t",{"_index":1973,"title":{},"name":{},"text":{"18":{},"20":{}},"component":{}}],["cap",{"_index":681,"title":{},"name":{},"text":{"6":{},"18":{}},"component":{}}],["capit",{"_index":1510,"title":{},"name":{},"text":{"14":{}},"component":{}}],["caps.get(i).and_then(|m",{"_index":2008,"title":{},"name":{},"text":{"18":{}},"component":{}}],["caps.get(i)?.as_str().parse::().ok",{"_index":688,"title":{},"name":{},"text":{"6":{}},"component":{}}],["cartesian",{"_index":530,"title":{},"name":{},"text":{"5":{},"6":{}},"component":{}}],["case",{"_index":76,"title":{},"name":{},"text":{"1":{},"2":{},"7":{},"9":{},"13":{},"15":{},"17":{}},"component":{}}],["catch",{"_index":869,"title":{},"name":{},"text":{"8":{}},"component":{}}],["caus",{"_index":2404,"title":{},"name":{},"text":{"20":{}},"component":{}}],["cave",{"_index":1320,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cave.traverse(fals",{"_index":1392,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cave.traverse(tru",{"_index":1394,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cave_system",{"_index":1387,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cave_visit_count",{"_index":1372,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cave_visit_counts.entry(next_cave.name).or_insert(0",{"_index":1379,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cavekind",{"_index":1351,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cavekind::big",{"_index":1358,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cavekind::smal",{"_index":1357,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cavesystem",{"_index":1359,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cavesystem::from_str(input).unwrap",{"_index":1388,"title":{},"name":{},"text":{"13":{}},"component":{}}],["center_col",{"_index":2638,"title":{},"name":{},"text":{"21":{}},"component":{}}],["center_row",{"_index":2636,"title":{},"name":{},"text":{"21":{}},"component":{}}],["center_row.checked_sub(1",{"_index":2642,"title":{},"name":{},"text":{"21":{}},"component":{}}],["certain",{"_index":1315,"title":{},"name":{},"text":{"13":{}},"component":{}}],["cf",{"_index":915,"title":{},"name":{},"text":{"9":{}},"component":{}}],["cfg!(not(debug_assert",{"_index":2587,"title":{},"name":{},"text":{"20":{},"25":{}},"component":{}}],["cfg(debug_assert",{"_index":3184,"title":{},"name":{},"text":{"25":{}},"component":{}}],["cfg(featur",{"_index":126,"title":{},"name":{},"text":{"1":{}},"component":{}}],["cfg(test",{"_index":352,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["chain(other.elems.as_ref",{"_index":2238,"title":{},"name":{},"text":{"19":{}},"component":{}}],["chain(rest.iter().enumerate().filter_map(|(j",{"_index":2552,"title":{},"name":{},"text":{"20":{}},"component":{}}],["challeng",{"_index":408,"title":{},"name":{},"text":{"4":{},"6":{},"17":{}},"component":{}}],["changed_l_idx",{"_index":2209,"title":{},"name":{},"text":{"19":{}},"component":{}}],["changed_r_idx",{"_index":2213,"title":{},"name":{},"text":{"19":{}},"component":{}}],["char",{"_index":1142,"title":{},"name":{},"text":{"10":{},"11":{},"12":{},"15":{},"21":{},"24":{}},"component":{}}],["char_count",{"_index":1613,"title":{},"name":{},"text":{"15":{}},"component":{}}],["char_counts.valu",{"_index":1622,"title":{},"name":{},"text":{"15":{}},"component":{}}],["char_counts_2x",{"_index":1614,"title":{},"name":{},"text":{"15":{}},"component":{}}],["char_counts_2x.entry(c).or_insert(0",{"_index":1618,"title":{},"name":{},"text":{"15":{}},"component":{}}],["char_pair_count",{"_index":1611,"title":{},"name":{},"text":{"15":{}},"component":{}}],["charact",{"_index":427,"title":{},"name":{},"text":{"4":{},"15":{},"17":{},"19":{}},"component":{}}],["cheaper",{"_index":1667,"title":{},"name":{},"text":{"16":{}},"component":{}}],["cheapest",{"_index":2930,"title":{},"name":{},"text":{"24":{}},"component":{}}],["check",{"_index":317,"title":{},"name":{},"text":{"2":{},"15":{},"18":{},"25":{}},"component":{}}],["child",{"_index":1781,"title":{},"name":{},"text":{"17":{}},"component":{}}],["children",{"_index":1779,"title":{},"name":{},"text":{"17":{}},"component":{}}],["chiton",{"_index":253,"title":{"16":{}},"name":{},"text":{"1":{}},"component":{}}],["choic",{"_index":1344,"title":{},"name":{},"text":{"13":{},"18":{}},"component":{}}],["choices1",{"_index":1019,"title":{},"name":{},"text":{"9":{}},"component":{}}],["choices2",{"_index":1022,"title":{},"name":{},"text":{"9":{}},"component":{}}],["choos",{"_index":1639,"title":{},"name":{},"text":{"16":{}},"component":{}}],["chunk",{"_index":1837,"title":{},"name":{},"text":{"17":{}},"component":{}}],["chunk[0",{"_index":1840,"title":{},"name":{},"text":{"17":{}},"component":{}}],["chunk_siz",{"_index":1834,"title":{},"name":{},"text":{"17":{}},"component":{}}],["circularbuff",{"_index":309,"title":{},"name":{},"text":{"2":{}},"component":{}}],["classic",{"_index":1634,"title":{},"name":{},"text":{"16":{},"24":{}},"component":{}}],["classifi",{"_index":1324,"title":{},"name":{},"text":{"13":{}},"component":{}}],["clearli",{"_index":2677,"title":{},"name":{},"text":{"22":{}},"component":{}}],["clippy::enum_glob_us",{"_index":112,"title":{},"name":{},"text":{"1":{}},"component":{}}],["clippy::missing_panics_doc",{"_index":113,"title":{},"name":{},"text":{"1":{}},"component":{}}],["clippy::must_use_candid",{"_index":114,"title":{},"name":{},"text":{"1":{}},"component":{}}],["clippy::similar_nam",{"_index":115,"title":{},"name":{},"text":{"1":{}},"component":{}}],["clippy::too_many_lin",{"_index":116,"title":{},"name":{},"text":{"1":{}},"component":{}}],["clone",{"_index":966,"title":{},"name":{},"text":{"9":{},"14":{},"15":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["cmp(&self",{"_index":2947,"title":{},"name":{},"text":{"24":{}},"component":{}}],["cmp_predic",{"_index":484,"title":{},"name":{},"text":{"4":{}},"component":{}}],["cmp_predicate(2",{"_index":502,"title":{},"name":{},"text":{"4":{}},"component":{}}],["co2_rat",{"_index":513,"title":{},"name":{},"text":{"4":{}},"component":{}}],["code",{"_index":5,"title":{"1":{}},"name":{},"text":{"1":{},"5":{},"13":{},"15":{},"17":{},"20":{}},"component":{}}],["coincid",{"_index":2101,"title":{},"name":{},"text":{"18":{}},"component":{}}],["col",{"_index":533,"title":{},"name":{},"text":{"5":{},"10":{},"20":{},"24":{},"26":{}},"component":{}}],["col(&self",{"_index":2443,"title":{},"name":{},"text":{"20":{}},"component":{}}],["col)).unwrap_or(&wal",{"_index":2995,"title":{},"name":{},"text":{"24":{}},"component":{}}],["col[i]).sum",{"_index":2458,"title":{},"name":{},"text":{"20":{}},"component":{}}],["col]].to_char",{"_index":3011,"title":{},"name":{},"text":{"24":{}},"component":{}}],["col_has_more_ones_than_zero",{"_index":472,"title":{},"name":{},"text":{"4":{}},"component":{}}],["col_rang",{"_index":3075,"title":{},"name":{},"text":{"24":{}},"component":{}}],["collaps",{"_index":2372,"title":{},"name":{},"text":{"19":{}},"component":{}}],["collect",{"_index":393,"title":{},"name":{},"text":{"3":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"14":{},"15":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{}},"component":{}}],["collections::btreeset",{"_index":2420,"title":{},"name":{},"text":{"20":{}},"component":{}}],["collections::{btreemap",{"_index":569,"title":{},"name":{},"text":{"5":{},"24":{},"25":{}},"component":{}}],["column",{"_index":494,"title":{},"name":{},"text":{"4":{},"5":{},"20":{}},"component":{}}],["combin",{"_index":2150,"title":{},"name":{},"text":{"19":{},"23":{}},"component":{}}],["combine(&self",{"_index":1887,"title":{},"name":{},"text":{"17":{}},"component":{}}],["come",{"_index":1776,"title":{},"name":{},"text":{"17":{},"23":{}},"component":{}}],["commonli",{"_index":102,"title":{},"name":{},"text":{"1":{}},"component":{}}],["comp",{"_index":1470,"title":{},"name":{},"text":{"14":{},"20":{},"23":{}},"component":{}}],["compar",{"_index":314,"title":{},"name":{},"text":{"2":{},"24":{}},"component":{}}],["compare(comparitor",{"_index":1896,"title":{},"name":{},"text":{"17":{}},"component":{}}],["compare(eq",{"_index":1903,"title":{},"name":{},"text":{"17":{}},"component":{}}],["compare(gt",{"_index":1901,"title":{},"name":{},"text":{"17":{}},"component":{}}],["compare(lt",{"_index":1902,"title":{},"name":{},"text":{"17":{}},"component":{}}],["comparitor",{"_index":1890,"title":{},"name":{},"text":{"17":{}},"component":{}}],["comparitor.apply(first",{"_index":1914,"title":{},"name":{},"text":{"17":{}},"component":{}}],["compil",{"_index":69,"title":{},"name":{},"text":{"1":{}},"component":{}}],["complic",{"_index":1118,"title":{},"name":{},"text":{"10":{},"18":{}},"component":{}}],["compon",{"_index":313,"title":{},"name":{},"text":{"2":{}},"component":{}}],["compris",{"_index":1780,"title":{},"name":{},"text":{"17":{},"24":{}},"component":{}}],["comps.next",{"_index":2857,"title":{},"name":{},"text":{"23":{}},"component":{}}],["comps.next()?.parse().ok",{"_index":2563,"title":{},"name":{},"text":{"20":{}},"component":{}}],["comps.next()?.parse::().ok",{"_index":1471,"title":{},"name":{},"text":{"14":{}},"component":{}}],["comput",{"_index":438,"title":{},"name":{},"text":{"4":{},"5":{},"9":{},"15":{},"17":{}},"component":{}}],["computation",{"_index":1527,"title":{},"name":{},"text":{"15":{},"18":{},"22":{},"24":{}},"component":{}}],["computer’",{"_index":905,"title":{},"name":{},"text":{"9":{}},"component":{}}],["concat",{"_index":1501,"title":{},"name":{},"text":{"14":{}},"component":{}}],["concaten",{"_index":1738,"title":{},"name":{},"text":{"16":{},"19":{}},"component":{}}],["concav",{"_index":877,"title":{},"name":{},"text":{"8":{}},"component":{}}],["conclus",{"_index":3,"title":{"1-3":{}},"name":{},"text":{},"component":{}}],["condit",{"_index":416,"title":{},"name":{},"text":{"4":{}},"component":{}}],["connect",{"_index":1125,"title":{},"name":{},"text":{"10":{}},"component":{}}],["consecut",{"_index":2370,"title":{},"name":{},"text":{"19":{}},"component":{}}],["consid",{"_index":2913,"title":{},"name":{},"text":{"24":{}},"component":{}}],["consider",{"_index":2141,"title":{},"name":{},"text":{"18":{}},"component":{}}],["consist",{"_index":1748,"title":{},"name":{},"text":{"17":{},"22":{}},"component":{}}],["const",{"_index":757,"title":{},"name":{},"text":{"7":{},"9":{},"24":{}},"component":{}}],["constant",{"_index":792,"title":{},"name":{},"text":{"8":{}},"component":{}}],["constraint",{"_index":1313,"title":{},"name":{},"text":{"13":{},"18":{},"24":{}},"component":{}}],["construct",{"_index":1737,"title":{},"name":{},"text":{"16":{},"24":{}},"component":{}}],["consum",{"_index":1773,"title":{},"name":{},"text":{"17":{},"25":{}},"component":{}}],["contain",{"_index":1127,"title":{},"name":{},"text":{"10":{},"14":{},"15":{},"17":{},"19":{},"23":{},"25":{}},"component":{}}],["content",{"_index":2598,"title":{},"name":{},"text":{"21":{}},"component":{}}],["contextu",{"_index":30,"title":{},"name":{},"text":{"1":{}},"component":{}}],["continu",{"_index":640,"title":{},"name":{},"text":{"5":{},"6":{},"9":{},"10":{},"13":{},"16":{},"17":{},"18":{},"20":{},"23":{},"24":{},"26":{}},"component":{}}],["control",{"_index":749,"title":{},"name":{},"text":{"7":{}},"component":{}}],["convert",{"_index":429,"title":{},"name":{},"text":{"4":{}},"component":{}}],["coord",{"_index":596,"title":{},"name":{},"text":{"5":{},"16":{},"23":{}},"component":{}}],["coordin",{"_index":531,"title":{},"name":{},"text":{"5":{},"18":{},"23":{}},"component":{}}],["coords_stack",{"_index":1178,"title":{},"name":{},"text":{"10":{}},"component":{}}],["coords_stack.pop",{"_index":1181,"title":{},"name":{},"text":{"10":{}},"component":{}}],["coords_stack.push(nghbr_idx",{"_index":1187,"title":{},"name":{},"text":{"10":{}},"component":{}}],["copi",{"_index":771,"title":{},"name":{},"text":{"7":{},"9":{},"11":{},"16":{},"18":{},"19":{},"20":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["copy>(&self",{"_index":2511,"title":{},"name":{},"text":{"20":{}},"component":{}}],["corner",{"_index":1422,"title":{},"name":{},"text":{"14":{},"16":{}},"component":{}}],["correct",{"_index":58,"title":{},"name":{},"text":{"1":{},"9":{},"15":{},"17":{}},"component":{}}],["correctli",{"_index":70,"title":{},"name":{},"text":{"1":{},"3":{},"9":{},"12":{}},"component":{}}],["correspond",{"_index":426,"title":{},"name":{},"text":{"4":{},"9":{},"23":{}},"component":{}}],["corrupt",{"_index":1205,"title":{},"name":{},"text":{"11":{}},"component":{}}],["corrupted(token",{"_index":1220,"title":{},"name":{},"text":{"11":{}},"component":{}}],["cost",{"_index":849,"title":{},"name":{},"text":{"8":{},"16":{},"24":{}},"component":{}}],["cost(0",{"_index":3038,"title":{},"name":{},"text":{"24":{}},"component":{}}],["cost(cost.0",{"_index":3085,"title":{},"name":{},"text":{"24":{}},"component":{}}],["cost(mean",{"_index":821,"title":{},"name":{},"text":{"8":{}},"component":{}}],["cost(mean_rounded_down",{"_index":829,"title":{},"name":{},"text":{"8":{}},"component":{}}],["cost(us",{"_index":2945,"title":{},"name":{},"text":{"24":{}},"component":{}}],["cost::max",{"_index":1697,"title":{},"name":{},"text":{"16":{}},"component":{}}],["cost::try_from(outer_r",{"_index":1726,"title":{},"name":{},"text":{"16":{}},"component":{}}],["count",{"_index":413,"title":{},"name":{},"text":{"4":{},"5":{},"6":{},"9":{},"13":{},"15":{},"17":{},"18":{},"20":{},"21":{},"22":{}},"component":{}}],["counter",{"_index":692,"title":{},"name":{},"text":{"6":{}},"component":{}}],["counter.entry(point(x",{"_index":704,"title":{},"name":{},"text":{"6":{}},"component":{}}],["counteract",{"_index":1867,"title":{},"name":{},"text":{"17":{}},"component":{}}],["counts[r1",{"_index":2737,"title":{},"name":{},"text":{"22":{}},"component":{}}],["coupl",{"_index":2483,"title":{},"name":{},"text":{"20":{}},"component":{}}],["cours",{"_index":2133,"title":{},"name":{},"text":{"18":{}},"component":{}}],["crap",{"_index":1954,"title":{},"name":{},"text":{"18":{}},"component":{}}],["crate::answ",{"_index":327,"title":{},"name":{},"text":{"2":{},"3":{},"5":{},"6":{},"7":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"18":{},"19":{},"20":{},"22":{},"23":{},"25":{},"26":{}},"component":{}}],["crate::test_input",{"_index":355,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"20":{},"21":{},"22":{},"23":{},"25":{},"26":{}},"component":{}}],["crate::{utils::abs_diff",{"_index":803,"title":{},"name":{},"text":{"8":{},"24":{}},"component":{}}],["crate::{utils::to_big_decim",{"_index":1792,"title":{},"name":{},"text":{"17":{}},"component":{}}],["crate::{utils::to_decim",{"_index":441,"title":{},"name":{},"text":{"4":{},"21":{}},"component":{}}],["creat",{"_index":81,"title":{},"name":{},"text":{"1":{},"4":{},"23":{},"24":{}},"component":{}}],["cross",{"_index":900,"title":{},"name":{},"text":{"9":{}},"component":{}}],["crux",{"_index":2910,"title":{},"name":{},"text":{"24":{}},"component":{}}],["cs",{"_index":1635,"title":{},"name":{},"text":{"16":{},"23":{}},"component":{}}],["cs.sort_by_key(|c",{"_index":2830,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[0].x_range[0",{"_index":2835,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[0].x_range[1",{"_index":2832,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[0].y_range[0",{"_index":2841,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[0].y_range[1",{"_index":2839,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[0].z_range[0",{"_index":2846,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[0].z_range[1",{"_index":2844,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[1].x_range[0",{"_index":2833,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[1].x_range[1",{"_index":2836,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[1].y_range[0",{"_index":2840,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[1].y_range[1",{"_index":2842,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[1].z_range[0",{"_index":2845,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cs[1].z_range[1",{"_index":2847,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cube",{"_index":2756,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cuboid",{"_index":2777,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cuboid.intersection(&bound",{"_index":2877,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cuboid.s",{"_index":2892,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cuboid::from_coords_str(str_comps.next",{"_index":2870,"title":{},"name":{},"text":{"23":{}},"component":{}}],["cucumb",{"_index":282,"title":{"26":{}},"name":{},"text":{"1":{}},"component":{}}],["curli",{"_index":1212,"title":{},"name":{},"text":{"11":{}},"component":{}}],["curr",{"_index":1225,"title":{},"name":{},"text":{"11":{}},"component":{}}],["curr.borrow",{"_index":1226,"title":{},"name":{},"text":{"11":{}},"component":{}}],["curr.brac",{"_index":1233,"title":{},"name":{},"text":{"11":{}},"component":{}}],["curr.orient",{"_index":1231,"title":{},"name":{},"text":{"11":{}},"component":{}}],["curr_cav",{"_index":1370,"title":{},"name":{},"text":{"13":{}},"component":{}}],["curr_col",{"_index":3071,"title":{},"name":{},"text":{"24":{}},"component":{}}],["curr_depth",{"_index":2255,"title":{},"name":{},"text":{"19":{}},"component":{}}],["curr_in_reg",{"_index":3141,"title":{},"name":{},"text":{"25":{}},"component":{}}],["curr_instr",{"_index":3142,"title":{},"name":{},"text":{"25":{}},"component":{}}],["curr_instrs.clear",{"_index":3150,"title":{},"name":{},"text":{"25":{}},"component":{}}],["curr_instrs.clon",{"_index":3148,"title":{},"name":{},"text":{"25":{}},"component":{}}],["curr_instrs.push(mathinstr",{"_index":3154,"title":{},"name":{},"text":{"25":{}},"component":{}}],["curr_loc",{"_index":3061,"title":{},"name":{},"text":{"24":{}},"component":{}}],["curr_loc[col",{"_index":3067,"title":{},"name":{},"text":{"24":{}},"component":{}}],["curr_loc[row",{"_index":3068,"title":{},"name":{},"text":{"24":{}},"component":{}}],["curr_row",{"_index":3070,"title":{},"name":{},"text":{"24":{}},"component":{}}],["curr_z",{"_index":3176,"title":{},"name":{},"text":{"25":{}},"component":{}}],["curr_zs.entry(z).or_insert_with(set::new).insert(prev_z",{"_index":3183,"title":{},"name":{},"text":{"25":{}},"component":{}}],["curr_zs.len",{"_index":3185,"title":{},"name":{},"text":{"25":{}},"component":{}}],["current",{"_index":298,"title":{},"name":{},"text":{"2":{},"3":{},"13":{},"16":{},"17":{},"24":{}},"component":{}}],["cursor",{"_index":1770,"title":{},"name":{},"text":{"17":{}},"component":{}}],["cut",{"_index":2684,"title":{},"name":{},"text":{"22":{}},"component":{}}],["c|f",{"_index":956,"title":{},"name":{},"text":{"9":{}},"component":{}}],["d",{"_index":945,"title":{},"name":{},"text":{"9":{},"18":{},"19":{},"24":{}},"component":{}}],["d.borrow",{"_index":1091,"title":{},"name":{},"text":{"9":{}},"component":{}}],["d_cost",{"_index":1725,"title":{},"name":{},"text":{"16":{}},"component":{}}],["data",{"_index":843,"title":{},"name":{},"text":{"8":{},"10":{},"12":{},"17":{},"21":{}},"component":{}}],["data).ok",{"_index":1148,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["data).unwrap",{"_index":2624,"title":{},"name":{},"text":{"21":{}},"component":{}}],["data.extend",{"_index":1141,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["data.into_iter().collect",{"_index":1273,"title":{},"name":{},"text":{"12":{}},"component":{}}],["data.iter().copied().collect",{"_index":1146,"title":{},"name":{},"text":{"10":{}},"component":{}}],["data.len",{"_index":2623,"title":{},"name":{},"text":{"21":{}},"component":{}}],["data_bit",{"_index":1827,"title":{},"name":{},"text":{"17":{}},"component":{}}],["data_bits.chunks_exact(5",{"_index":1838,"title":{},"name":{},"text":{"17":{}},"component":{}}],["data_bits[0",{"_index":1846,"title":{},"name":{},"text":{"17":{}},"component":{}}],["dataset",{"_index":837,"title":{},"name":{},"text":{"8":{}},"component":{}}],["datum_abov",{"_index":814,"title":{},"name":{},"text":{"8":{}},"component":{}}],["datum_below",{"_index":812,"title":{},"name":{},"text":{"8":{}},"component":{}}],["day",{"_index":160,"title":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["day:expr",{"_index":184,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_01:\"day_01",{"_index":130,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_02:\"day_02",{"_index":131,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_03:\"day_03",{"_index":132,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_04:\"day_04",{"_index":133,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_05:\"day_05",{"_index":134,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_06:\"day_06",{"_index":135,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_07:\"day_07",{"_index":136,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_08:\"day_08",{"_index":137,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_09:\"day_09",{"_index":138,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_10:\"day_10",{"_index":139,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_11:\"day_11",{"_index":140,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_12:\"day_12",{"_index":141,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_13:\"day_13",{"_index":142,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_14:\"day_14",{"_index":143,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_15:\"day_15",{"_index":144,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_16:\"day_16",{"_index":145,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_17:\"day_17",{"_index":146,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_18:\"day_18",{"_index":147,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_19:\"day_19",{"_index":148,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_20:\"day_20",{"_index":149,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_21:\"day_21",{"_index":150,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_22:\"day_22",{"_index":151,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_23:\"day_23",{"_index":152,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_24:\"day_24",{"_index":153,"title":{},"name":{},"text":{"1":{}},"component":{}}],["day_25:\"day_25",{"_index":154,"title":{},"name":{},"text":{"1":{}},"component":{}}],["dddd",{"_index":891,"title":{},"name":{},"text":{"9":{}},"component":{}}],["de",{"_index":953,"title":{},"name":{},"text":{"9":{}},"component":{}}],["debug",{"_index":1210,"title":{},"name":{},"text":{"11":{},"12":{},"14":{},"15":{},"20":{},"24":{},"25":{},"26":{}},"component":{}}],["decim",{"_index":433,"title":{},"name":{},"text":{"4":{}},"component":{}}],["decod",{"_index":256,"title":{"17":{}},"name":{},"text":{"1":{}},"component":{}}],["decreas",{"_index":845,"title":{},"name":{},"text":{"8":{},"18":{}},"component":{}}],["decrement",{"_index":557,"title":{},"name":{},"text":{"5":{},"17":{}},"component":{}}],["deduc",{"_index":881,"title":{},"name":{},"text":{"9":{}},"component":{}}],["deep",{"_index":363,"title":{},"name":{},"text":{"3":{}},"component":{}}],["deeper",{"_index":2375,"title":{},"name":{},"text":{"19":{},"24":{}},"component":{}}],["def",{"_index":951,"title":{},"name":{},"text":{"9":{}},"component":{}}],["defin",{"_index":661,"title":{},"name":{},"text":{"6":{},"17":{}},"component":{}}],["definit",{"_index":1658,"title":{},"name":{},"text":{"16":{},"18":{}},"component":{}}],["delet",{"_index":2362,"title":{},"name":{},"text":{"19":{}},"component":{}}],["depend",{"_index":1326,"title":{},"name":{},"text":{"13":{},"21":{}},"component":{}}],["depth",{"_index":299,"title":{},"name":{},"text":{"2":{},"17":{},"19":{}},"component":{}}],["depth_buf",{"_index":331,"title":{},"name":{},"text":{"2":{}},"component":{}}],["depth_buf.extend(depths.by_ref().take(n",{"_index":335,"title":{},"name":{},"text":{"2":{}},"component":{}}],["depth_buf.len",{"_index":336,"title":{},"name":{},"text":{"2":{}},"component":{}}],["depth_stack",{"_index":2250,"title":{},"name":{},"text":{"19":{}},"component":{}}],["depth_stack.extend([prev_depth",{"_index":2262,"title":{},"name":{},"text":{"19":{}},"component":{}}],["depth_stack.pop",{"_index":2253,"title":{},"name":{},"text":{"19":{}},"component":{}}],["depth_stack.push(curr_depth",{"_index":2259,"title":{},"name":{},"text":{"19":{}},"component":{}}],["depth_stack.push(depth",{"_index":2252,"title":{},"name":{},"text":{"19":{}},"component":{}}],["deriv",{"_index":937,"title":{},"name":{},"text":{"9":{},"18":{}},"component":{}}],["derive(clon",{"_index":1209,"title":{},"name":{},"text":{"11":{},"12":{},"14":{},"20":{},"22":{},"24":{},"26":{}},"component":{}}],["derive(copi",{"_index":1445,"title":{},"name":{},"text":{"14":{},"15":{}},"component":{}}],["derive(debug",{"_index":156,"title":{},"name":{},"text":{"1":{},"5":{},"6":{},"9":{},"10":{},"13":{},"15":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["derive(eq",{"_index":2944,"title":{},"name":{},"text":{"24":{}},"component":{}}],["descend",{"_index":1786,"title":{},"name":{},"text":{"17":{},"19":{}},"component":{}}],["descent",{"_index":2055,"title":{},"name":{},"text":{"18":{}},"component":{}}],["describ",{"_index":551,"title":{},"name":{},"text":{"5":{},"24":{}},"component":{}}],["descript",{"_index":295,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["desir",{"_index":2373,"title":{},"name":{},"text":{"19":{}},"component":{}}],["despit",{"_index":1660,"title":{},"name":{},"text":{"16":{},"17":{}},"component":{}}],["dest",{"_index":1364,"title":{},"name":{},"text":{"13":{}},"component":{}}],["dest_col",{"_index":3062,"title":{},"name":{},"text":{"24":{}},"component":{}}],["dest_col(self",{"_index":2958,"title":{},"name":{},"text":{"24":{}},"component":{}}],["destin",{"_index":1312,"title":{},"name":{},"text":{"13":{},"24":{}},"component":{}}],["determin",{"_index":2366,"title":{},"name":{},"text":{"19":{}},"component":{}}],["determinist",{"_index":2673,"title":{},"name":{},"text":{"22":{}},"component":{}}],["deterministicdi",{"_index":2699,"title":{},"name":{},"text":{"22":{}},"component":{}}],["deterministicdie::new(1",{"_index":2713,"title":{},"name":{},"text":{"22":{}},"component":{}}],["deviat",{"_index":835,"title":{},"name":{},"text":{"8":{}},"component":{}}],["df",{"_index":1129,"title":{},"name":{},"text":{"10":{}},"component":{}}],["diag_count",{"_index":715,"title":{},"name":{},"text":{"6":{}},"component":{}}],["diag_counter.entry(k).or_default",{"_index":717,"title":{},"name":{},"text":{"6":{}},"component":{}}],["diagnost",{"_index":219,"title":{"4":{}},"name":{},"text":{"1":{}},"component":{}}],["diagon",{"_index":732,"title":{},"name":{},"text":{"6":{}},"component":{}}],["dice",{"_index":270,"title":{"22":{}},"name":{},"text":{"1":{},"22":{}},"component":{}}],["dictionari",{"_index":527,"title":{},"name":{},"text":{"5":{},"13":{}},"component":{}}],["did_modifi",{"_index":1700,"title":{},"name":{},"text":{"16":{}},"component":{}}],["didn’t",{"_index":1567,"title":{},"name":{},"text":{"15":{},"16":{}},"component":{}}],["die",{"_index":2671,"title":{},"name":{},"text":{"22":{}},"component":{}}],["die.n_rol",{"_index":2720,"title":{},"name":{},"text":{"22":{}},"component":{}}],["die.roll()).sum",{"_index":2702,"title":{},"name":{},"text":{"22":{}},"component":{}}],["die_n_fac",{"_index":2725,"title":{},"name":{},"text":{"22":{}},"component":{}}],["diff",{"_index":824,"title":{},"name":{},"text":{"8":{},"20":{}},"component":{}}],["differ",{"_index":16,"title":{},"name":{},"text":{"1":{},"8":{},"9":{},"20":{},"24":{}},"component":{}}],["digit",{"_index":432,"title":{},"name":{},"text":{"4":{},"9":{},"17":{},"19":{},"25":{}},"component":{}}],["digit..=9",{"_index":3212,"title":{},"name":{},"text":{"25":{}},"component":{}}],["digit.segments.map(u8::from",{"_index":994,"title":{},"name":{},"text":{"9":{}},"component":{}}],["digit::from(n",{"_index":1002,"title":{},"name":{},"text":{"9":{}},"component":{}}],["digit::new([fals",{"_index":1071,"title":{},"name":{},"text":{"9":{}},"component":{}}],["digit_idx",{"_index":3169,"title":{},"name":{},"text":{"25":{}},"component":{}}],["digit_sum",{"_index":496,"title":{},"name":{},"text":{"4":{}},"component":{}}],["digitrang",{"_index":3198,"title":{},"name":{},"text":{"25":{}},"component":{}}],["digits_w_same_n_seg",{"_index":1008,"title":{},"name":{},"text":{"9":{}},"component":{}}],["digits_w_same_n_segments.clon",{"_index":1011,"title":{},"name":{},"text":{"9":{}},"component":{}}],["dimens",{"_index":2823,"title":{},"name":{},"text":{"23":{}},"component":{}}],["dimension",{"_index":2397,"title":{},"name":{},"text":{"20":{}},"component":{}}],["dirac",{"_index":269,"title":{"22":{}},"name":{},"text":{"1":{}},"component":{}}],["direct",{"_index":374,"title":{},"name":{},"text":{"3":{},"16":{},"17":{},"18":{}},"component":{}}],["direction::from_str(tokens_iter.next",{"_index":390,"title":{},"name":{},"text":{"3":{}},"component":{}}],["discrimin",{"_index":2024,"title":{},"name":{},"text":{"18":{}},"component":{}}],["discuss",{"_index":1744,"title":{},"name":{},"text":{"16":{},"22":{}},"component":{}}],["disjoint",{"_index":1045,"title":{},"name":{},"text":{"9":{},"24":{}},"component":{}}],["display",{"_index":118,"title":{},"name":{},"text":{"1":{},"9":{},"14":{},"19":{},"21":{},"23":{}},"component":{}}],["dist",{"_index":384,"title":{},"name":{},"text":{"3":{},"16":{}},"component":{}}],["distanc",{"_index":851,"title":{},"name":{},"text":{"8":{},"20":{}},"component":{}}],["distinct",{"_index":2148,"title":{},"name":{},"text":{"18":{},"20":{}},"component":{}}],["div",{"_index":3123,"title":{},"name":{},"text":{"25":{}},"component":{}}],["div_mod_floor(i",{"_index":590,"title":{},"name":{},"text":{"5":{}},"component":{}}],["dive",{"_index":216,"title":{"3":{}},"name":{},"text":{"1":{}},"component":{}}],["divid",{"_index":1547,"title":{},"name":{},"text":{"15":{},"19":{},"23":{}},"component":{}}],["divis",{"_index":1560,"title":{},"name":{},"text":{"15":{}},"component":{}}],["do",{"_index":1339,"title":{},"name":{},"text":{"13":{},"23":{}},"component":{}}],["do_fold",{"_index":1463,"title":{},"name":{},"text":{"14":{}},"component":{}}],["doc",{"_index":8,"title":{},"name":{},"text":{"1":{},"5":{}},"component":{}}],["document",{"_index":36,"title":{},"name":{},"text":{"1":{}},"component":{}}],["doesn’t",{"_index":1540,"title":{},"name":{},"text":{"15":{},"20":{}},"component":{}}],["domin",{"_index":862,"title":{},"name":{},"text":{"8":{}},"component":{}}],["done",{"_index":949,"title":{},"name":{},"text":{"9":{},"11":{},"20":{},"23":{},"25":{}},"component":{}}],["don’t",{"_index":39,"title":{},"name":{},"text":{"1":{},"9":{},"13":{}},"component":{}}],["doorway",{"_index":2923,"title":{},"name":{},"text":{"24":{}},"component":{}}],["dot",{"_index":1415,"title":{},"name":{},"text":{"14":{}},"component":{}}],["dots.insert(p.folded(fold",{"_index":1461,"title":{},"name":{},"text":{"14":{}},"component":{}}],["dots.into_iter().collect",{"_index":1457,"title":{},"name":{},"text":{"14":{}},"component":{}}],["doubl",{"_index":1526,"title":{},"name":{},"text":{"15":{}},"component":{}}],["down",{"_index":376,"title":{},"name":{},"text":{"3":{},"8":{},"9":{},"18":{},"19":{},"22":{},"26":{}},"component":{}}],["downs.insert(loc",{"_index":3226,"title":{},"name":{},"text":{"26":{}},"component":{}}],["drag",{"_index":1971,"title":{},"name":{},"text":{"18":{}},"component":{}}],["draw",{"_index":648,"title":{},"name":{},"text":{"5":{}},"component":{}}],["drawn",{"_index":526,"title":{},"name":{},"text":{"5":{}},"component":{}}],["due",{"_index":1648,"title":{},"name":{},"text":{"16":{},"24":{}},"component":{}}],["dumbo",{"_index":241,"title":{"12":{}},"name":{},"text":{"1":{}},"component":{}}],["dummi",{"_index":3143,"title":{},"name":{},"text":{"25":{}},"component":{}}],["duplic",{"_index":1946,"title":{},"name":{},"text":{"17":{}},"component":{}}],["durat",{"_index":2609,"title":{},"name":{},"text":{"21":{}},"component":{}}],["dure",{"_index":901,"title":{},"name":{},"text":{"9":{}},"component":{}}],["dyn",{"_index":1013,"title":{},"name":{},"text":{"9":{}},"component":{}}],["e",{"_index":892,"title":{},"name":{},"text":{"9":{},"16":{}},"component":{}}],["e.g",{"_index":1049,"title":{},"name":{},"text":{"9":{}},"component":{}}],["e1",{"_index":2201,"title":{},"name":{},"text":{"19":{}},"component":{}}],["e1.depth",{"_index":2204,"title":{},"name":{},"text":{"19":{}},"component":{}}],["e2",{"_index":2203,"title":{},"name":{},"text":{"19":{}},"component":{}}],["e2.depth",{"_index":2205,"title":{},"name":{},"text":{"19":{}},"component":{}}],["e_1,\\ldots,e_n",{"_index":2411,"title":{},"name":{},"text":{"20":{}},"component":{}}],["each",{"_index":18,"title":{},"name":{},"text":{"1":{},"5":{},"6":{},"9":{},"13":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{}},"component":{}}],["easi",{"_index":1757,"title":{},"name":{},"text":{"17":{},"18":{},"19":{}},"component":{}}],["easier",{"_index":1558,"title":{},"name":{},"text":{"15":{},"19":{},"20":{}},"component":{}}],["edg",{"_index":1316,"title":{},"name":{},"text":{"13":{},"18":{},"20":{},"23":{}},"component":{}}],["effect",{"_index":787,"title":{},"name":{},"text":{"8":{}},"component":{}}],["effici",{"_index":1961,"title":{},"name":{},"text":{"18":{},"24":{}},"component":{}}],["eight",{"_index":1509,"title":{},"name":{},"text":{"14":{},"21":{}},"component":{}}],["eight_i",{"_index":2038,"title":{},"name":{},"text":{"18":{}},"component":{}}],["eight_y.ab",{"_index":2040,"title":{},"name":{},"text":{"18":{}},"component":{}}],["elem",{"_index":2156,"title":{},"name":{},"text":{"19":{},"20":{}},"component":{}}],["elem.valu",{"_index":2216,"title":{},"name":{},"text":{"19":{}},"component":{}}],["element",{"_index":414,"title":{},"name":{},"text":{"4":{},"6":{},"19":{},"21":{}},"component":{}}],["elems.insert",{"_index":2222,"title":{},"name":{},"text":{"19":{}},"component":{}}],["elems.iter().enumer",{"_index":2251,"title":{},"name":{},"text":{"19":{}},"component":{}}],["elems.iter().enumerate().find_map(|(i",{"_index":2215,"title":{},"name":{},"text":{"19":{}},"component":{}}],["elems.len",{"_index":2248,"title":{},"name":{},"text":{"19":{}},"component":{}}],["elems.remove(r_idx",{"_index":2212,"title":{},"name":{},"text":{"19":{}},"component":{}}],["elems.split_at(i",{"_index":2256,"title":{},"name":{},"text":{"19":{}},"component":{}}],["elems[idx].valu",{"_index":2210,"title":{},"name":{},"text":{"19":{}},"component":{}}],["elems[l_idx",{"_index":2207,"title":{},"name":{},"text":{"19":{}},"component":{}}],["elems[split_idx",{"_index":2221,"title":{},"name":{},"text":{"19":{}},"component":{}}],["empti",{"_index":1207,"title":{},"name":{},"text":{"11":{},"23":{}},"component":{}}],["encount",{"_index":73,"title":{},"name":{},"text":{"1":{}},"component":{}}],["end",{"_index":903,"title":{},"name":{},"text":{"9":{},"11":{},"13":{},"14":{},"15":{},"17":{},"25":{}},"component":{}}],["end::add",{"_index":2242,"title":{},"name":{},"text":{"19":{}},"component":{}}],["end::algo",{"_index":3208,"title":{},"name":{},"text":{"25":{}},"component":{}}],["end::amphipod",{"_index":3012,"title":{},"name":{},"text":{"24":{}},"component":{}}],["end::cod",{"_index":213,"title":{},"name":{},"text":{"1":{}},"component":{}}],["end::debug",{"_index":2235,"title":{},"name":{},"text":{"19":{},"21":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["end::digit",{"_index":997,"title":{},"name":{},"text":{"9":{}},"component":{}}],["end::get_traj",{"_index":2065,"title":{},"name":{},"text":{"18":{}},"component":{}}],["end::magnitud",{"_index":2271,"title":{},"name":{},"text":{"19":{}},"component":{}}],["end::mod",{"_index":155,"title":{},"name":{},"text":{"1":{}},"component":{}}],["end::pair",{"_index":2263,"title":{},"name":{},"text":{"19":{}},"component":{}}],["end::pt1",{"_index":347,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["end::pt2",{"_index":351,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{}},"component":{}}],["end::setup",{"_index":344,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"25":{},"26":{}},"component":{}}],["end::setup_main",{"_index":2013,"title":{},"name":{},"text":{"18":{}},"component":{}}],["end::snail_num",{"_index":2158,"title":{},"name":{},"text":{"19":{}},"component":{}}],["end::solv",{"_index":3092,"title":{},"name":{},"text":{"24":{}},"component":{}}],["end::split",{"_index":2225,"title":{},"name":{},"text":{"19":{}},"component":{}}],["endpoint",{"_index":694,"title":{},"name":{},"text":{"6":{},"23":{}},"component":{}}],["endpointpair",{"_index":700,"title":{},"name":{},"text":{"6":{}},"component":{}}],["endpointpair(point",{"_index":675,"title":{},"name":{},"text":{"6":{}},"component":{}}],["endpointpair(point(x1",{"_index":701,"title":{},"name":{},"text":{"6":{}},"component":{}}],["end{align",{"_index":2097,"title":{},"name":{},"text":{"18":{}},"component":{}}],["end{cas",{"_index":2095,"title":{},"name":{},"text":{"18":{}},"component":{}}],["energy(self",{"_index":2960,"title":{},"name":{},"text":{"24":{}},"component":{}}],["enough",{"_index":1512,"title":{},"name":{},"text":{"14":{},"20":{},"23":{}},"component":{}}],["enqueu",{"_index":3025,"title":{},"name":{},"text":{"24":{}},"component":{}}],["entir",{"_index":927,"title":{},"name":{},"text":{"9":{},"25":{}},"component":{}}],["entri",{"_index":1121,"title":{},"name":{},"text":{"10":{},"13":{},"15":{},"20":{},"24":{}},"component":{}}],["entries.iter_mut().enumer",{"_index":2457,"title":{},"name":{},"text":{"20":{}},"component":{}}],["entries[i",{"_index":2451,"title":{},"name":{},"text":{"20":{}},"component":{}}],["entry(digit.n_on",{"_index":1003,"title":{},"name":{},"text":{"9":{}},"component":{}}],["entry(next_cave.nam",{"_index":1384,"title":{},"name":{},"text":{"13":{}},"component":{}}],["entry(orig",{"_index":1366,"title":{},"name":{},"text":{"13":{}},"component":{}}],["entry_costs.dim",{"_index":1694,"title":{},"name":{},"text":{"16":{}},"component":{}}],["entry_costs[nghbr_coord",{"_index":1706,"title":{},"name":{},"text":{"16":{}},"component":{}}],["enum",{"_index":373,"title":{},"name":{},"text":{"3":{},"11":{},"13":{},"14":{},"15":{},"16":{},"17":{},"20":{},"23":{},"24":{},"25":{}},"component":{}}],["enumer",{"_index":200,"title":{},"name":{},"text":{"1":{},"4":{},"9":{},"15":{},"18":{},"19":{},"22":{}},"component":{}}],["enumit",{"_index":2461,"title":{},"name":{},"text":{"20":{}},"component":{}}],["epsilon_r",{"_index":481,"title":{},"name":{},"text":{"4":{}},"component":{}}],["eq",{"_index":158,"title":{},"name":{},"text":{"1":{},"6":{},"9":{},"11":{},"13":{},"14":{},"15":{},"17":{},"18":{},"19":{},"20":{},"24":{},"26":{}},"component":{}}],["eql",{"_index":3124,"title":{},"name":{},"text":{"25":{}},"component":{}}],["eqn_sid",{"_index":1438,"title":{},"name":{},"text":{"14":{}},"component":{}}],["eqn_sides.next",{"_index":1441,"title":{},"name":{},"text":{"14":{}},"component":{}}],["eqn_sides.next()?.parse::().ok",{"_index":1442,"title":{},"name":{},"text":{"14":{}},"component":{}}],["equal",{"_index":1275,"title":{},"name":{},"text":{"12":{},"16":{}},"component":{}}],["equat",{"_index":2083,"title":{},"name":{},"text":{"18":{}},"component":{}}],["equival",{"_index":2912,"title":{},"name":{},"text":{"24":{}},"component":{}}],["err",{"_index":2368,"title":{},"name":{},"text":{"19":{}},"component":{}}],["err(map",{"_index":1069,"title":{},"name":{},"text":{"9":{}},"component":{}}],["err(self.elems.as_ref()[0].valu",{"_index":2249,"title":{},"name":{},"text":{"19":{}},"component":{}}],["err(tokenizationerr::corrupted(curr",{"_index":1234,"title":{},"name":{},"text":{"11":{}},"component":{}}],["err(tokenizationerr::corrupted(t",{"_index":1249,"title":{},"name":{},"text":{"11":{}},"component":{}}],["err(tokenizationerr::incomplet",{"_index":1237,"title":{},"name":{},"text":{"11":{}},"component":{}}],["err(tokenizationerr::incomplete(token",{"_index":1257,"title":{},"name":{},"text":{"11":{}},"component":{}}],["err(val",{"_index":2270,"title":{},"name":{},"text":{"19":{}},"component":{}}],["err(valu",{"_index":2273,"title":{},"name":{},"text":{"19":{}},"component":{}}],["error",{"_index":47,"title":{},"name":{},"text":{"1":{},"8":{},"15":{}},"component":{}}],["essenti",{"_index":1950,"title":{},"name":{},"text":{"17":{},"20":{}},"component":{}}],["etc",{"_index":2388,"title":{},"name":{},"text":{"20":{}},"component":{}}],["evalu",{"_index":1763,"title":{},"name":{},"text":{"17":{}},"component":{}}],["even",{"_index":90,"title":{},"name":{},"text":{"1":{},"9":{},"18":{}},"component":{}}],["eventu",{"_index":958,"title":{},"name":{},"text":{"9":{}},"component":{}}],["everyth",{"_index":1206,"title":{},"name":{},"text":{"11":{},"15":{},"18":{}},"component":{}}],["exactli",{"_index":913,"title":{},"name":{},"text":{"9":{},"17":{}},"component":{}}],["examin",{"_index":1640,"title":{},"name":{},"text":{"16":{}},"component":{}}],["exampl",{"_index":436,"title":{},"name":{},"text":{"4":{},"24":{}},"component":{}}],["exceed",{"_index":861,"title":{},"name":{},"text":{"8":{}},"component":{}}],["except",{"_index":50,"title":{},"name":{},"text":{"1":{},"16":{}},"component":{}}],["exclud",{"_index":2140,"title":{},"name":{},"text":{"18":{},"25":{}},"component":{}}],["exhaust",{"_index":1347,"title":{},"name":{},"text":{"13":{}},"component":{}}],["exist",{"_index":1518,"title":{},"name":{},"text":{"15":{},"18":{},"19":{},"20":{}},"component":{}}],["expand_grid(grid",{"_index":1711,"title":{},"name":{},"text":{"16":{}},"component":{}}],["expect",{"_index":1771,"title":{},"name":{},"text":{"17":{}},"component":{}}],["explanatori",{"_index":2376,"title":{},"name":{},"text":{"19":{}},"component":{}}],["explicitli",{"_index":45,"title":{},"name":{},"text":{"1":{}},"component":{}}],["explod",{"_index":2191,"title":{},"name":{},"text":{"19":{}},"component":{}}],["explode_first",{"_index":2186,"title":{},"name":{},"text":{"19":{}},"component":{}}],["explode_first(&mut",{"_index":2193,"title":{},"name":{},"text":{"19":{}},"component":{}}],["explor",{"_index":1318,"title":{},"name":{},"text":{"13":{},"24":{}},"component":{}}],["expon",{"_index":2685,"title":{},"name":{},"text":{"22":{}},"component":{}}],["express",{"_index":1764,"title":{},"name":{},"text":{"17":{}},"component":{}}],["extend",{"_index":250,"title":{"15":{}},"name":{},"text":{"1":{}},"component":{}}],["exterior",{"_index":2600,"title":{},"name":{},"text":{"21":{}},"component":{}}],["f",{"_index":169,"title":{},"name":{},"text":{"1":{},"9":{},"14":{},"19":{},"21":{},"23":{},"24":{},"26":{}},"component":{}}],["f(x",{"_index":979,"title":{},"name":{},"text":{"9":{}},"component":{}}],["f.write_char",{"_index":2865,"title":{},"name":{},"text":{"23":{}},"component":{}}],["f.write_char('\\n",{"_index":2619,"title":{},"name":{},"text":{"21":{},"24":{},"26":{}},"component":{}}],["f.write_char(bit",{"_index":2618,"title":{},"name":{},"text":{"21":{}},"component":{}}],["f.write_char(c",{"_index":1803,"title":{},"name":{},"text":{"17":{}},"component":{}}],["f.write_char(if",{"_index":3220,"title":{},"name":{},"text":{"26":{}},"component":{}}],["f.write_char(match",{"_index":2861,"title":{},"name":{},"text":{"23":{}},"component":{}}],["f.write_str(\"\\n",{"_index":1493,"title":{},"name":{},"text":{"14":{}},"component":{}}],["f.write_str(if",{"_index":1488,"title":{},"name":{},"text":{"14":{}},"component":{}}],["face",{"_index":2400,"title":{},"name":{},"text":{"20":{},"23":{}},"component":{}}],["fact",{"_index":744,"title":{},"name":{},"text":{"6":{},"8":{},"16":{},"17":{},"18":{},"24":{}},"component":{}}],["factor",{"_index":793,"title":{},"name":{},"text":{"8":{},"18":{},"22":{}},"component":{}}],["fall",{"_index":1740,"title":{},"name":{},"text":{"16":{}},"component":{}}],["fals",{"_index":428,"title":{},"name":{},"text":{"4":{},"5":{},"9":{},"13":{},"16":{},"19":{},"21":{},"24":{},"26":{}},"component":{}}],["famili",{"_index":1948,"title":{},"name":{},"text":{"17":{}},"component":{}}],["familiar",{"_index":10,"title":{},"name":{},"text":{"1":{}},"component":{}}],["far",{"_index":1774,"title":{},"name":{},"text":{"17":{},"24":{}},"component":{}}],["fashion",{"_index":750,"title":{},"name":{},"text":{"7":{}},"component":{}}],["faster",{"_index":1656,"title":{},"name":{},"text":{"16":{}},"component":{}}],["feasibl",{"_index":1574,"title":{},"name":{},"text":{"15":{},"22":{},"23":{}},"component":{}}],["feature(array_zip",{"_index":107,"title":{},"name":{},"text":{"1":{}},"component":{}}],["feature(bool_to_opt",{"_index":109,"title":{},"name":{},"text":{"1":{}},"component":{}}],["feature(map_first_last",{"_index":108,"title":{},"name":{},"text":{"1":{}},"component":{}}],["feel",{"_index":1654,"title":{},"name":{},"text":{"16":{}},"component":{}}],["fewest",{"_index":2914,"title":{},"name":{},"text":{"24":{}},"component":{}}],["file",{"_index":419,"title":{},"name":{},"text":{"4":{}},"component":{}}],["filter",{"_index":411,"title":{},"name":{},"text":{"4":{}},"component":{}}],["filter(|&n",{"_index":1103,"title":{},"name":{},"text":{"9":{}},"component":{}}],["filter_map(|(&k",{"_index":1599,"title":{},"name":{},"text":{"15":{}},"component":{}}],["filter_map(|(i",{"_index":497,"title":{},"name":{},"text":{"4":{},"22":{}},"component":{}}],["filter_map(|lin",{"_index":1078,"title":{},"name":{},"text":{"9":{}},"component":{}}],["filter_map(|r",{"_index":1256,"title":{},"name":{},"text":{"11":{}},"component":{}}],["filter_map(|splat",{"_index":2855,"title":{},"name":{},"text":{"23":{}},"component":{}}],["final",{"_index":1114,"title":{},"name":{},"text":{"9":{},"13":{},"15":{},"18":{},"24":{}},"component":{}}],["find",{"_index":297,"title":{},"name":{},"text":{"2":{},"8":{},"10":{},"16":{},"18":{},"19":{},"20":{},"23":{},"24":{},"25":{}},"component":{}}],["find_digit",{"_index":3194,"title":{},"name":{},"text":{"25":{}},"component":{}}],["find_map(|((i1",{"_index":2200,"title":{},"name":{},"text":{"19":{}},"component":{}}],["find_map(|(i",{"_index":507,"title":{},"name":{},"text":{"4":{}},"component":{}}],["find_ts_and_vys_for_y(i",{"_index":2059,"title":{},"name":{},"text":{"18":{}},"component":{}}],["find_velocities(t",{"_index":2015,"title":{},"name":{},"text":{"18":{}},"component":{}}],["finish",{"_index":3090,"title":{},"name":{},"text":{"24":{}},"component":{}}],["finit",{"_index":2116,"title":{},"name":{},"text":{"18":{},"21":{}},"component":{}}],["fire",{"_index":1965,"title":{},"name":{},"text":{"18":{}},"component":{}}],["first",{"_index":417,"title":{},"name":{},"text":{"4":{},"6":{},"9":{},"13":{},"15":{},"17":{},"18":{},"19":{},"20":{},"22":{},"23":{}},"component":{}}],["first.borrow",{"_index":2540,"title":{},"name":{},"text":{"20":{}},"component":{}}],["first.candidates_for_merge(",{"_index":2547,"title":{},"name":{},"text":{"20":{}},"component":{}}],["first.clon",{"_index":2543,"title":{},"name":{},"text":{"20":{}},"component":{}}],["first.merged_with(&transformed_scann",{"_index":2549,"title":{},"name":{},"text":{"20":{}},"component":{}}],["first_digit",{"_index":3195,"title":{},"name":{},"text":{"25":{}},"component":{}}],["first_lin",{"_index":448,"title":{},"name":{},"text":{"4":{},"16":{}},"component":{}}],["first_line.char",{"_index":1675,"title":{},"name":{},"text":{"16":{}},"component":{}}],["first_line.len",{"_index":451,"title":{},"name":{},"text":{"4":{}},"component":{}}],["first_po",{"_index":1603,"title":{},"name":{},"text":{"15":{}},"component":{}}],["first_pos)).or_default",{"_index":1606,"title":{},"name":{},"text":{"15":{}},"component":{}}],["fit",{"_index":2381,"title":{},"name":{},"text":{"20":{}},"component":{}}],["five",{"_index":917,"title":{},"name":{},"text":{"9":{}},"component":{}}],["fix",{"_index":790,"title":{},"name":{},"text":{"8":{},"14":{},"17":{}},"component":{}}],["flash",{"_index":1277,"title":{},"name":{},"text":{"12":{}},"component":{}}],["flash_thresh",{"_index":1276,"title":{},"name":{},"text":{"12":{}},"component":{}}],["flash_thresh).then_some(idx",{"_index":1287,"title":{},"name":{},"text":{"12":{}},"component":{}}],["flashing_octopi_idx",{"_index":1284,"title":{},"name":{},"text":{"12":{}},"component":{}}],["flashing_octopi_idxs.is_empti",{"_index":1288,"title":{},"name":{},"text":{"12":{}},"component":{}}],["flashing_octopi_idxs.len",{"_index":1289,"title":{},"name":{},"text":{"12":{}},"component":{}}],["flat",{"_index":2361,"title":{},"name":{},"text":{"19":{}},"component":{}}],["flat_map(|lin",{"_index":2620,"title":{},"name":{},"text":{"21":{}},"component":{}}],["flat_map(|piec",{"_index":2887,"title":{},"name":{},"text":{"23":{}},"component":{}}],["flat_map(|r",{"_index":1172,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["flatten",{"_index":2075,"title":{},"name":{},"text":{"18":{}},"component":{}}],["flavor",{"_index":1777,"title":{},"name":{},"text":{"17":{}},"component":{}}],["flip(self",{"_index":1216,"title":{},"name":{},"text":{"11":{}},"component":{}}],["floor",{"_index":1559,"title":{},"name":{},"text":{"15":{}},"component":{}}],["fmt(&self",{"_index":168,"title":{},"name":{},"text":{"1":{},"14":{},"19":{},"21":{},"23":{},"24":{},"26":{}},"component":{}}],["fmt::display",{"_index":1506,"title":{},"name":{},"text":{"14":{}},"component":{}}],["fmt::write",{"_index":2943,"title":{},"name":{},"text":{"24":{},"26":{}},"component":{}}],["fn",{"_index":167,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["fn(&mut",{"_index":2293,"title":{},"name":{},"text":{"19":{}},"component":{}}],["fn(bool",{"_index":977,"title":{},"name":{},"text":{"9":{}},"component":{}}],["fn(digit",{"_index":1014,"title":{},"name":{},"text":{"9":{}},"component":{}}],["fn(num",{"_index":3197,"title":{},"name":{},"text":{"25":{}},"component":{}}],["fn(usiz",{"_index":485,"title":{},"name":{},"text":{"4":{}},"component":{}}],["fnonce(&mut",{"_index":3137,"title":{},"name":{},"text":{"25":{}},"component":{}}],["fold",{"_index":1419,"title":{},"name":{},"text":{"14":{}},"component":{}}],["fold(0",{"_index":2890,"title":{},"name":{},"text":{"23":{}},"component":{}}],["fold.borrow",{"_index":1465,"title":{},"name":{},"text":{"14":{}},"component":{}}],["fold::x(fold_x",{"_index":1448,"title":{},"name":{},"text":{"14":{}},"component":{}}],["fold::y(fold_i",{"_index":1452,"title":{},"name":{},"text":{"14":{}},"component":{}}],["fold_eqn",{"_index":1437,"title":{},"name":{},"text":{"14":{}},"component":{}}],["fold_eqn.split",{"_index":1439,"title":{},"name":{},"text":{"14":{}},"component":{}}],["fold_i",{"_index":1454,"title":{},"name":{},"text":{"14":{}},"component":{}}],["fold_x",{"_index":1450,"title":{},"name":{},"text":{"14":{}},"component":{}}],["folded(&self",{"_index":1446,"title":{},"name":{},"text":{"14":{}},"component":{}}],["folded_across(&self",{"_index":1458,"title":{},"name":{},"text":{"14":{}},"component":{}}],["folds.iter()))).into",{"_index":1480,"title":{},"name":{},"text":{"14":{}},"component":{}}],["folds[0",{"_index":1478,"title":{},"name":{},"text":{"14":{}},"component":{}}],["follow",{"_index":886,"title":{},"name":{},"text":{"9":{},"10":{},"17":{},"18":{},"19":{}},"component":{}}],["for_col(col",{"_index":2957,"title":{},"name":{},"text":{"24":{}},"component":{}}],["forc",{"_index":1958,"title":{},"name":{},"text":{"18":{}},"component":{}}],["foremost",{"_index":2121,"title":{},"name":{},"text":{"18":{}},"component":{}}],["forev",{"_index":1335,"title":{},"name":{},"text":{"13":{},"17":{},"18":{}},"component":{}}],["form",{"_index":656,"title":{},"name":{},"text":{"6":{},"16":{},"20":{}},"component":{}}],["former",{"_index":1671,"title":{},"name":{},"text":{"16":{}},"component":{}}],["forth",{"_index":1334,"title":{},"name":{},"text":{"13":{}},"component":{}}],["forward",{"_index":290,"title":{},"name":{},"text":{"1":{},"3":{}},"component":{}}],["found",{"_index":736,"title":{},"name":{},"text":{"6":{},"19":{}},"component":{}}],["four",{"_index":1666,"title":{},"name":{},"text":{"16":{},"19":{},"20":{},"25":{}},"component":{}}],["frac",{"_index":2111,"title":{},"name":{},"text":{"18":{}},"component":{}}],["frac{1}{2}(k_1+k_2",{"_index":2134,"title":{},"name":{},"text":{"18":{}},"component":{}}],["frac{1}{2}t(t",{"_index":2090,"title":{},"name":{},"text":{"18":{}},"component":{}}],["frac{1}{2}v_x(v_x+1)&t",{"_index":2093,"title":{},"name":{},"text":{"18":{}},"component":{}}],["frac{1}{2}v_y(v_y+1",{"_index":2147,"title":{},"name":{},"text":{"18":{}},"component":{}}],["frac{27}{7",{"_index":2686,"title":{},"name":{},"text":{"22":{}},"component":{}}],["frac{2x+t(t",{"_index":2109,"title":{},"name":{},"text":{"18":{}},"component":{}}],["frac{n(n+1)}{2",{"_index":853,"title":{},"name":{},"text":{"8":{}},"component":{}}],["friendli",{"_index":1717,"title":{},"name":{},"text":{"16":{}},"component":{}}],["from((day",{"_index":178,"title":{},"name":{},"text":{"1":{}},"component":{}}],["from(axi",{"_index":2468,"title":{},"name":{},"text":{"20":{}},"component":{}}],["from(digit",{"_index":993,"title":{},"name":{},"text":{"9":{}},"component":{}}],["from(n",{"_index":989,"title":{},"name":{},"text":{"9":{},"17":{}},"component":{}}],["from(swivel",{"_index":2501,"title":{},"name":{},"text":{"20":{}},"component":{}}],["from(transl",{"_index":2503,"title":{},"name":{},"text":{"20":{}},"component":{}}],["from_char(c",{"_index":1217,"title":{},"name":{},"text":{"11":{},"24":{}},"component":{}}],["from_col",{"_index":1684,"title":{},"name":{},"text":{"16":{}},"component":{}}],["from_cols(x",{"_index":2425,"title":{},"name":{},"text":{"20":{}},"component":{}}],["from_coords_str(",{"_index":2852,"title":{},"name":{},"text":{"23":{}},"component":{}}],["from_dots(dot",{"_index":1455,"title":{},"name":{},"text":{"14":{}},"component":{}}],["from_hex(",{"_index":1797,"title":{},"name":{},"text":{"17":{}},"component":{}}],["from_line(lin",{"_index":2161,"title":{},"name":{},"text":{"19":{},"23":{}},"component":{}}],["from_row",{"_index":1683,"title":{},"name":{},"text":{"16":{}},"component":{}}],["from_running_block_on",{"_index":3136,"title":{},"name":{},"text":{"25":{}},"component":{}}],["from_str(",{"_index":377,"title":{},"name":{},"text":{"3":{},"5":{},"9":{},"12":{},"14":{},"15":{},"21":{},"23":{},"24":{},"25":{}},"component":{}}],["from_str(input",{"_index":1360,"title":{},"name":{},"text":{"13":{},"19":{},"26":{}},"component":{}}],["from_usize(n",{"_index":2956,"title":{},"name":{},"text":{"24":{}},"component":{}}],["ft_name",{"_index":127,"title":{},"name":{},"text":{"1":{}},"component":{}}],["full",{"_index":923,"title":{},"name":{},"text":{"9":{},"14":{}},"component":{}}],["fun",{"_index":284,"title":{},"name":{},"text":{"1":{},"14":{},"18":{}},"component":{}}],["function",{"_index":88,"title":{},"name":{},"text":{"1":{},"4":{},"6":{},"9":{},"17":{},"19":{},"20":{}},"component":{}}],["further",{"_index":1745,"title":{},"name":{},"text":{"16":{}},"component":{}}],["g",{"_index":990,"title":{},"name":{},"text":{"9":{}},"component":{}}],["game",{"_index":522,"title":{},"name":{},"text":{"5":{},"22":{}},"component":{}}],["game.board",{"_index":628,"title":{},"name":{},"text":{"5":{}},"component":{}}],["game.boards.iter_mut().enumer",{"_index":637,"title":{},"name":{},"text":{"5":{}},"component":{}}],["game.numb",{"_index":627,"title":{},"name":{},"text":{"5":{}},"component":{}}],["game1",{"_index":620,"title":{},"name":{},"text":{"5":{}},"component":{}}],["game2",{"_index":621,"title":{},"name":{},"text":{"5":{}},"component":{}}],["game::from_str(input).unwrap",{"_index":623,"title":{},"name":{},"text":{"5":{}},"component":{}}],["gamma_r",{"_index":479,"title":{},"name":{},"text":{"4":{}},"component":{}}],["garbl",{"_index":930,"title":{},"name":{},"text":{"9":{}},"component":{}}],["garbled1",{"_index":1018,"title":{},"name":{},"text":{"9":{}},"component":{}}],["garbled2",{"_index":1021,"title":{},"name":{},"text":{"9":{}},"component":{}}],["garbled2).n_on",{"_index":1058,"title":{},"name":{},"text":{"9":{}},"component":{}}],["garbled_digit",{"_index":999,"title":{},"name":{},"text":{"9":{}},"component":{}}],["garden",{"_index":3241,"title":{},"name":{},"text":{"26":{}},"component":{}}],["garden.run_until_no_mov",{"_index":3246,"title":{},"name":{},"text":{"26":{}},"component":{}}],["gd",{"_index":1006,"title":{},"name":{},"text":{"9":{}},"component":{}}],["gd.borrow",{"_index":1007,"title":{},"name":{},"text":{"9":{}},"component":{}}],["ge",{"_index":2094,"title":{},"name":{},"text":{"18":{}},"component":{}}],["gener",{"_index":82,"title":{},"name":{},"text":{"1":{},"15":{},"24":{}},"component":{}}],["get",{"_index":1112,"title":{},"name":{},"text":{"9":{}},"component":{}}],["get(&[row",{"_index":3055,"title":{},"name":{},"text":{"24":{}},"component":{}}],["get_an",{"_index":400,"title":{},"name":{},"text":{"3":{}},"component":{}}],["get_ans(&all_count",{"_index":718,"title":{},"name":{},"text":{"6":{}},"component":{}}],["get_ans(&get_hv_point_counts(endpoint",{"_index":707,"title":{},"name":{},"text":{"6":{}},"component":{}}],["get_ans(&self",{"_index":370,"title":{},"name":{},"text":{"3":{},"5":{}},"component":{}}],["get_ans(polym",{"_index":1610,"title":{},"name":{},"text":{"15":{}},"component":{}}],["get_answer_from_final_game_st",{"_index":564,"title":{},"name":{},"text":{"5":{}},"component":{}}],["get_diag_point_counts(endpoint",{"_index":708,"title":{},"name":{},"text":{"6":{}},"component":{}}],["get_hv_point_counts(endpoint",{"_index":699,"title":{},"name":{},"text":{"6":{}},"component":{}}],["get_initial_char_pair_counts(&self",{"_index":1589,"title":{},"name":{},"text":{"15":{}},"component":{}}],["get_lines(input",{"_index":677,"title":{},"name":{},"text":{"6":{}},"component":{}}],["get_lines(input).unwrap",{"_index":695,"title":{},"name":{},"text":{"6":{}},"component":{}}],["get_mapping_from_garbled_digit",{"_index":998,"title":{},"name":{},"text":{"9":{}},"component":{}}],["get_mapping_from_garbled_digits(in_digits).ok",{"_index":1088,"title":{},"name":{},"text":{"9":{}},"component":{}}],["get_n_increasing_running_sum_of_depths(input",{"_index":329,"title":{},"name":{},"text":{"2":{}},"component":{}}],["get_neighbor_idx",{"_index":1136,"title":{},"name":{},"text":{"10":{}},"component":{}}],["get_neighbor_idxs(idx",{"_index":1158,"title":{},"name":{},"text":{"10":{}},"component":{}}],["get_next_digit",{"_index":3199,"title":{},"name":{},"text":{"25":{}},"component":{}}],["get_spans(my_span",{"_index":2797,"title":{},"name":{},"text":{"23":{}},"component":{}}],["get_spans(self.x_rang",{"_index":2810,"title":{},"name":{},"text":{"23":{}},"component":{}}],["get_spans(self.y_rang",{"_index":2812,"title":{},"name":{},"text":{"23":{}},"component":{}}],["get_spans(self.z_rang",{"_index":2814,"title":{},"name":{},"text":{"23":{}},"component":{}}],["get_trajectories(rect",{"_index":2047,"title":{},"name":{},"text":{"18":{}},"component":{}}],["get_valid_zs(&block",{"_index":3157,"title":{},"name":{},"text":{"25":{}},"component":{}}],["get_valid_zs(block",{"_index":3162,"title":{},"name":{},"text":{"25":{}},"component":{}}],["get_x(t",{"_index":2051,"title":{},"name":{},"text":{"18":{}},"component":{}}],["gggg",{"_index":893,"title":{},"name":{},"text":{"9":{}},"component":{}}],["giant",{"_index":221,"title":{"5":{}},"name":{},"text":{"1":{}},"component":{}}],["gibberish",{"_index":904,"title":{},"name":{},"text":{"9":{}},"component":{}}],["give",{"_index":13,"title":{},"name":{},"text":{"1":{},"18":{},"20":{},"25":{}},"component":{}}],["given",{"_index":28,"title":{},"name":{},"text":{"1":{},"4":{},"5":{},"15":{},"16":{},"18":{},"20":{},"21":{},"24":{}},"component":{}}],["global",{"_index":880,"title":{},"name":{},"text":{"8":{}},"component":{}}],["go",{"_index":364,"title":{},"name":{},"text":{"3":{},"17":{},"20":{},"24":{}},"component":{}}],["good_digit1",{"_index":1032,"title":{},"name":{},"text":{"9":{}},"component":{}}],["good_digit2",{"_index":1033,"title":{},"name":{},"text":{"9":{}},"component":{}}],["goosey",{"_index":65,"title":{},"name":{},"text":{"1":{}},"component":{}}],["gracefulli",{"_index":77,"title":{},"name":{},"text":{"1":{}},"component":{}}],["graph",{"_index":1311,"title":{},"name":{},"text":{"13":{},"24":{}},"component":{}}],["graviti",{"_index":1976,"title":{},"name":{},"text":{"18":{}},"component":{}}],["greater",{"_index":300,"title":{},"name":{},"text":{"2":{},"12":{}},"component":{}}],["grid",{"_index":528,"title":{},"name":{},"text":{"5":{},"16":{},"23":{},"24":{}},"component":{}}],["grid).ok",{"_index":1680,"title":{},"name":{},"text":{"16":{}},"component":{}}],["grid.apply_step(step.borrow",{"_index":2897,"title":{},"name":{},"text":{"23":{}},"component":{}}],["grid.dim",{"_index":1687,"title":{},"name":{},"text":{"16":{}},"component":{}}],["grid.insert(x",{"_index":591,"title":{},"name":{},"text":{"5":{}},"component":{}}],["grid.len",{"_index":1677,"title":{},"name":{},"text":{"16":{}},"component":{}}],["grid.n_on",{"_index":2898,"title":{},"name":{},"text":{"23":{}},"component":{}}],["grid.push(c.to_digit(10",{"_index":1676,"title":{},"name":{},"text":{"16":{}},"component":{}}],["grid::from_shape_simple_fn((n_row",{"_index":1696,"title":{},"name":{},"text":{"16":{}},"component":{}}],["grid::new_unbound",{"_index":2899,"title":{},"name":{},"text":{"23":{}},"component":{}}],["grid::new_with_size(50",{"_index":2896,"title":{},"name":{},"text":{"23":{}},"component":{}}],["grid[(inner_r",{"_index":1724,"title":{},"name":{},"text":{"16":{}},"component":{}}],["grid’",{"_index":1632,"title":{},"name":{},"text":{"16":{}},"component":{}}],["grouped_by_n_on",{"_index":1000,"title":{},"name":{},"text":{"9":{}},"component":{}}],["grouped_by_n_on[&gd.n_on",{"_index":1009,"title":{},"name":{},"text":{"9":{}},"component":{}}],["grow",{"_index":2608,"title":{},"name":{},"text":{"21":{}},"component":{}}],["grown_mat",{"_index":2630,"title":{},"name":{},"text":{"21":{}},"component":{}}],["grown_mat[[r",{"_index":2644,"title":{},"name":{},"text":{"21":{}},"component":{}}],["gt",{"_index":1891,"title":{},"name":{},"text":{"17":{}},"component":{}}],["guess",{"_index":1562,"title":{},"name":{},"text":{"15":{}},"component":{}}],["guesswork",{"_index":1578,"title":{},"name":{},"text":{"15":{}},"component":{}}],["h",{"_index":368,"title":{},"name":{},"text":{"3":{},"24":{}},"component":{}}],["hack",{"_index":1852,"title":{},"name":{},"text":{"17":{}},"component":{}}],["half",{"_index":838,"title":{},"name":{},"text":{"8":{},"15":{},"20":{}},"component":{}}],["hallway",{"_index":2925,"title":{},"name":{},"text":{"24":{}},"component":{}}],["hallway_row",{"_index":3031,"title":{},"name":{},"text":{"24":{}},"component":{}}],["hallway_row..curr_row",{"_index":3072,"title":{},"name":{},"text":{"24":{}},"component":{}}],["halv",{"_index":1561,"title":{},"name":{},"text":{"15":{}},"component":{}}],["hand",{"_index":2484,"title":{},"name":{},"text":{"20":{},"24":{}},"component":{}}],["handl",{"_index":46,"title":{},"name":{},"text":{"1":{},"13":{}},"component":{}}],["handle_entry(&mut",{"_index":579,"title":{},"name":{},"text":{"5":{}},"component":{}}],["happen",{"_index":1430,"title":{},"name":{},"text":{"14":{}},"component":{}}],["hard",{"_index":1759,"title":{},"name":{},"text":{"17":{},"18":{}},"component":{}}],["has_visited_a_small_cave_twic",{"_index":1374,"title":{},"name":{},"text":{"13":{}},"component":{}}],["has_won",{"_index":575,"title":{},"name":{},"text":{"5":{}},"component":{}}],["has_won(&self",{"_index":598,"title":{},"name":{},"text":{"5":{}},"component":{}}],["hash",{"_index":671,"title":{},"name":{},"text":{"6":{},"24":{}},"component":{}}],["hashbrown::hash_map::defaulthashbuild",{"_index":2941,"title":{},"name":{},"text":{"24":{}},"component":{}}],["hasher",{"_index":1657,"title":{},"name":{},"text":{"16":{}},"component":{}}],["hashmap",{"_index":1649,"title":{},"name":{},"text":{"16":{}},"component":{}}],["hasn't",{"_index":1859,"title":{},"name":{},"text":{"17":{}},"component":{}}],["have",{"_index":932,"title":{},"name":{},"text":{"9":{}},"component":{}}],["haven’t",{"_index":539,"title":{},"name":{},"text":{"5":{}},"component":{}}],["head",{"_index":1772,"title":{},"name":{},"text":{"17":{}},"component":{}}],["header_length",{"_index":1814,"title":{},"name":{},"text":{"17":{}},"component":{}}],["heap",{"_index":2937,"title":{},"name":{},"text":{"24":{}},"component":{}}],["heavi",{"_index":2413,"title":{},"name":{},"text":{"20":{}},"component":{}}],["height",{"_index":1139,"title":{},"name":{},"text":{"10":{},"12":{},"18":{},"24":{},"26":{}},"component":{}}],["heightmap",{"_index":1134,"title":{},"name":{},"text":{"10":{}},"component":{}}],["heightmap::from_str(input).unwrap",{"_index":1150,"title":{},"name":{},"text":{"10":{}},"component":{}}],["help",{"_index":662,"title":{},"name":{},"text":{"6":{},"18":{}},"component":{}}],["henc",{"_index":2130,"title":{},"name":{},"text":{"18":{}},"component":{}}],["here",{"_index":26,"title":{},"name":{},"text":{"1":{},"3":{},"10":{},"14":{},"17":{},"19":{},"20":{}},"component":{}}],["hex",{"_index":1750,"title":{},"name":{},"text":{"17":{}},"component":{}}],["high",{"_index":745,"title":{},"name":{},"text":{"7":{}},"component":{}}],["hipod_locs_map",{"_index":3003,"title":{},"name":{},"text":{"24":{}},"component":{}}],["hit",{"_index":546,"title":{},"name":{},"text":{"5":{},"18":{}},"component":{}}],["hm",{"_index":1149,"title":{},"name":{},"text":{"10":{}},"component":{}}],["hm.arr[idx",{"_index":1168,"title":{},"name":{},"text":{"10":{}},"component":{}}],["hm.basin_s",{"_index":1191,"title":{},"name":{},"text":{"10":{}},"component":{}}],["hm.idxs_where_lower_than_neighbor",{"_index":1166,"title":{},"name":{},"text":{"10":{}},"component":{}}],["hold",{"_index":907,"title":{},"name":{},"text":{"9":{}},"component":{}}],["holi",{"_index":1953,"title":{},"name":{},"text":{"18":{}},"component":{}}],["hook",{"_index":884,"title":{},"name":{},"text":{"9":{}},"component":{}}],["hope",{"_index":2115,"title":{},"name":{},"text":{"18":{}},"component":{}}],["horizont",{"_index":723,"title":{},"name":{},"text":{"6":{},"14":{}},"component":{}}],["hv_counter",{"_index":713,"title":{},"name":{},"text":{"6":{}},"component":{}}],["hydrotherm",{"_index":223,"title":{"6":{}},"name":{},"text":{"1":{}},"component":{}}],["i+1",{"_index":2154,"title":{},"name":{},"text":{"19":{}},"component":{}}],["i.",{"_index":322,"title":{},"name":{},"text":{"2":{},"5":{},"8":{},"11":{},"14":{},"17":{},"20":{}},"component":{}}],["i2",{"_index":2202,"title":{},"name":{},"text":{"19":{}},"component":{}}],["i32",{"_index":369,"title":{},"name":{},"text":{"3":{},"5":{},"6":{},"20":{},"23":{},"25":{}},"component":{}}],["i64",{"_index":1795,"title":{},"name":{},"text":{"17":{},"18":{}},"component":{}}],["i64::from(match",{"_index":1894,"title":{},"name":{},"text":{"17":{}},"component":{}}],["i64::try_from(to_big_decimal(bin_bits)).unwrap",{"_index":1841,"title":{},"name":{},"text":{"17":{}},"component":{}}],["ident",{"_index":1012,"title":{},"name":{},"text":{"9":{},"20":{},"21":{}},"component":{}}],["identity(&self",{"_index":1884,"title":{},"name":{},"text":{"17":{}},"component":{}}],["idod",{"_index":1087,"title":{},"name":{},"text":{"9":{}},"component":{}}],["idx",{"_index":1154,"title":{},"name":{},"text":{"10":{},"12":{},"19":{}},"component":{}}],["idx_pair",{"_index":1159,"title":{},"name":{},"text":{"10":{}},"component":{}}],["idxs.push([r",{"_index":1164,"title":{},"name":{},"text":{"10":{}},"component":{}}],["ignor",{"_index":2391,"title":{},"name":{},"text":{"20":{}},"component":{}}],["im",{"_index":2658,"title":{},"name":{},"text":{"21":{}},"component":{}}],["im.mat.map(|&bit",{"_index":2660,"title":{},"name":{},"text":{"21":{}},"component":{}}],["im.tick_n_times(2",{"_index":2659,"title":{},"name":{},"text":{"21":{}},"component":{}}],["im.tick_n_times(50",{"_index":2663,"title":{},"name":{},"text":{"21":{}},"component":{}}],["im1",{"_index":2651,"title":{},"name":{},"text":{"21":{}},"component":{}}],["im1.clon",{"_index":2654,"title":{},"name":{},"text":{"21":{}},"component":{}}],["im2",{"_index":2653,"title":{},"name":{},"text":{"21":{}},"component":{}}],["imag",{"_index":2610,"title":{},"name":{},"text":{"21":{}},"component":{}}],["image::from_str(input).unwrap",{"_index":2652,"title":{},"name":{},"text":{"21":{}},"component":{}}],["immedi",{"_index":1204,"title":{},"name":{},"text":{"11":{}},"component":{}}],["impl",{"_index":166,"title":{},"name":{},"text":{"1":{},"3":{},"4":{},"5":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["implement",{"_index":562,"title":{},"name":{},"text":{"5":{},"7":{},"16":{},"17":{},"18":{},"25":{}},"component":{}}],["implicitli",{"_index":51,"title":{},"name":{},"text":{"1":{}},"component":{}}],["import",{"_index":1978,"title":{},"name":{},"text":{"18":{},"23":{}},"component":{}}],["imposs",{"_index":2143,"title":{},"name":{},"text":{"18":{}},"component":{}}],["improv",{"_index":2678,"title":{},"name":{},"text":{"22":{}},"component":{}}],["in_digit",{"_index":1082,"title":{},"name":{},"text":{"9":{}},"component":{}}],["in_out",{"_index":1080,"title":{},"name":{},"text":{"9":{}},"component":{}}],["in_out_lin",{"_index":1092,"title":{},"name":{},"text":{"9":{}},"component":{}}],["in_reg",{"_index":3127,"title":{},"name":{},"text":{"25":{}},"component":{}}],["includ",{"_index":1408,"title":{},"name":{},"text":{"13":{},"18":{}},"component":{}}],["include_day",{"_index":124,"title":{},"name":{},"text":{"1":{}},"component":{}}],["include_str!(\"input.txt",{"_index":698,"title":{},"name":{},"text":{"6":{},"14":{}},"component":{}}],["inclus",{"_index":666,"title":{},"name":{},"text":{"6":{},"7":{},"10":{}},"component":{}}],["incom",{"_index":318,"title":{},"name":{},"text":{"2":{}},"component":{}}],["incomplet",{"_index":1208,"title":{},"name":{},"text":{"11":{}},"component":{}}],["incomplete(vec",{"_index":1221,"title":{},"name":{},"text":{"11":{}},"component":{}}],["incorrectli",{"_index":883,"title":{},"name":{},"text":{"9":{}},"component":{}}],["increment",{"_index":1790,"title":{},"name":{},"text":{"17":{},"19":{}},"component":{}}],["inde",{"_index":2132,"title":{},"name":{},"text":{"18":{}},"component":{}}],["index",{"_index":7,"title":{},"name":{"1":{}},"text":{"4":{},"15":{},"19":{},"20":{},"21":{},"24":{},"25":{}},"component":{}}],["index(&self",{"_index":2460,"title":{},"name":{},"text":{"20":{},"24":{},"25":{}},"component":{}}],["index_for(am",{"_index":2965,"title":{},"name":{},"text":{"24":{}},"component":{}}],["index_mut(&mut",{"_index":2974,"title":{},"name":{},"text":{"24":{},"25":{}},"component":{}}],["indexmut",{"_index":3115,"title":{},"name":{},"text":{"25":{}},"component":{}}],["indic",{"_index":549,"title":{},"name":{},"text":{"5":{},"19":{}},"component":{}}],["individu",{"_index":2903,"title":{},"name":{},"text":{"23":{}},"component":{}}],["infeas",{"_index":1528,"title":{},"name":{},"text":{"15":{},"22":{},"24":{}},"component":{}}],["infinit",{"_index":1331,"title":{},"name":{},"text":{"13":{},"18":{},"21":{}},"component":{}}],["inform",{"_index":939,"title":{},"name":{},"text":{"9":{}},"component":{}}],["ingest",{"_index":1337,"title":{},"name":{},"text":{"13":{}},"component":{}}],["initi",{"_index":765,"title":{},"name":{},"text":{"7":{},"15":{},"16":{},"18":{},"24":{},"25":{}},"component":{}}],["initial_loc",{"_index":3019,"title":{},"name":{},"text":{"24":{}},"component":{}}],["initial_st",{"_index":3035,"title":{},"name":{},"text":{"24":{}},"component":{}}],["inner",{"_index":1585,"title":{},"name":{},"text":{"15":{}},"component":{}}],["inner_c",{"_index":1722,"title":{},"name":{},"text":{"16":{}},"component":{}}],["inner_r",{"_index":1720,"title":{},"name":{},"text":{"16":{}},"component":{}}],["inordin",{"_index":1644,"title":{},"name":{},"text":{"16":{}},"component":{}}],["inp",{"_index":3146,"title":{},"name":{},"text":{"25":{}},"component":{}}],["input",{"_index":17,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["input.lin",{"_index":445,"title":{},"name":{},"text":{"4":{},"13":{},"14":{},"16":{}},"component":{}}],["input.lines().enumer",{"_index":3223,"title":{},"name":{},"text":{"26":{}},"component":{}}],["input.lines().map(|lin",{"_index":333,"title":{},"name":{},"text":{"2":{}},"component":{}}],["input/output",{"_index":34,"title":{},"name":{},"text":{"1":{}},"component":{}}],["input:expr",{"_index":183,"title":{},"name":{},"text":{"1":{}},"component":{}}],["insert",{"_index":1519,"title":{},"name":{},"text":{"15":{}},"component":{}}],["insert(digit",{"_index":1005,"title":{},"name":{},"text":{"9":{}},"component":{}}],["insid",{"_index":2920,"title":{},"name":{},"text":{"24":{}},"component":{}}],["instanc",{"_index":909,"title":{},"name":{},"text":{"9":{},"18":{},"23":{},"25":{}},"component":{}}],["instantiatedburrow",{"_index":2979,"title":{},"name":{},"text":{"24":{}},"component":{}}],["instantiatedburrow::::from_str(include_str!(\"input_1.txt\")).unwrap",{"_index":3093,"title":{},"name":{},"text":{"24":{}},"component":{}}],["instantiatedburrow::::from_str(include_str!(\"input_2.txt\")).unwrap",{"_index":3095,"title":{},"name":{},"text":{"24":{}},"component":{}}],["instead",{"_index":1650,"title":{},"name":{},"text":{"16":{}},"component":{}}],["instr",{"_index":3128,"title":{},"name":{},"text":{"25":{}},"component":{}}],["instr_str",{"_index":3145,"title":{},"name":{},"text":{"25":{}},"component":{}}],["instrblock",{"_index":3126,"title":{},"name":{},"text":{"25":{}},"component":{}}],["instruct",{"_index":3111,"title":{},"name":{},"text":{"25":{}},"component":{}}],["int",{"_index":748,"title":{},"name":{},"text":{"7":{}},"component":{}}],["integ",{"_index":567,"title":{},"name":{},"text":{"5":{},"6":{},"7":{},"8":{},"14":{},"15":{},"18":{},"23":{},"24":{},"25":{}},"component":{}}],["integr",{"_index":2033,"title":{},"name":{},"text":{"18":{}},"component":{}}],["interchang",{"_index":791,"title":{},"name":{},"text":{"8":{}},"component":{}}],["interest",{"_index":561,"title":{},"name":{},"text":{"5":{},"9":{},"12":{},"14":{},"26":{}},"component":{}}],["interesting",{"_index":1270,"title":{},"name":{},"text":{"12":{}},"component":{}}],["interfac",{"_index":1951,"title":{},"name":{},"text":{"17":{}},"component":{}}],["interior",{"_index":312,"title":{},"name":{},"text":{"2":{},"21":{}},"component":{}}],["intersect",{"_index":935,"title":{},"name":{},"text":{"9":{},"20":{},"23":{}},"component":{}}],["intersection(&self",{"_index":2791,"title":{},"name":{},"text":{"23":{}},"component":{}}],["intersection(&transformed_other.beacon",{"_index":2531,"title":{},"name":{},"text":{"20":{}},"component":{}}],["intersection.x_rang",{"_index":2811,"title":{},"name":{},"text":{"23":{}},"component":{}}],["intersection.y_rang",{"_index":2813,"title":{},"name":{},"text":{"23":{}},"component":{}}],["intersection.z_rang",{"_index":2815,"title":{},"name":{},"text":{"23":{}},"component":{}}],["intersection_span",{"_index":2798,"title":{},"name":{},"text":{"23":{}},"component":{}}],["intersection_span[0",{"_index":2801,"title":{},"name":{},"text":{"23":{}},"component":{}}],["intersection_span[1",{"_index":2805,"title":{},"name":{},"text":{"23":{}},"component":{}}],["into_it",{"_index":506,"title":{},"name":{},"text":{"4":{},"9":{},"10":{},"15":{},"23":{}},"component":{}}],["into_shape((n_col",{"_index":478,"title":{},"name":{},"text":{"4":{}},"component":{}}],["intoiter",{"_index":1456,"title":{},"name":{},"text":{"14":{}},"component":{}}],["intoiterator>(lin",{"_index":2175,"title":{},"name":{},"text":{"19":{}},"component":{}}],["involv",{"_index":1522,"title":{},"name":{},"text":{"15":{}},"component":{}}],["is_don",{"_index":3023,"title":{},"name":{},"text":{"24":{}},"component":{}}],["is_empty(&self",{"_index":1808,"title":{},"name":{},"text":{"17":{}},"component":{}}],["is_lower_than_neighbors(&self",{"_index":1153,"title":{},"name":{},"text":{"10":{}},"component":{}}],["is_on",{"_index":202,"title":{},"name":{},"text":{"1":{}},"component":{}}],["is_p0s_turn",{"_index":2722,"title":{},"name":{},"text":{"22":{}},"component":{}}],["is_smal",{"_index":1354,"title":{},"name":{},"text":{"13":{}},"component":{}}],["is_small_cav",{"_index":1380,"title":{},"name":{},"text":{"13":{}},"component":{}}],["isn’t",{"_index":360,"title":{},"name":{},"text":{"3":{},"11":{},"13":{},"17":{},"24":{}},"component":{}}],["it'",{"_index":2056,"title":{},"name":{},"text":{"18":{},"20":{},"25":{}},"component":{}}],["iter",{"_index":198,"title":{},"name":{},"text":{"1":{},"3":{},"4":{},"6":{},"8":{},"9":{},"11":{},"13":{},"14":{},"15":{},"16":{},"18":{},"19":{},"22":{},"23":{},"24":{}},"component":{}}],["iter_item",{"_index":3007,"title":{},"name":{},"text":{"24":{}},"component":{}}],["iter_items(&self",{"_index":2969,"title":{},"name":{},"text":{"24":{}},"component":{}}],["itself",{"_index":872,"title":{},"name":{},"text":{"8":{}},"component":{}}],["it’",{"_index":729,"title":{},"name":{},"text":{"6":{},"8":{},"14":{},"15":{},"18":{},"22":{}},"component":{}}],["j",{"_index":2442,"title":{},"name":{},"text":{"20":{},"23":{}},"component":{}}],["jigsaw",{"_index":2379,"title":{},"name":{},"text":{"20":{}},"component":{}}],["join",{"_index":3207,"title":{},"name":{},"text":{"25":{}},"component":{}}],["k",{"_index":716,"title":{},"name":{},"text":{"6":{},"8":{},"9":{},"15":{},"16":{},"21":{},"23":{},"24":{}},"component":{}}],["k).n_on",{"_index":1072,"title":{},"name":{},"text":{"9":{}},"component":{}}],["k1",{"_index":2041,"title":{},"name":{},"text":{"18":{}},"component":{}}],["k2",{"_index":2044,"title":{},"name":{},"text":{"18":{}},"component":{}}],["k=2",{"_index":2666,"title":{},"name":{},"text":{"21":{}},"component":{}}],["k=50",{"_index":2667,"title":{},"name":{},"text":{"21":{}},"component":{}}],["k\\)th",{"_index":741,"title":{},"name":{},"text":{"6":{}},"component":{}}],["keep",{"_index":310,"title":{},"name":{},"text":{"2":{},"5":{},"9":{},"15":{},"18":{},"24":{}},"component":{}}],["key",{"_index":753,"title":{},"name":{},"text":{"7":{},"9":{},"15":{}},"component":{}}],["kind",{"_index":1352,"title":{},"name":{},"text":{"13":{},"17":{},"20":{},"24":{}},"component":{}}],["kind.to_char",{"_index":3015,"title":{},"name":{},"text":{"24":{}},"component":{}}],["kind_numb",{"_index":1825,"title":{},"name":{},"text":{"17":{}},"component":{}}],["know",{"_index":911,"title":{},"name":{},"text":{"9":{},"11":{},"18":{},"21":{}},"component":{}}],["knowledg",{"_index":797,"title":{},"name":{},"text":{"8":{},"9":{}},"component":{}}],["known",{"_index":868,"title":{},"name":{},"text":{"8":{}},"component":{}}],["l_1",{"_index":836,"title":{},"name":{},"text":{"8":{}},"component":{}}],["l_2",{"_index":866,"title":{},"name":{},"text":{"8":{}},"component":{}}],["l_elem",{"_index":2196,"title":{},"name":{},"text":{"19":{}},"component":{}}],["l_elem.depth",{"_index":2208,"title":{},"name":{},"text":{"19":{}},"component":{}}],["l_elem.valu",{"_index":2211,"title":{},"name":{},"text":{"19":{}},"component":{}}],["l_idx",{"_index":2195,"title":{},"name":{},"text":{"19":{}},"component":{}}],["l_p",{"_index":801,"title":{},"name":{},"text":{"8":{}},"component":{}}],["label",{"_index":888,"title":{},"name":{},"text":{"9":{}},"component":{}}],["land",{"_index":1963,"title":{},"name":{},"text":{"18":{}},"component":{}}],["languag",{"_index":12,"title":{},"name":{},"text":{"1":{}},"component":{}}],["lanternfish",{"_index":226,"title":{"7":{}},"name":{},"text":{"1":{}},"component":{}}],["larg",{"_index":1570,"title":{},"name":{},"text":{"15":{},"18":{},"21":{}},"component":{}}],["larger",{"_index":1645,"title":{},"name":{},"text":{"16":{},"18":{},"20":{},"23":{}},"component":{}}],["last",{"_index":651,"title":{},"name":{},"text":{"5":{},"15":{},"17":{},"24":{},"25":{}},"component":{}}],["later",{"_index":1854,"title":{},"name":{},"text":{"17":{}},"component":{}}],["latter",{"_index":1670,"title":{},"name":{},"text":{"16":{}},"component":{}}],["layer",{"_index":2669,"title":{},"name":{},"text":{"22":{}},"component":{}}],["lazi",{"_index":2939,"title":{},"name":{},"text":{"24":{}},"component":{}}],["ldot",{"_index":2409,"title":{},"name":{},"text":{"20":{}},"component":{}}],["le",{"_index":2092,"title":{},"name":{},"text":{"18":{}},"component":{}}],["lead",{"_index":875,"title":{},"name":{},"text":{"8":{},"25":{}},"component":{}}],["learn",{"_index":285,"title":{},"name":{},"text":{"1":{}},"component":{}}],["leav",{"_index":847,"title":{},"name":{},"text":{"8":{}},"component":{}}],["left",{"_index":1115,"title":{},"name":{},"text":{"9":{},"11":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{}},"component":{}}],["left.magnitud",{"_index":2268,"title":{},"name":{},"text":{"19":{}},"component":{}}],["len",{"_index":827,"title":{},"name":{},"text":{"8":{},"18":{}},"component":{}}],["length",{"_index":304,"title":{},"name":{},"text":{"2":{},"6":{},"9":{},"15":{},"17":{},"22":{}},"component":{}}],["length_typ",{"_index":1845,"title":{},"name":{},"text":{"17":{}},"component":{}}],["less",{"_index":1765,"title":{},"name":{},"text":{"17":{}},"component":{}}],["let",{"_index":2124,"title":{},"name":{},"text":{"18":{}},"component":{}}],["letter",{"_index":1511,"title":{},"name":{},"text":{"14":{}},"component":{}}],["let’",{"_index":2117,"title":{},"name":{},"text":{"18":{}},"component":{}}],["level",{"_index":746,"title":{},"name":{},"text":{"7":{},"17":{},"19":{}},"component":{}}],["lib.r",{"_index":106,"title":{},"name":{},"text":{"1":{}},"component":{}}],["lie",{"_index":1427,"title":{},"name":{},"text":{"14":{}},"component":{}}],["lift",{"_index":2414,"title":{},"name":{},"text":{"20":{}},"component":{}}],["light",{"_index":910,"title":{},"name":{},"text":{"9":{}},"component":{}}],["limit",{"_index":1329,"title":{},"name":{},"text":{"13":{}},"component":{}}],["line",{"_index":444,"title":{},"name":{},"text":{"4":{},"5":{},"6":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"18":{},"19":{},"20":{},"21":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["line.byt",{"_index":454,"title":{},"name":{},"text":{"4":{}},"component":{}}],["line.char",{"_index":1678,"title":{},"name":{},"text":{"16":{}},"component":{}}],["line.chars().count",{"_index":3224,"title":{},"name":{},"text":{"26":{}},"component":{}}],["line.chars().enumer",{"_index":2986,"title":{},"name":{},"text":{"24":{},"26":{}},"component":{}}],["line.is_empti",{"_index":609,"title":{},"name":{},"text":{"5":{},"9":{},"20":{}},"component":{}}],["line.parse::().unwrap",{"_index":334,"title":{},"name":{},"text":{"2":{}},"component":{}}],["line.split",{"_index":1081,"title":{},"name":{},"text":{"9":{},"13":{},"14":{},"15":{},"20":{},"22":{}},"component":{}}],["line.split_ascii_whitespac",{"_index":2868,"title":{},"name":{},"text":{"23":{},"25":{}},"component":{}}],["line.split_whitespac",{"_index":389,"title":{},"name":{},"text":{"3":{}},"component":{}}],["line.split_whitespace().map(|",{"_index":615,"title":{},"name":{},"text":{"5":{}},"component":{}}],["line.starts_with",{"_index":2559,"title":{},"name":{},"text":{"20":{}},"component":{}}],["line.trim",{"_index":1079,"title":{},"name":{},"text":{"9":{},"10":{},"11":{},"12":{}},"component":{}}],["line.trim().char",{"_index":2165,"title":{},"name":{},"text":{"19":{}},"component":{}}],["line.trim().chars().map(|c",{"_index":2621,"title":{},"name":{},"text":{"21":{}},"component":{}}],["line.trim().is_empti",{"_index":1469,"title":{},"name":{},"text":{"14":{}},"component":{}}],["line_length",{"_index":450,"title":{},"name":{},"text":{"4":{}},"component":{}}],["line_r",{"_index":678,"title":{},"name":{},"text":{"6":{}},"component":{}}],["line_re.captures(lin",{"_index":682,"title":{},"name":{},"text":{"6":{}},"component":{}}],["lines.into_it",{"_index":2176,"title":{},"name":{},"text":{"19":{}},"component":{}}],["lines.map(fold::::from_str).collect",{"_index":1474,"title":{},"name":{},"text":{"14":{}},"component":{}}],["lines.next",{"_index":449,"title":{},"name":{},"text":{"4":{},"15":{},"16":{}},"component":{}}],["lines.next()?.to_own",{"_index":1581,"title":{},"name":{},"text":{"15":{}},"component":{}}],["line’",{"_index":726,"title":{},"name":{},"text":{"6":{}},"component":{}}],["list",{"_index":524,"title":{},"name":{},"text":{"5":{},"6":{},"9":{},"13":{},"19":{},"23":{},"25":{}},"component":{}}],["lit",{"_index":898,"title":{},"name":{},"text":{"9":{}},"component":{}}],["liter",{"_index":1874,"title":{},"name":{},"text":{"17":{}},"component":{}}],["littl",{"_index":21,"title":{},"name":{},"text":{"1":{}},"component":{}}],["loc",{"_index":3000,"title":{},"name":{},"text":{"24":{},"26":{}},"component":{}}],["local",{"_index":878,"title":{},"name":{},"text":{"8":{},"10":{},"19":{}},"component":{}}],["locs[am",{"_index":3004,"title":{},"name":{},"text":{"24":{}},"component":{}}],["locs_amphipod",{"_index":3006,"title":{},"name":{},"text":{"24":{}},"component":{}}],["locs_amphipods.get(&[row",{"_index":3008,"title":{},"name":{},"text":{"24":{}},"component":{}}],["logic",{"_index":278,"title":{"25":{}},"name":{},"text":{"1":{},"9":{}},"component":{}}],["long",{"_index":1942,"title":{},"name":{},"text":{"17":{},"24":{}},"component":{}}],["longer",{"_index":863,"title":{},"name":{},"text":{"8":{},"21":{}},"component":{}}],["look",{"_index":289,"title":{},"name":{},"text":{"1":{},"8":{},"9":{},"17":{},"18":{},"20":{},"21":{},"23":{},"25":{}},"component":{}}],["loop",{"_index":1016,"title":{},"name":{},"text":{"9":{},"12":{},"13":{},"16":{},"19":{},"22":{},"23":{}},"component":{}}],["loosey",{"_index":64,"title":{},"name":{},"text":{"1":{}},"component":{}}],["lord",{"_index":1746,"title":{},"name":{},"text":{"17":{}},"component":{}}],["loser",{"_index":2715,"title":{},"name":{},"text":{"22":{}},"component":{}}],["loser.scor",{"_index":2721,"title":{},"name":{},"text":{"22":{}},"component":{}}],["lot",{"_index":283,"title":{},"name":{},"text":{"1":{},"17":{}},"component":{}}],["low",{"_index":751,"title":{},"name":{},"text":{"7":{}},"component":{}}],["lower",{"_index":2794,"title":{},"name":{},"text":{"23":{}},"component":{}}],["lt",{"_index":1892,"title":{},"name":{},"text":{"17":{}},"component":{}}],["m",{"_index":2034,"title":{},"name":{},"text":{"18":{}},"component":{}}],["m.as_str().parse().ok",{"_index":2009,"title":{},"name":{},"text":{"18":{}},"component":{}}],["m.len",{"_index":1065,"title":{},"name":{},"text":{"9":{}},"component":{}}],["m=\\frac{1}{2}(k_1+k_2",{"_index":2129,"title":{},"name":{},"text":{"18":{}},"component":{}}],["m^2",{"_index":2035,"title":{},"name":{},"text":{"18":{}},"component":{}}],["macro_export",{"_index":181,"title":{},"name":{},"text":{"1":{}},"component":{}}],["macro_rul",{"_index":123,"title":{},"name":{},"text":{"1":{}},"component":{}}],["made",{"_index":912,"title":{},"name":{},"text":{"9":{},"16":{}},"component":{}}],["mag1",{"_index":2286,"title":{},"name":{},"text":{"19":{}},"component":{}}],["mag2",{"_index":2288,"title":{},"name":{},"text":{"19":{}},"component":{}}],["magnitud",{"_index":2229,"title":{},"name":{},"text":{"19":{}},"component":{}}],["magnitude(&self",{"_index":2265,"title":{},"name":{},"text":{"19":{}},"component":{}}],["main",{"_index":1766,"title":{},"name":{},"text":{"17":{}},"component":{}}],["maintain",{"_index":1341,"title":{},"name":{},"text":{"13":{},"15":{},"16":{},"17":{},"19":{}},"component":{}}],["major",{"_index":1714,"title":{},"name":{},"text":{"16":{}},"component":{}}],["make",{"_index":20,"title":{},"name":{},"text":{"1":{},"9":{},"11":{},"15":{},"19":{},"24":{}},"component":{}}],["manag",{"_index":1265,"title":{},"name":{},"text":{"12":{}},"component":{}}],["manhattan",{"_index":2592,"title":{},"name":{},"text":{"20":{}},"component":{}}],["manhattan_dist(&self",{"_index":2497,"title":{},"name":{},"text":{"20":{}},"component":{}}],["mani",{"_index":721,"title":{},"name":{},"text":{"6":{},"8":{},"13":{},"18":{},"22":{},"24":{}},"component":{}}],["manifest",{"_index":2363,"title":{},"name":{},"text":{"19":{}},"component":{}}],["manipul",{"_index":1307,"title":{},"name":{},"text":{"13":{},"16":{},"19":{},"21":{},"26":{}},"component":{}}],["manner",{"_index":882,"title":{},"name":{},"text":{"9":{},"18":{},"21":{}},"component":{}}],["map",{"_index":267,"title":{"21":{}},"name":{},"text":{"1":{},"5":{},"6":{},"7":{},"9":{},"13":{},"15":{},"24":{},"25":{}},"component":{}}],["map(digit::from_str",{"_index":1077,"title":{},"name":{},"text":{"9":{}},"component":{}}],["map(player::new",{"_index":2690,"title":{},"name":{},"text":{"22":{}},"component":{}}],["map(rebootstep::from_lin",{"_index":2893,"title":{},"name":{},"text":{"23":{}},"component":{}}],["map(snailnumowned::from_lin",{"_index":2281,"title":{},"name":{},"text":{"19":{}},"component":{}}],["map(token::from_char",{"_index":1241,"title":{},"name":{},"text":{"11":{}},"component":{}}],["map(|",{"_index":606,"title":{},"name":{},"text":{"5":{},"7":{}},"component":{}}],["map(|&(valu",{"_index":2298,"title":{},"name":{},"text":{"19":{}},"component":{}}],["map(|&elem",{"_index":2239,"title":{},"name":{},"text":{"19":{}},"component":{}}],["map(|&n",{"_index":823,"title":{},"name":{},"text":{"8":{}},"component":{}}],["map(|(am",{"_index":3046,"title":{},"name":{},"text":{"24":{}},"component":{}}],["map(|(in_d",{"_index":1094,"title":{},"name":{},"text":{"9":{}},"component":{}}],["map(|(k",{"_index":1067,"title":{},"name":{},"text":{"9":{},"15":{},"24":{}},"component":{}}],["map(|(pow10",{"_index":1106,"title":{},"name":{},"text":{"9":{}},"component":{}}],["map(|(pow2",{"_index":201,"title":{},"name":{},"text":{"1":{}},"component":{}}],["map(|c",{"_index":1143,"title":{},"name":{},"text":{"10":{},"12":{},"21":{}},"component":{}}],["map(|count",{"_index":693,"title":{},"name":{},"text":{"6":{}},"component":{}}],["map(|d",{"_index":1089,"title":{},"name":{},"text":{"9":{}},"component":{}}],["map(|idx",{"_index":1167,"title":{},"name":{},"text":{"10":{}},"component":{}}],["map(|lin",{"_index":387,"title":{},"name":{},"text":{"3":{},"6":{},"11":{},"14":{},"22":{}},"component":{}}],["map(|n",{"_index":805,"title":{},"name":{},"text":{"8":{}},"component":{}}],["map(|traj",{"_index":2067,"title":{},"name":{},"text":{"18":{}},"component":{}}],["map(|v",{"_index":1101,"title":{},"name":{},"text":{"9":{},"11":{}},"component":{}}],["map::new",{"_index":587,"title":{},"name":{},"text":{"5":{},"6":{},"9":{},"13":{},"15":{},"24":{}},"component":{}}],["map_collect(|&candid",{"_index":505,"title":{},"name":{},"text":{"4":{}},"component":{}}],["map_collect(|n_o",{"_index":475,"title":{},"name":{},"text":{"4":{}},"component":{}}],["map_or(tru",{"_index":3056,"title":{},"name":{},"text":{"24":{}},"component":{}}],["mapentri",{"_index":962,"title":{},"name":{},"text":{"9":{}},"component":{}}],["mapentry::occupied(mut",{"_index":1041,"title":{},"name":{},"text":{"9":{}},"component":{}}],["mapentry::vacant(v",{"_index":1039,"title":{},"name":{},"text":{"9":{}},"component":{}}],["mapping.insert((left",{"_index":1587,"title":{},"name":{},"text":{"15":{}},"component":{}}],["mappings.insert(gd",{"_index":1010,"title":{},"name":{},"text":{"9":{}},"component":{}}],["mappings.iter().enumer",{"_index":1020,"title":{},"name":{},"text":{"9":{}},"component":{}}],["mappings.iter().skip(i",{"_index":1023,"title":{},"name":{},"text":{"9":{}},"component":{}}],["mappings.len",{"_index":1063,"title":{},"name":{},"text":{"9":{}},"component":{}}],["mappings.values().all(|m",{"_index":1064,"title":{},"name":{},"text":{"9":{}},"component":{}}],["map’",{"_index":752,"title":{},"name":{},"text":{"7":{}},"component":{}}],["mat",{"_index":461,"title":{},"name":{},"text":{"4":{},"21":{}},"component":{}}],["mat.dim",{"_index":466,"title":{},"name":{},"text":{"4":{}},"component":{}}],["mat.index_axis(axis(0",{"_index":509,"title":{},"name":{},"text":{"4":{}},"component":{}}],["mat.index_axis(axis(1",{"_index":495,"title":{},"name":{},"text":{"4":{}},"component":{}}],["mat.map(|x",{"_index":468,"title":{},"name":{},"text":{"4":{}},"component":{}}],["mat_mul(&self",{"_index":2445,"title":{},"name":{},"text":{"20":{}},"component":{}}],["mat_mul(mat_to_rotate_about_up",{"_index":2490,"title":{},"name":{},"text":{"20":{}},"component":{}}],["mat_to_bring_face_to_up",{"_index":2478,"title":{},"name":{},"text":{"20":{}},"component":{}}],["mat_to_rotate_about_up",{"_index":2486,"title":{},"name":{},"text":{"20":{}},"component":{}}],["match",{"_index":399,"title":{},"name":{},"text":{"3":{},"5":{},"9":{},"10":{},"11":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["matches!(n_col",{"_index":617,"title":{},"name":{},"text":{"5":{}},"component":{}}],["matches!(self",{"_index":1809,"title":{},"name":{},"text":{"17":{}},"component":{}}],["matches!(tiles[[row",{"_index":2998,"title":{},"name":{},"text":{"24":{}},"component":{}}],["math",{"_index":2082,"title":{},"name":{},"text":{"18":{},"20":{}},"component":{}}],["mathemat",{"_index":1983,"title":{},"name":{},"text":{"18":{}},"component":{}}],["mathinstr",{"_index":3125,"title":{},"name":{},"text":{"25":{}},"component":{}}],["mathop",{"_index":3121,"title":{},"name":{},"text":{"25":{}},"component":{}}],["mathop::from_str(instr_str",{"_index":3151,"title":{},"name":{},"text":{"25":{}},"component":{}}],["mathrm{abs}(v_\\mathrm{max",{"_index":1982,"title":{},"name":{},"text":{"18":{}},"component":{}}],["matrix",{"_index":1120,"title":{},"name":{},"text":{"10":{},"20":{}},"component":{}}],["matrix3",{"_index":2424,"title":{},"name":{},"text":{"20":{}},"component":{}}],["matrix3([i32",{"_index":2423,"title":{},"name":{},"text":{"20":{}},"component":{}}],["matrix3::from_cols(negi",{"_index":2489,"title":{},"name":{},"text":{"20":{}},"component":{}}],["matrix3::from_cols(negx",{"_index":2485,"title":{},"name":{},"text":{"20":{}},"component":{}}],["matrix3::from_cols(negz",{"_index":2481,"title":{},"name":{},"text":{"20":{}},"component":{}}],["matrix3::from_cols(posi",{"_index":2488,"title":{},"name":{},"text":{"20":{}},"component":{}}],["matrix3::from_cols(posx",{"_index":2482,"title":{},"name":{},"text":{"20":{}},"component":{}}],["matrix3::from_cols(posz",{"_index":2480,"title":{},"name":{},"text":{"20":{}},"component":{}}],["matrix’",{"_index":1123,"title":{},"name":{},"text":{"10":{}},"component":{}}],["matter",{"_index":2396,"title":{},"name":{},"text":{"20":{}},"component":{}}],["max",{"_index":1636,"title":{},"name":{},"text":{"16":{},"17":{},"22":{}},"component":{}}],["max_col",{"_index":1689,"title":{},"name":{},"text":{"16":{}},"component":{}}],["max_count",{"_index":1619,"title":{},"name":{},"text":{"15":{}},"component":{}}],["max_dist",{"_index":1699,"title":{},"name":{},"text":{"16":{}},"component":{}}],["max_i",{"_index":1484,"title":{},"name":{},"text":{"14":{}},"component":{}}],["max_mag",{"_index":2279,"title":{},"name":{},"text":{"19":{}},"component":{}}],["max_mag.max(mag1).max(mag2",{"_index":2290,"title":{},"name":{},"text":{"19":{}},"component":{}}],["max_manh_dist",{"_index":2575,"title":{},"name":{},"text":{"20":{}},"component":{}}],["max_manh_dist.max(diff.manhattan_dist",{"_index":2585,"title":{},"name":{},"text":{"20":{}},"component":{}}],["max_row",{"_index":1688,"title":{},"name":{},"text":{"16":{}},"component":{}}],["max_sum",{"_index":2731,"title":{},"name":{},"text":{"22":{}},"component":{}}],["max_x",{"_index":1483,"title":{},"name":{},"text":{"14":{}},"component":{}}],["maxim",{"_index":1124,"title":{},"name":{},"text":{"10":{},"23":{}},"component":{}}],["maximum",{"_index":2145,"title":{},"name":{},"text":{"18":{},"19":{},"20":{}},"component":{}}],["mayb",{"_index":2151,"title":{},"name":{},"text":{"19":{}},"component":{}}],["mean",{"_index":550,"title":{},"name":{},"text":{"5":{},"8":{},"9":{},"12":{},"19":{}},"component":{}}],["mean_rounded_down",{"_index":828,"title":{},"name":{},"text":{"8":{}},"component":{}}],["mean_rounded_up",{"_index":830,"title":{},"name":{},"text":{"8":{}},"component":{}}],["measur",{"_index":789,"title":{},"name":{},"text":{"8":{}},"component":{}}],["median",{"_index":816,"title":{},"name":{},"text":{"8":{}},"component":{}}],["median)).sum",{"_index":819,"title":{},"name":{},"text":{"8":{}},"component":{}}],["memori",{"_index":1531,"title":{},"name":{},"text":{"15":{}},"component":{}}],["mere",{"_index":316,"title":{},"name":{},"text":{"2":{},"7":{},"8":{},"13":{},"20":{},"22":{}},"component":{}}],["merg",{"_index":2416,"title":{},"name":{},"text":{"20":{},"23":{}},"component":{}}],["merge_al",{"_index":2535,"title":{},"name":{},"text":{"20":{}},"component":{}}],["merge_result",{"_index":2554,"title":{},"name":{},"text":{"20":{}},"component":{}}],["merged_cuboid",{"_index":2827,"title":{},"name":{},"text":{"23":{}},"component":{}}],["merged_scann",{"_index":2548,"title":{},"name":{},"text":{"20":{}},"component":{}}],["merged_with(&self",{"_index":2509,"title":{},"name":{},"text":{"20":{}},"component":{}}],["mesh",{"_index":2385,"title":{},"name":{},"text":{"20":{}},"component":{}}],["middl",{"_index":1552,"title":{},"name":{},"text":{"15":{},"23":{}},"component":{}}],["migrat",{"_index":1418,"title":{},"name":{},"text":{"14":{}},"component":{}}],["min",{"_index":1883,"title":{},"name":{},"text":{"17":{},"22":{}},"component":{}}],["min_col",{"_index":1686,"title":{},"name":{},"text":{"16":{}},"component":{}}],["min_count",{"_index":1620,"title":{},"name":{},"text":{"15":{}},"component":{}}],["min_row",{"_index":1685,"title":{},"name":{},"text":{"16":{}},"component":{}}],["minim",{"_index":788,"title":{},"name":{},"text":{"8":{},"16":{}},"component":{}}],["minima",{"_index":1122,"title":{},"name":{},"text":{"10":{}},"component":{}}],["minimum",{"_index":879,"title":{},"name":{},"text":{"8":{}},"component":{}}],["mismatch",{"_index":1203,"title":{},"name":{},"text":{"11":{}},"component":{}}],["mod",{"_index":120,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["mod_nam",{"_index":129,"title":{},"name":{},"text":{"1":{}},"component":{}}],["mod_name:ident:$ft_name:liter",{"_index":125,"title":{},"name":{},"text":{"1":{}},"component":{}}],["mode",{"_index":2588,"title":{},"name":{},"text":{"20":{},"25":{}},"component":{}}],["model",{"_index":959,"title":{},"name":{},"text":{"9":{},"15":{}},"component":{}}],["modif",{"_index":1674,"title":{},"name":{},"text":{"16":{},"24":{}},"component":{}}],["modifi",{"_index":747,"title":{},"name":{},"text":{"7":{},"16":{},"19":{}},"component":{}}],["monolith",{"_index":2606,"title":{},"name":{},"text":{"21":{}},"component":{}}],["moot",{"_index":2057,"title":{},"name":{},"text":{"18":{}},"component":{}}],["more",{"_index":858,"title":{},"name":{},"text":{"8":{},"9":{},"13":{},"16":{},"17":{},"18":{}},"component":{}}],["most_common_digit",{"_index":501,"title":{},"name":{},"text":{"4":{}},"component":{}}],["mostli",{"_index":409,"title":{},"name":{},"text":{"4":{}},"component":{}}],["move",{"_index":841,"title":{},"name":{},"text":{"8":{},"14":{},"22":{},"24":{}},"component":{}}],["move_dist",{"_index":2700,"title":{},"name":{},"text":{"22":{}},"component":{}}],["movement",{"_index":2908,"title":{},"name":{},"text":{"24":{}},"component":{}}],["mse",{"_index":865,"title":{},"name":{},"text":{"8":{}},"component":{}}],["much",{"_index":730,"title":{},"name":{},"text":{"6":{},"16":{},"17":{},"19":{}},"component":{}}],["mul",{"_index":3122,"title":{},"name":{},"text":{"25":{}},"component":{}}],["mul_vec(&self",{"_index":2456,"title":{},"name":{},"text":{"20":{}},"component":{}}],["mul_vec(point",{"_index":2491,"title":{},"name":{},"text":{"20":{}},"component":{}}],["mult",{"_index":1617,"title":{},"name":{},"text":{"15":{}},"component":{}}],["multipl",{"_index":2406,"title":{},"name":{},"text":{"20":{}},"component":{}}],["multipli",{"_index":2045,"title":{},"name":{},"text":{"18":{},"25":{}},"component":{}}],["mut",{"_index":170,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["mutat",{"_index":542,"title":{},"name":{},"text":{"5":{}},"component":{}}],["my_cuboid",{"_index":2879,"title":{},"name":{},"text":{"23":{}},"component":{}}],["my_span[0",{"_index":2800,"title":{},"name":{},"text":{"23":{}},"component":{}}],["my_span[1",{"_index":2806,"title":{},"name":{},"text":{"23":{}},"component":{}}],["myself",{"_index":1989,"title":{},"name":{},"text":{"18":{}},"component":{}}],["n",{"_index":306,"title":{},"name":{},"text":{"2":{},"4":{},"5":{},"8":{},"9":{},"12":{},"14":{},"15":{},"16":{},"17":{},"18":{},"21":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["n)(m+n)=8i",{"_index":2126,"title":{},"name":{},"text":{"18":{}},"component":{}}],["n)(m+n)=k_1k_2",{"_index":2128,"title":{},"name":{},"text":{"18":{}},"component":{}}],["n)*(m+n",{"_index":2037,"title":{},"name":{},"text":{"18":{}},"component":{}}],["n.parse().ok",{"_index":806,"title":{},"name":{},"text":{"8":{}},"component":{}}],["n=1",{"_index":307,"title":{},"name":{},"text":{"2":{}},"component":{}}],["n=3",{"_index":308,"title":{},"name":{},"text":{"2":{}},"component":{}}],["n^2",{"_index":859,"title":{},"name":{},"text":{"8":{},"18":{}},"component":{}}],["n^2+n",{"_index":855,"title":{},"name":{},"text":{"8":{}},"component":{}}],["n^2\\ge",{"_index":854,"title":{},"name":{},"text":{"8":{}},"component":{}}],["n_amphipod",{"_index":2935,"title":{},"name":{},"text":{"24":{}},"component":{}}],["n_amphipods_per_kind",{"_index":2963,"title":{},"name":{},"text":{"24":{}},"component":{}}],["n_bit",{"_index":1850,"title":{},"name":{},"text":{"17":{}},"component":{}}],["n_bits_consum",{"_index":1833,"title":{},"name":{},"text":{"17":{}},"component":{}}],["n_bits_for_length",{"_index":1844,"title":{},"name":{},"text":{"17":{}},"component":{}}],["n_candidates_remain",{"_index":490,"title":{},"name":{},"text":{"4":{}},"component":{}}],["n_chunk",{"_index":1836,"title":{},"name":{},"text":{"17":{}},"component":{}}],["n_col",{"_index":423,"title":{},"name":{},"text":{"4":{},"5":{},"10":{},"12":{},"16":{},"21":{}},"component":{}}],["n_cols.unwrap",{"_index":612,"title":{},"name":{},"text":{"5":{}},"component":{}}],["n_digit",{"_index":3164,"title":{},"name":{},"text":{"25":{}},"component":{}}],["n_finish",{"_index":1371,"title":{},"name":{},"text":{"13":{}},"component":{}}],["n_flash",{"_index":1283,"title":{},"name":{},"text":{"12":{}},"component":{}}],["n_in_correct_sideroom_by_kind",{"_index":3048,"title":{},"name":{},"text":{"24":{}},"component":{}}],["n_in_correct_sideroom_by_kind[am.kind",{"_index":3065,"title":{},"name":{},"text":{"24":{}},"component":{}}],["n_increas",{"_index":338,"title":{},"name":{},"text":{"2":{}},"component":{}}],["n_kind",{"_index":2955,"title":{},"name":{},"text":{"24":{}},"component":{}}],["n_line",{"_index":457,"title":{},"name":{},"text":{"4":{}},"component":{}}],["n_o",{"_index":477,"title":{},"name":{},"text":{"4":{}},"component":{}}],["n_on",{"_index":967,"title":{},"name":{},"text":{"9":{}},"component":{}}],["n_on(&self",{"_index":2882,"title":{},"name":{},"text":{"23":{}},"component":{}}],["n_one",{"_index":467,"title":{},"name":{},"text":{"4":{}},"component":{}}],["n_ones.map(|n",{"_index":471,"title":{},"name":{},"text":{"4":{}},"component":{}}],["n_packet",{"_index":1847,"title":{},"name":{},"text":{"17":{}},"component":{}}],["n_pair",{"_index":1590,"title":{},"name":{},"text":{"15":{}},"component":{}}],["n_roll",{"_index":2704,"title":{},"name":{},"text":{"22":{}},"component":{}}],["n_rolls_per_turn",{"_index":2726,"title":{},"name":{},"text":{"22":{}},"component":{}}],["n_row",{"_index":422,"title":{},"name":{},"text":{"4":{},"5":{},"10":{},"12":{},"16":{},"21":{}},"component":{}}],["n_segment",{"_index":964,"title":{},"name":{},"text":{"9":{}},"component":{}}],["n_step",{"_index":3020,"title":{},"name":{},"text":{"24":{}},"component":{}}],["n_steps_to_hallway",{"_index":3081,"title":{},"name":{},"text":{"24":{}},"component":{}}],["n_timer",{"_index":758,"title":{},"name":{},"text":{"7":{}},"component":{}}],["n_visit",{"_index":1382,"title":{},"name":{},"text":{"13":{}},"component":{}}],["n_way",{"_index":2723,"title":{},"name":{},"text":{"22":{}},"component":{}}],["n_ways_to_get_her",{"_index":2744,"title":{},"name":{},"text":{"22":{}},"component":{}}],["n_ways_to_have_gotten_her",{"_index":2739,"title":{},"name":{},"text":{"22":{}},"component":{}}],["n_ways_to_roll_thi",{"_index":2743,"title":{},"name":{},"text":{"22":{}},"component":{}}],["n_z",{"_index":476,"title":{},"name":{},"text":{"4":{}},"component":{}}],["n_zero",{"_index":470,"title":{},"name":{},"text":{"4":{}},"component":{}}],["naiv",{"_index":794,"title":{},"name":{},"text":{"8":{},"24":{}},"component":{}}],["name",{"_index":1327,"title":{},"name":{},"text":{"13":{}},"component":{}}],["name.chars().map(|c",{"_index":1355,"title":{},"name":{},"text":{"13":{}},"component":{}}],["narrow",{"_index":948,"title":{},"name":{},"text":{"9":{}},"component":{}}],["natur",{"_index":870,"title":{},"name":{},"text":{"8":{},"18":{}},"component":{}}],["nbits(us",{"_index":1806,"title":{},"name":{},"text":{"17":{}},"component":{}}],["ndarray::array2",{"_index":420,"title":{},"name":{},"text":{"4":{}},"component":{}}],["ndarray::prelud",{"_index":442,"title":{},"name":{},"text":{"4":{},"10":{},"12":{},"16":{},"21":{},"24":{}},"component":{}}],["ndarray::zip::from(&candid",{"_index":503,"title":{},"name":{},"text":{"4":{}},"component":{}}],["ndarray::zip::from(&n_on",{"_index":473,"title":{},"name":{},"text":{"4":{}},"component":{}}],["nearli",{"_index":2144,"title":{},"name":{},"text":{"18":{},"21":{}},"component":{}}],["necessarili",{"_index":1977,"title":{},"name":{},"text":{"18":{},"21":{}},"component":{}}],["need",{"_index":537,"title":{},"name":{},"text":{"5":{},"8":{},"9":{},"18":{},"20":{},"22":{},"23":{}},"component":{}}],["needless",{"_index":2928,"title":{},"name":{},"text":{"24":{}},"component":{}}],["neg",{"_index":1641,"title":{},"name":{},"text":{"16":{}},"component":{}}],["negi",{"_index":2465,"title":{},"name":{},"text":{"20":{}},"component":{}}],["negx",{"_index":2463,"title":{},"name":{},"text":{"20":{}},"component":{}}],["negz",{"_index":2467,"title":{},"name":{},"text":{"20":{}},"component":{}}],["neighbor",{"_index":1157,"title":{},"name":{},"text":{"10":{},"16":{}},"component":{}}],["neighbor_idx",{"_index":1183,"title":{},"name":{},"text":{"10":{}},"component":{}}],["neighbor’",{"_index":1668,"title":{},"name":{},"text":{"16":{}},"component":{}}],["nest",{"_index":2149,"title":{},"name":{},"text":{"19":{}},"component":{}}],["net_cost_to_travel_her",{"_index":1705,"title":{},"name":{},"text":{"16":{}},"component":{}}],["net_cost_to_travel_to_nghbr_thru_her",{"_index":1704,"title":{},"name":{},"text":{"16":{}},"component":{}}],["net_travel_cost",{"_index":1695,"title":{},"name":{},"text":{"16":{}},"component":{}}],["net_travel_costs[(0",{"_index":1698,"title":{},"name":{},"text":{"16":{}},"component":{}}],["never",{"_index":100,"title":{},"name":{},"text":{"1":{},"17":{}},"component":{}}],["new",{"_index":323,"title":{},"name":{},"text":{"2":{},"16":{},"17":{},"20":{},"25":{}},"component":{}}],["new(beacon",{"_index":2508,"title":{},"name":{},"text":{"20":{}},"component":{}}],["new(min",{"_index":2705,"title":{},"name":{},"text":{"22":{}},"component":{}}],["new(n_row",{"_index":576,"title":{},"name":{},"text":{"5":{}},"component":{}}],["new(nam",{"_index":1353,"title":{},"name":{},"text":{"13":{}},"component":{}}],["new(num",{"_index":583,"title":{},"name":{},"text":{"5":{}},"component":{}}],["new(po",{"_index":2692,"title":{},"name":{},"text":{"22":{}},"component":{}}],["new(seg",{"_index":968,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new(up_fac",{"_index":2474,"title":{},"name":{},"text":{"20":{}},"component":{}}],["new_col",{"_index":1691,"title":{},"name":{},"text":{"16":{}},"component":{}}],["new_cost",{"_index":1728,"title":{},"name":{},"text":{"16":{}},"component":{}}],["new_curr_z",{"_index":3191,"title":{},"name":{},"text":{"25":{}},"component":{}}],["new_curr_zs.extend(prev_zs.get(z).unwrap().iter().copi",{"_index":3193,"title":{},"name":{},"text":{"25":{}},"component":{}}],["new_down",{"_index":3235,"title":{},"name":{},"text":{"26":{}},"component":{}}],["new_downs.insert(*old_loc",{"_index":3238,"title":{},"name":{},"text":{"26":{}},"component":{}}],["new_downs.insert(new_loc",{"_index":3239,"title":{},"name":{},"text":{"26":{}},"component":{}}],["new_elem",{"_index":2220,"title":{},"name":{},"text":{"19":{}},"component":{}}],["new_elem.depth",{"_index":2223,"title":{},"name":{},"text":{"19":{}},"component":{}}],["new_garbl",{"_index":1026,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_garbled.n_on",{"_index":1029,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_garbled_key",{"_index":1054,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_garbled_keys.contains(&segment_union",{"_index":1060,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_garbled_keys.iter().enumer",{"_index":1056,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_garbled_keys.iter().skip(i",{"_index":1057,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_good_candid",{"_index":1030,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_good_candidates.insert(candid",{"_index":1037,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_grid",{"_index":1712,"title":{},"name":{},"text":{"16":{}},"component":{}}],["new_grid[(new_grid_r",{"_index":1731,"title":{},"name":{},"text":{"16":{}},"component":{}}],["new_grid_c",{"_index":1730,"title":{},"name":{},"text":{"16":{}},"component":{}}],["new_grid_r",{"_index":1729,"title":{},"name":{},"text":{"16":{}},"component":{}}],["new_i",{"_index":1453,"title":{},"name":{},"text":{"14":{}},"component":{}}],["new_l_valu",{"_index":2218,"title":{},"name":{},"text":{"19":{}},"component":{}}],["new_loc",{"_index":3066,"title":{},"name":{},"text":{"24":{},"26":{}},"component":{}}],["new_map",{"_index":1017,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_mappings.entry(new_garbl",{"_index":1038,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_mappings.keys().copied().collect",{"_index":1055,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_mappings.remove(k",{"_index":1062,"title":{},"name":{},"text":{"9":{}},"component":{}}],["new_mat",{"_index":2634,"title":{},"name":{},"text":{"21":{}},"component":{}}],["new_mat[[center_row",{"_index":2647,"title":{},"name":{},"text":{"21":{}},"component":{}}],["new_po",{"_index":2694,"title":{},"name":{},"text":{"22":{}},"component":{}}],["new_r_valu",{"_index":2219,"title":{},"name":{},"text":{"19":{}},"component":{}}],["new_right",{"_index":3228,"title":{},"name":{},"text":{"26":{}},"component":{}}],["new_rights.contains(&new_loc",{"_index":3237,"title":{},"name":{},"text":{"26":{}},"component":{}}],["new_rights.insert(*old_loc",{"_index":3233,"title":{},"name":{},"text":{"26":{}},"component":{}}],["new_rights.insert(new_loc",{"_index":3234,"title":{},"name":{},"text":{"26":{}},"component":{}}],["new_row",{"_index":1690,"title":{},"name":{},"text":{"16":{}},"component":{}}],["new_scann",{"_index":2550,"title":{},"name":{},"text":{"20":{}},"component":{}}],["new_stat",{"_index":3021,"title":{},"name":{},"text":{"24":{}},"component":{}}],["new_surround",{"_index":2626,"title":{},"name":{},"text":{"21":{}},"component":{}}],["new_total_st",{"_index":3083,"title":{},"name":{},"text":{"24":{}},"component":{}}],["new_total_state[am",{"_index":3084,"title":{},"name":{},"text":{"24":{}},"component":{}}],["new_unbound",{"_index":2873,"title":{},"name":{},"text":{"23":{}},"component":{}}],["new_with_size(n",{"_index":2872,"title":{},"name":{},"text":{"23":{}},"component":{}}],["new_x",{"_index":1449,"title":{},"name":{},"text":{"14":{}},"component":{}}],["newli",{"_index":1857,"title":{},"name":{},"text":{"17":{}},"component":{}}],["next",{"_index":291,"title":{},"name":{},"text":{"1":{},"5":{},"13":{},"16":{},"17":{},"18":{},"20":{},"21":{},"22":{},"23":{},"25":{}},"component":{}}],["next_cav",{"_index":1375,"title":{},"name":{},"text":{"13":{}},"component":{}}],["next_cave.kind",{"_index":1381,"title":{},"name":{},"text":{"13":{}},"component":{}}],["next_cave.nam",{"_index":1377,"title":{},"name":{},"text":{"13":{}},"component":{}}],["next_digit_attempt",{"_index":3203,"title":{},"name":{},"text":{"25":{}},"component":{}}],["nghbr_coord",{"_index":1703,"title":{},"name":{},"text":{"16":{}},"component":{}}],["nghbr_idx",{"_index":1184,"title":{},"name":{},"text":{"10":{}},"component":{}}],["node",{"_index":1309,"title":{},"name":{},"text":{"13":{},"16":{},"19":{}},"component":{}}],["node’",{"_index":1345,"title":{},"name":{},"text":{"13":{}},"component":{}}],["non",{"_index":2371,"title":{},"name":{},"text":{"19":{}},"component":{}}],["none",{"_index":382,"title":{},"name":{},"text":{"3":{},"4":{},"5":{},"9":{},"11":{},"14":{},"15":{},"16":{},"18":{},"19":{},"20":{},"22":{},"23":{},"24":{},"25":{}},"component":{}}],["nonempti",{"_index":664,"title":{},"name":{},"text":{"6":{}},"component":{}}],["nonintersecting_cuboid",{"_index":2883,"title":{},"name":{},"text":{"23":{}},"component":{}}],["nonintersecting_cuboids.extend(piec",{"_index":2889,"title":{},"name":{},"text":{"23":{}},"component":{}}],["nonsens",{"_index":91,"title":{},"name":{},"text":{"1":{}},"component":{}}],["norm",{"_index":802,"title":{},"name":{},"text":{"8":{}},"component":{}}],["not(self",{"_index":987,"title":{},"name":{},"text":{"9":{}},"component":{}}],["not_yet_visited_idx",{"_index":1171,"title":{},"name":{},"text":{"10":{}},"component":{}}],["not_yet_visited_idxs.pop_first",{"_index":1176,"title":{},"name":{},"text":{"10":{}},"component":{}}],["not_yet_visited_idxs.remove(idx",{"_index":1188,"title":{},"name":{},"text":{"10":{}},"component":{}}],["notabl",{"_index":2364,"title":{},"name":{},"text":{"19":{},"21":{}},"component":{}}],["notat",{"_index":440,"title":{},"name":{},"text":{"4":{}},"component":{}}],["note",{"_index":1317,"title":{},"name":{},"text":{"13":{},"15":{},"18":{},"22":{},"23":{},"25":{}},"component":{}}],["noth",{"_index":1117,"title":{},"name":{},"text":{"10":{}},"component":{}}],["notion",{"_index":960,"title":{},"name":{},"text":{"9":{}},"component":{}}],["now",{"_index":1278,"title":{},"name":{},"text":{"12":{},"13":{},"15":{},"18":{},"23":{}},"component":{}}],["npackets(us",{"_index":1807,"title":{},"name":{},"text":{"17":{}},"component":{}}],["nth_back(0",{"_index":2689,"title":{},"name":{},"text":{"22":{},"23":{}},"component":{}}],["num",{"_index":604,"title":{},"name":{},"text":{"5":{},"7":{},"8":{},"18":{},"19":{},"25":{}},"component":{}}],["num::integ",{"_index":668,"title":{},"name":{},"text":{"6":{}},"component":{}}],["num::integer::root",{"_index":1990,"title":{},"name":{},"text":{"18":{}},"component":{}}],["num::iter::rangestepinclus",{"_index":691,"title":{},"name":{},"text":{"6":{}},"component":{}}],["num::on",{"_index":1487,"title":{},"name":{},"text":{"14":{}},"component":{}}],["num::range_step_inclusive(num::zero",{"_index":1486,"title":{},"name":{},"text":{"14":{}},"component":{}}],["num::zero",{"_index":1485,"title":{},"name":{},"text":{"14":{}},"component":{}}],["num::{checkedadd",{"_index":1504,"title":{},"name":{},"text":{"14":{}},"component":{}}],["num::{integer::div_mod_floor",{"_index":566,"title":{},"name":{},"text":{"5":{}},"component":{}}],["number",{"_index":319,"title":{},"name":{},"text":{"2":{},"4":{},"5":{},"8":{},"9":{},"13":{},"15":{},"16":{},"17":{},"18":{},"19":{},"21":{},"22":{},"24":{}},"component":{}}],["number(n",{"_index":3134,"title":{},"name":{},"text":{"25":{}},"component":{}}],["number(num",{"_index":3117,"title":{},"name":{},"text":{"25":{}},"component":{}}],["number(v",{"_index":3119,"title":{},"name":{},"text":{"25":{}},"component":{}}],["number::max",{"_index":1885,"title":{},"name":{},"text":{"17":{}},"component":{}}],["number::min",{"_index":1886,"title":{},"name":{},"text":{"17":{}},"component":{}}],["numer",{"_index":24,"title":{},"name":{},"text":{"1":{}},"component":{}}],["nums).min(cost(mean_rounded_up",{"_index":831,"title":{},"name":{},"text":{"8":{}},"component":{}}],["nums.as_ref",{"_index":825,"title":{},"name":{},"text":{"8":{}},"component":{}}],["nums.as_ref().to_vec",{"_index":810,"title":{},"name":{},"text":{"8":{}},"component":{}}],["nums.it",{"_index":822,"title":{},"name":{},"text":{"8":{}},"component":{}}],["nums.iter().enumer",{"_index":588,"title":{},"name":{},"text":{"5":{}},"component":{}}],["nums.iter().map(|&n",{"_index":817,"title":{},"name":{},"text":{"8":{}},"component":{}}],["nums.iter().sum",{"_index":826,"title":{},"name":{},"text":{"8":{}},"component":{}}],["nums.len",{"_index":585,"title":{},"name":{},"text":{"5":{},"8":{}},"component":{}}],["nums.sort_unst",{"_index":811,"title":{},"name":{},"text":{"8":{}},"component":{}}],["nums[1",{"_index":815,"title":{},"name":{},"text":{"8":{}},"component":{}}],["nums[nums.len",{"_index":813,"title":{},"name":{},"text":{"8":{}},"component":{}}],["o",{"_index":1042,"title":{},"name":{},"text":{"9":{}},"component":{}}],["o.insert(o.get",{"_index":1043,"title":{},"name":{},"text":{"9":{}},"component":{}}],["object",{"_index":94,"title":{},"name":{},"text":{"1":{}},"component":{}}],["observ",{"_index":921,"title":{},"name":{},"text":{"9":{}},"component":{}}],["obtain",{"_index":1553,"title":{},"name":{},"text":{"15":{},"20":{}},"component":{}}],["occur",{"_index":1556,"title":{},"name":{},"text":{"15":{},"23":{}},"component":{}}],["octopi",{"_index":1271,"title":{},"name":{},"text":{"12":{}},"component":{}}],["octopi.arr.iter().any(|&v",{"_index":1304,"title":{},"name":{},"text":{"12":{}},"component":{}}],["octopi.tick_in_place_and_count_flash",{"_index":1300,"title":{},"name":{},"text":{"12":{}},"component":{}}],["octopi::from_str(input).unwrap",{"_index":1295,"title":{},"name":{},"text":{"12":{}},"component":{}}],["octopu",{"_index":242,"title":{"12":{}},"name":{},"text":{"1":{}},"component":{}}],["odd",{"_index":2135,"title":{},"name":{},"text":{"18":{},"21":{}},"component":{}}],["offer",{"_index":799,"title":{},"name":{},"text":{"8":{}},"component":{}}],["ok",{"_index":1240,"title":{},"name":{},"text":{"11":{},"14":{},"17":{},"18":{},"19":{},"21":{},"22":{},"23":{},"24":{},"26":{}},"component":{}}],["ok((left",{"_index":2267,"title":{},"name":{},"text":{"19":{}},"component":{}}],["ok(map",{"_index":1066,"title":{},"name":{},"text":{"9":{}},"component":{}}],["old_cost",{"_index":1723,"title":{},"name":{},"text":{"16":{}},"component":{}}],["old_depth",{"_index":337,"title":{},"name":{},"text":{"2":{}},"component":{}}],["old_loc",{"_index":3229,"title":{},"name":{},"text":{"26":{}},"component":{}}],["oldest",{"_index":324,"title":{},"name":{},"text":{"2":{}},"component":{}}],["omit",{"_index":2377,"title":{},"name":{},"text":{"19":{}},"component":{}}],["on",{"_index":545,"title":{},"name":{},"text":{"5":{},"6":{},"7":{},"9":{},"14":{},"15":{},"17":{},"18":{},"19":{},"20":{},"23":{},"24":{},"25":{}},"component":{}}],["on_cuboid",{"_index":2816,"title":{},"name":{},"text":{"23":{}},"component":{}}],["on_cuboids.extend(my_cuboid.difference(&cuboid",{"_index":2881,"title":{},"name":{},"text":{"23":{}},"component":{}}],["on_cuboids.iter().enumer",{"_index":2825,"title":{},"name":{},"text":{"23":{}},"component":{}}],["on_cuboids.iter().enumerate().skip(i",{"_index":2826,"title":{},"name":{},"text":{"23":{}},"component":{}}],["on_cuboids.push(cuboid",{"_index":2820,"title":{},"name":{},"text":{"23":{}},"component":{}}],["on_cuboids.push(merged_cuboid",{"_index":2851,"title":{},"name":{},"text":{"23":{}},"component":{}}],["on_cuboids.swap_remove(i",{"_index":2850,"title":{},"name":{},"text":{"23":{}},"component":{}}],["on_cuboids.swap_remove(j",{"_index":2849,"title":{},"name":{},"text":{"23":{}},"component":{}}],["onc",{"_index":1404,"title":{},"name":{},"text":{"13":{},"14":{},"15":{},"18":{},"20":{}},"component":{}}],["ongoing_game_idx",{"_index":634,"title":{},"name":{},"text":{"5":{}},"component":{}}],["ongoing_game_idxs.contains(&board_idx",{"_index":639,"title":{},"name":{},"text":{"5":{}},"component":{}}],["ongoing_game_idxs.len",{"_index":641,"title":{},"name":{},"text":{"5":{}},"component":{}}],["ongoing_game_idxs.remove(&board_idx",{"_index":642,"title":{},"name":{},"text":{"5":{}},"component":{}}],["onto",{"_index":1343,"title":{},"name":{},"text":{"13":{},"17":{},"20":{}},"component":{}}],["op",{"_index":517,"title":{},"name":{},"text":{"4":{},"17":{}},"component":{}}],["op.into",{"_index":1864,"title":{},"name":{},"text":{"17":{}},"component":{}}],["op1",{"_index":1024,"title":{},"name":{},"text":{"9":{}},"component":{}}],["op1(garbled1",{"_index":1027,"title":{},"name":{},"text":{"9":{}},"component":{}}],["op1(good_digit1",{"_index":1034,"title":{},"name":{},"text":{"9":{}},"component":{}}],["op2",{"_index":1025,"title":{},"name":{},"text":{"9":{}},"component":{}}],["op2(garbled2",{"_index":1028,"title":{},"name":{},"text":{"9":{}},"component":{}}],["op2(good_digit2",{"_index":1035,"title":{},"name":{},"text":{"9":{}},"component":{}}],["op_data_length",{"_index":1843,"title":{},"name":{},"text":{"17":{}},"component":{}}],["open",{"_index":38,"title":{},"name":{},"text":{"1":{}},"component":{}}],["oper",{"_index":1789,"title":{},"name":{},"text":{"17":{},"19":{},"23":{},"25":{}},"component":{}}],["operand",{"_index":3116,"title":{},"name":{},"text":{"25":{}},"component":{}}],["operand::from_str(splat.next",{"_index":3153,"title":{},"name":{},"text":{"25":{}},"component":{}}],["operatorss",{"_index":1949,"title":{},"name":{},"text":{"17":{}},"component":{}}],["oppos",{"_index":49,"title":{},"name":{},"text":{"1":{}},"component":{}}],["ops::{index",{"_index":3114,"title":{},"name":{},"text":{"25":{}},"component":{}}],["optim",{"_index":1652,"title":{},"name":{},"text":{"16":{}},"component":{}}],["option",{"_index":67,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{}},"component":{}}],["or_insert_with(set::new",{"_index":1004,"title":{},"name":{},"text":{"9":{}},"component":{}}],["or_insert_with(vec::new",{"_index":1367,"title":{},"name":{},"text":{"13":{}},"component":{}}],["ord",{"_index":673,"title":{},"name":{},"text":{"6":{},"9":{},"13":{},"14":{},"15":{},"20":{},"24":{},"26":{}},"component":{}}],["order",{"_index":29,"title":{},"name":{},"text":{"1":{},"9":{},"16":{},"19":{}},"component":{}}],["ordinari",{"_index":2383,"title":{},"name":{},"text":{"20":{}},"component":{}}],["orient",{"_index":1214,"title":{},"name":{},"text":{"11":{},"20":{}},"component":{}}],["orig",{"_index":1363,"title":{},"name":{},"text":{"13":{}},"component":{}}],["orig_data",{"_index":1813,"title":{},"name":{},"text":{"17":{}},"component":{}}],["orig_data[cursor",{"_index":1822,"title":{},"name":{},"text":{"17":{}},"component":{}}],["origami",{"_index":248,"title":{"14":{}},"name":{},"text":{"1":{}},"component":{}}],["origin",{"_index":1308,"title":{},"name":{},"text":{"13":{},"15":{},"17":{},"18":{}},"component":{}}],["other.applying(swivel",{"_index":2521,"title":{},"name":{},"text":{"20":{}},"component":{}}],["other.col(c",{"_index":2450,"title":{},"name":{},"text":{"20":{}},"component":{}}],["other_col",{"_index":2449,"title":{},"name":{},"text":{"20":{}},"component":{}}],["other_col[i]).sum",{"_index":2454,"title":{},"name":{},"text":{"20":{}},"component":{}}],["otherwis",{"_index":540,"title":{},"name":{},"text":{"5":{},"17":{}},"component":{}}],["out",{"_index":37,"title":{},"name":{},"text":{"1":{},"14":{},"15":{},"17":{},"21":{},"24":{}},"component":{}}],["out_d",{"_index":1095,"title":{},"name":{},"text":{"9":{}},"component":{}}],["out_d.it",{"_index":1097,"title":{},"name":{},"text":{"9":{}},"component":{}}],["out_digit",{"_index":1084,"title":{},"name":{},"text":{"9":{}},"component":{}}],["outcom",{"_index":2681,"title":{},"name":{},"text":{"22":{}},"component":{}}],["outcome_count",{"_index":2730,"title":{},"name":{},"text":{"22":{}},"component":{}}],["outer",{"_index":2613,"title":{},"name":{},"text":{"21":{}},"component":{}}],["outer_c",{"_index":1721,"title":{},"name":{},"text":{"16":{}},"component":{}}],["outer_c).unwrap",{"_index":1727,"title":{},"name":{},"text":{"16":{}},"component":{}}],["outer_char",{"_index":1582,"title":{},"name":{},"text":{"15":{}},"component":{}}],["outer_chars.next",{"_index":1584,"title":{},"name":{},"text":{"15":{}},"component":{}}],["outer_r",{"_index":1718,"title":{},"name":{},"text":{"16":{}},"component":{}}],["outgo",{"_index":321,"title":{},"name":{},"text":{"2":{}},"component":{}}],["output",{"_index":908,"title":{},"name":{},"text":{"9":{},"14":{},"20":{},"24":{},"25":{}},"component":{}}],["output_digit",{"_index":1093,"title":{},"name":{},"text":{"9":{}},"component":{}}],["over",{"_index":755,"title":{},"name":{},"text":{"7":{},"14":{},"15":{}},"component":{}}],["overlap",{"_index":2099,"title":{},"name":{},"text":{"18":{},"20":{}},"component":{}}],["own",{"_index":2188,"title":{},"name":{},"text":{"19":{}},"component":{}}],["owning(elem",{"_index":2180,"title":{},"name":{},"text":{"19":{}},"component":{}}],["oxy_r",{"_index":512,"title":{},"name":{},"text":{"4":{}},"component":{}}],["p",{"_index":1459,"title":{},"name":{},"text":{"14":{},"16":{},"17":{},"26":{}},"component":{}}],["p1_n_win",{"_index":2749,"title":{},"name":{},"text":{"22":{}},"component":{}}],["p1_n_wins.max(p2_n_win",{"_index":2752,"title":{},"name":{},"text":{"22":{}},"component":{}}],["p2_n_win",{"_index":2750,"title":{},"name":{},"text":{"22":{}},"component":{}}],["p\\)’",{"_index":1665,"title":{},"name":{},"text":{"16":{}},"component":{}}],["packet",{"_index":255,"title":{"17":{}},"name":{},"text":{"1":{},"17":{}},"component":{}}],["packet.version_number).sum",{"_index":1881,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packet_bit",{"_index":1821,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packet_bits[header_length",{"_index":1828,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packet_depth",{"_index":1908,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packet_kind",{"_index":1907,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packetkind",{"_index":1873,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packetkind::liter",{"_index":1842,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packetkind::oper",{"_index":1863,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packets.iter().map(|packet",{"_index":1880,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packets.iter().rev",{"_index":1909,"title":{},"name":{},"text":{"17":{}},"component":{}}],["packets.push(packet",{"_index":1872,"title":{},"name":{},"text":{"17":{}},"component":{}}],["page",{"_index":1423,"title":{},"name":{},"text":{"14":{}},"component":{}}],["pair",{"_index":35,"title":{},"name":{},"text":{"1":{},"5":{},"9":{},"11":{},"15":{},"18":{},"19":{},"20":{},"22":{}},"component":{}}],["pair_count",{"_index":1596,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pair_counts.entry((c",{"_index":1607,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pair_counts.entry((c1",{"_index":1605,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pair_counts.get_mut(&key).unwrap",{"_index":1609,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pair_counts_vec",{"_index":1598,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pairwis",{"_index":946,"title":{},"name":{},"text":{"9":{},"19":{},"20":{}},"component":{}}],["panic!(\"cannot",{"_index":991,"title":{},"name":{},"text":{"9":{},"24":{}},"component":{}}],["panic!(\"could",{"_index":3089,"title":{},"name":{},"text":{"24":{}},"component":{}}],["panic!(\"digit",{"_index":995,"title":{},"name":{},"text":{"9":{}},"component":{}}],["panic!(\"unexpect",{"_index":2172,"title":{},"name":{},"text":{"19":{}},"component":{}}],["paper",{"_index":1417,"title":{},"name":{},"text":{"14":{}},"component":{}}],["paper.do_folds(fold",{"_index":1495,"title":{},"name":{},"text":{"14":{}},"component":{}}],["paper.folded_across(fold",{"_index":1466,"title":{},"name":{},"text":{"14":{}},"component":{}}],["paper.folded_across(fold).dots.len",{"_index":1482,"title":{},"name":{},"text":{"14":{}},"component":{}}],["paper::::from_dots(point",{"_index":1473,"title":{},"name":{},"text":{"14":{}},"component":{}}],["paper::from_dots(dot",{"_index":1462,"title":{},"name":{},"text":{"14":{}},"component":{}}],["parallel",{"_index":2770,"title":{},"name":{},"text":{"23":{}},"component":{}}],["paren",{"_index":1211,"title":{},"name":{},"text":{"11":{}},"component":{}}],["parent_packet_length",{"_index":1829,"title":{},"name":{},"text":{"17":{}},"component":{}}],["parent’",{"_index":1791,"title":{},"name":{},"text":{"17":{}},"component":{}}],["pars",{"_index":31,"title":{},"name":{},"text":{"1":{},"11":{},"17":{},"19":{},"22":{}},"component":{}}],["parse_line(v.it",{"_index":1243,"title":{},"name":{},"text":{"11":{}},"component":{}}],["parse_line>(lin",{"_index":1223,"title":{},"name":{},"text":{"11":{}},"component":{}}],["parse_st",{"_index":1819,"title":{},"name":{},"text":{"17":{}},"component":{}}],["parsed_lin",{"_index":1242,"title":{},"name":{},"text":{"11":{}},"component":{}}],["parseresult",{"_index":1222,"title":{},"name":{},"text":{"11":{}},"component":{}}],["parsest",{"_index":1812,"title":{},"name":{},"text":{"17":{}},"component":{}}],["part",{"_index":175,"title":{"2-2":{},"3-2":{},"3-3":{},"4-2":{},"4-3":{},"5-2":{},"5-3":{},"6-2":{},"6-3":{},"7-2":{},"8-2":{},"8-3":{},"9-2":{},"9-3":{},"10-2":{},"10-3":{},"11-2":{},"11-3":{},"12-2":{},"12-3":{},"13-2":{},"14-2":{},"14-3":{},"15-2":{},"16-2":{},"16-3":{},"17-2":{},"17-3":{},"18-2":{},"18-3":{},"19-2":{},"19-3":{},"20-2":{},"20-3":{},"21-2":{},"22-2":{},"22-3":{},"23-2":{},"24-2":{},"25-2":{},"26-1":{}},"name":{},"text":{"1":{},"2":{},"6":{},"8":{},"10":{},"13":{},"14":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{}},"component":{}}],["partial_cmp(&self",{"_index":2951,"title":{},"name":{},"text":{"24":{}},"component":{}}],["partialeq",{"_index":157,"title":{},"name":{},"text":{"1":{},"6":{},"9":{},"11":{},"13":{},"14":{},"15":{},"18":{},"19":{},"20":{},"24":{},"26":{}},"component":{}}],["partialord",{"_index":672,"title":{},"name":{},"text":{"6":{},"9":{},"13":{},"14":{},"15":{},"20":{},"24":{},"26":{}},"component":{}}],["particip",{"_index":14,"title":{},"name":{},"text":{"1":{}},"component":{}}],["particular",{"_index":554,"title":{},"name":{},"text":{"5":{},"8":{},"18":{}},"component":{}}],["particularli",{"_index":560,"title":{},"name":{},"text":{"5":{}},"component":{}}],["passag",{"_index":244,"title":{"13":{}},"name":{},"text":{"1":{}},"component":{}}],["password",{"_index":1508,"title":{},"name":{},"text":{"14":{}},"component":{}}],["past",{"_index":311,"title":{},"name":{},"text":{"2":{}},"component":{}}],["path",{"_index":245,"title":{"13":{}},"name":{},"text":{"1":{},"13":{},"16":{},"24":{}},"component":{}}],["path’",{"_index":1633,"title":{},"name":{},"text":{"16":{}},"component":{}}],["pattern",{"_index":897,"title":{},"name":{},"text":{"9":{}},"component":{}}],["penal",{"_index":857,"title":{},"name":{},"text":{"8":{}},"component":{}}],["peopl",{"_index":1956,"title":{},"name":{},"text":{"18":{}},"component":{}}],["per",{"_index":1542,"title":{},"name":{},"text":{"15":{}},"component":{}}],["perfect",{"_index":2123,"title":{},"name":{},"text":{"18":{}},"component":{}}],["perform",{"_index":1503,"title":{},"name":{},"text":{"14":{},"15":{},"16":{},"19":{},"20":{},"23":{},"24":{}},"component":{}}],["perhap",{"_index":1651,"title":{},"name":{},"text":{"16":{},"18":{}},"component":{}}],["pghzbfjc",{"_index":1515,"title":{},"name":{},"text":{"14":{}},"component":{}}],["pick",{"_index":873,"title":{},"name":{},"text":{"8":{},"20":{},"24":{}},"component":{}}],["piec",{"_index":1416,"title":{},"name":{},"text":{"14":{},"20":{},"23":{}},"component":{}}],["piece.difference(&c2",{"_index":2888,"title":{},"name":{},"text":{"23":{}},"component":{}}],["pixel",{"_index":2596,"title":{},"name":{},"text":{"21":{}},"component":{}}],["place",{"_index":1425,"title":{},"name":{},"text":{"14":{},"19":{}},"component":{}}],["plagu",{"_index":1563,"title":{},"name":{},"text":{"15":{}},"component":{}}],["plane",{"_index":655,"title":{},"name":{},"text":{"6":{}},"component":{}}],["play_number(&mut",{"_index":593,"title":{},"name":{},"text":{"5":{}},"component":{}}],["play_quantum_dic",{"_index":2724,"title":{},"name":{},"text":{"22":{}},"component":{}}],["play_quantum_dice(play",{"_index":2751,"title":{},"name":{},"text":{"22":{}},"component":{}}],["player",{"_index":87,"title":{},"name":{},"text":{"1":{},"22":{}},"component":{}}],["player.roll_deterministic_die(board",{"_index":2717,"title":{},"name":{},"text":{"22":{}},"component":{}}],["player.roll_value(board",{"_index":2746,"title":{},"name":{},"text":{"22":{}},"component":{}}],["player.scor",{"_index":2718,"title":{},"name":{},"text":{"22":{}},"component":{}}],["player_index",{"_index":2741,"title":{},"name":{},"text":{"22":{}},"component":{}}],["players[1",{"_index":2716,"title":{},"name":{},"text":{"22":{}},"component":{}}],["players[player_index",{"_index":2745,"title":{},"name":{},"text":{"22":{}},"component":{}}],["plu",{"_index":1557,"title":{},"name":{},"text":{"15":{}},"component":{}}],["plug",{"_index":2136,"title":{},"name":{},"text":{"18":{}},"component":{}}],["pm1",{"_index":734,"title":{},"name":{},"text":{"6":{}},"component":{}}],["po",{"_index":1992,"title":{},"name":{},"text":{"18":{},"22":{}},"component":{}}],["point",{"_index":71,"title":{},"name":{},"text":{"1":{},"6":{},"8":{},"14":{},"16":{},"18":{},"20":{},"24":{},"26":{}},"component":{}}],["point(new_x",{"_index":1451,"title":{},"name":{},"text":{"14":{}},"component":{}}],["point(t",{"_index":674,"title":{},"name":{},"text":{"6":{},"14":{}},"component":{}}],["point(x",{"_index":1447,"title":{},"name":{},"text":{"14":{}},"component":{}}],["point(x2",{"_index":690,"title":{},"name":{},"text":{"6":{}},"component":{}}],["pointcount",{"_index":676,"title":{},"name":{},"text":{"6":{}},"component":{}}],["polym",{"_index":1579,"title":{},"name":{},"text":{"15":{}},"component":{}}],["polymer",{"_index":251,"title":{"15":{}},"name":{},"text":{"1":{}},"component":{}}],["polymer.apply_n_times(n",{"_index":1612,"title":{},"name":{},"text":{"15":{}},"component":{}}],["polymer::from_str(input).unwrap",{"_index":1623,"title":{},"name":{},"text":{"15":{}},"component":{}}],["poor",{"_index":2152,"title":{},"name":{},"text":{"19":{}},"component":{}}],["pop",{"_index":1202,"title":{},"name":{},"text":{"11":{},"13":{}},"component":{}}],["portion",{"_index":2597,"title":{},"name":{},"text":{"21":{}},"component":{}}],["pos0",{"_index":1551,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pos1",{"_index":1554,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pos2",{"_index":1555,"title":{},"name":{},"text":{"15":{}},"component":{}}],["posi",{"_index":2464,"title":{},"name":{},"text":{"20":{}},"component":{}}],["posit",{"_index":367,"title":{},"name":{},"text":{"3":{},"4":{},"5":{},"14":{},"15":{},"18":{},"22":{},"24":{}},"component":{}}],["position)).or_default",{"_index":1594,"title":{},"name":{},"text":{"15":{}},"component":{}}],["possibl",{"_index":796,"title":{},"name":{},"text":{"8":{},"18":{},"22":{},"23":{},"24":{}},"component":{}}],["posx",{"_index":2462,"title":{},"name":{},"text":{"20":{}},"component":{}}],["posz",{"_index":2466,"title":{},"name":{},"text":{"20":{}},"component":{}}],["potenti",{"_index":1266,"title":{},"name":{},"text":{"12":{},"18":{},"23":{}},"component":{}}],["pq",{"_index":3026,"title":{},"name":{},"text":{"24":{}},"component":{}}],["pq.pop",{"_index":3040,"title":{},"name":{},"text":{"24":{}},"component":{}}],["pq.push(initial_st",{"_index":3037,"title":{},"name":{},"text":{"24":{}},"component":{}}],["pq.push_increase(st",{"_index":3030,"title":{},"name":{},"text":{"24":{}},"component":{}}],["pr",{"_index":1255,"title":{},"name":{},"text":{"11":{}},"component":{}}],["practic",{"_index":2603,"title":{},"name":{},"text":{"21":{}},"component":{}}],["pre",{"_index":1860,"title":{},"name":{},"text":{"17":{}},"component":{}}],["precis",{"_index":1760,"title":{},"name":{},"text":{"17":{},"18":{}},"component":{}}],["precomput",{"_index":2682,"title":{},"name":{},"text":{"22":{}},"component":{}}],["precondit",{"_index":1426,"title":{},"name":{},"text":{"14":{}},"component":{}}],["present",{"_index":1051,"title":{},"name":{},"text":{"9":{}},"component":{}}],["presum",{"_index":2902,"title":{},"name":{},"text":{"23":{}},"component":{}}],["pretti",{"_index":63,"title":{},"name":{},"text":{"1":{},"11":{},"18":{}},"component":{}}],["prev.brac",{"_index":1232,"title":{},"name":{},"text":{"11":{}},"component":{}}],["prev.orient",{"_index":1230,"title":{},"name":{},"text":{"11":{}},"component":{}}],["prev_depth",{"_index":2261,"title":{},"name":{},"text":{"19":{}},"component":{}}],["prev_was_digit",{"_index":2164,"title":{},"name":{},"text":{"19":{}},"component":{}}],["prev_z",{"_index":3174,"title":{},"name":{},"text":{"25":{}},"component":{}}],["prev_zs.key",{"_index":3178,"title":{},"name":{},"text":{"25":{}},"component":{}}],["previou",{"_index":301,"title":{},"name":{},"text":{"2":{}},"component":{}}],["print",{"_index":1514,"title":{},"name":{},"text":{"14":{}},"component":{}}],["println",{"_index":1496,"title":{},"name":{},"text":{"14":{},"24":{},"25":{}},"component":{}}],["prioriti",{"_index":1637,"title":{},"name":{},"text":{"16":{},"24":{}},"component":{}}],["priority_queue::priorityqueu",{"_index":2942,"title":{},"name":{},"text":{"24":{}},"component":{}}],["priorityqueu",{"_index":3027,"title":{},"name":{},"text":{"24":{}},"component":{}}],["priorityqueue::::with_default_hash",{"_index":3034,"title":{},"name":{},"text":{"24":{}},"component":{}}],["prism",{"_index":2760,"title":{},"name":{},"text":{"23":{}},"component":{}}],["problem",{"_index":1,"title":{"1-2":{}},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["procedur",{"_index":1513,"title":{},"name":{},"text":{"14":{}},"component":{}}],["process",{"_index":1673,"title":{},"name":{},"text":{"16":{},"23":{}},"component":{}}],["processor",{"_index":3102,"title":{},"name":{},"text":{"25":{}},"component":{}}],["processor’",{"_index":3105,"title":{},"name":{},"text":{"25":{}},"component":{}}],["produc",{"_index":1521,"title":{},"name":{},"text":{"15":{}},"component":{}}],["product",{"_index":727,"title":{},"name":{},"text":{"6":{},"17":{}},"component":{}}],["program",{"_index":96,"title":{},"name":{},"text":{"1":{},"25":{}},"component":{}}],["progress",{"_index":534,"title":{},"name":{},"text":{"5":{}},"component":{}}],["progress.cols[3",{"_index":556,"title":{},"name":{},"text":{"5":{}},"component":{}}],["progress.rows[2",{"_index":555,"title":{},"name":{},"text":{"5":{}},"component":{}}],["projectil",{"_index":1964,"title":{},"name":{},"text":{"18":{}},"component":{}}],["proof",{"_index":840,"title":{},"name":{},"text":{"8":{}},"component":{}}],["prove",{"_index":565,"title":{},"name":{},"text":{"5":{},"18":{}},"component":{}}],["provid",{"_index":27,"title":{},"name":{},"text":{"1":{},"20":{}},"component":{}}],["prs.filter_map(|r",{"_index":1247,"title":{},"name":{},"text":{"11":{}},"component":{}}],["ps",{"_index":1865,"title":{},"name":{},"text":{"17":{}},"component":{}}],["ps.remain",{"_index":1866,"title":{},"name":{},"text":{"17":{}},"component":{}}],["pt1",{"_index":162,"title":{},"name":{},"text":{"1":{},"17":{},"24":{}},"component":{}}],["pt1(&block",{"_index":3158,"title":{},"name":{},"text":{"25":{}},"component":{}}],["pt1(&cave_system",{"_index":1389,"title":{},"name":{},"text":{"13":{}},"component":{}}],["pt1(&endpoint",{"_index":696,"title":{},"name":{},"text":{"6":{}},"component":{}}],["pt1(&grid",{"_index":1707,"title":{},"name":{},"text":{"16":{}},"component":{}}],["pt1(&hm",{"_index":1151,"title":{},"name":{},"text":{"10":{}},"component":{}}],["pt1(&mat",{"_index":462,"title":{},"name":{},"text":{"4":{}},"component":{}}],["pt1(&mut",{"_index":3243,"title":{},"name":{},"text":{"26":{}},"component":{}}],["pt1(&num",{"_index":807,"title":{},"name":{},"text":{"8":{}},"component":{}}],["pt1(&p",{"_index":1877,"title":{},"name":{},"text":{"17":{}},"component":{}}],["pt1(&paper",{"_index":1477,"title":{},"name":{},"text":{"14":{}},"component":{}}],["pt1(&polym",{"_index":1624,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pt1(&scanner",{"_index":2569,"title":{},"name":{},"text":{"20":{}},"component":{}}],["pt1(&snail_num",{"_index":2276,"title":{},"name":{},"text":{"19":{}},"component":{}}],["pt1(&snailnumowned::from_lin",{"_index":2356,"title":{},"name":{},"text":{"19":{}},"component":{}}],["pt1(&snailnumowned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4",{"_index":2359,"title":{},"name":{},"text":{"19":{}},"component":{}}],["pt1(&timer",{"_index":775,"title":{},"name":{},"text":{"7":{}},"component":{}}],["pt1(block",{"_index":3209,"title":{},"name":{},"text":{"25":{}},"component":{}}],["pt1(cave",{"_index":1391,"title":{},"name":{},"text":{"13":{}},"component":{}}],["pt1(directions.it",{"_index":395,"title":{},"name":{},"text":{"3":{}},"component":{}}],["pt1(endpoint",{"_index":706,"title":{},"name":{},"text":{"6":{}},"component":{}}],["pt1(game1",{"_index":624,"title":{},"name":{},"text":{"5":{}},"component":{}}],["pt1(garden",{"_index":3245,"title":{},"name":{},"text":{"26":{}},"component":{}}],["pt1(grid",{"_index":1709,"title":{},"name":{},"text":{"16":{}},"component":{}}],["pt1(hm",{"_index":1165,"title":{},"name":{},"text":{"10":{}},"component":{}}],["pt1(im",{"_index":2657,"title":{},"name":{},"text":{"21":{}},"component":{}}],["pt1(im1",{"_index":2655,"title":{},"name":{},"text":{"21":{}},"component":{}}],["pt1(input",{"_index":341,"title":{},"name":{},"text":{"2":{}},"component":{}}],["pt1(mat",{"_index":464,"title":{},"name":{},"text":{"4":{}},"component":{}}],["pt1(mut",{"_index":626,"title":{},"name":{},"text":{"5":{},"22":{}},"component":{}}],["pt1(octopi",{"_index":1301,"title":{},"name":{},"text":{"12":{}},"component":{}}],["pt1(octopi.clon",{"_index":1296,"title":{},"name":{},"text":{"12":{}},"component":{}}],["pt1(output_digits.it",{"_index":1098,"title":{},"name":{},"text":{"9":{}},"component":{}}],["pt1(packet",{"_index":1879,"title":{},"name":{},"text":{"17":{}},"component":{}}],["pt1(paper",{"_index":1481,"title":{},"name":{},"text":{"14":{}},"component":{}}],["pt1(parsed_lines.it",{"_index":1244,"title":{},"name":{},"text":{"11":{}},"component":{}}],["pt1(player",{"_index":2712,"title":{},"name":{},"text":{"22":{}},"component":{}}],["pt1(polym",{"_index":1626,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pt1(scanner",{"_index":2571,"title":{},"name":{},"text":{"20":{}},"component":{}}],["pt1(steps.it",{"_index":2894,"title":{},"name":{},"text":{"23":{}},"component":{}}],["pt1(timer",{"_index":778,"title":{},"name":{},"text":{"7":{}},"component":{}}],["pt1(trajectories.it",{"_index":2048,"title":{},"name":{},"text":{"18":{}},"component":{}}],["pt1:expr",{"_index":186,"title":{},"name":{},"text":{"1":{}},"component":{}}],["pt1>(num",{"_index":809,"title":{},"name":{},"text":{"8":{}},"component":{}}],["pt1>(out_digit",{"_index":1100,"title":{},"name":{},"text":{"9":{}},"component":{}}],["pt1>(pr",{"_index":1246,"title":{},"name":{},"text":{"11":{}},"component":{}}],["pt1>(snail_num",{"_index":2277,"title":{},"name":{},"text":{"19":{}},"component":{}}],["pt1>(step",{"_index":397,"title":{},"name":{},"text":{"3":{},"23":{}},"component":{}}],["pt1>(trajectori",{"_index":2066,"title":{},"name":{},"text":{"18":{}},"component":{}}],["pt1_val",{"_index":1918,"title":{},"name":{},"text":{"17":{}},"component":{}}],["pt2",{"_index":164,"title":{},"name":{},"text":{"1":{},"14":{},"17":{},"24":{}},"component":{}}],["pt2(&block",{"_index":3159,"title":{},"name":{},"text":{"25":{}},"component":{}}],["pt2(&cave_system))).into",{"_index":1390,"title":{},"name":{},"text":{"13":{}},"component":{}}],["pt2(&endpoints))).into",{"_index":697,"title":{},"name":{},"text":{"6":{}},"component":{}}],["pt2(&grid))).into",{"_index":1708,"title":{},"name":{},"text":{"16":{}},"component":{}}],["pt2(&hm))).into",{"_index":1152,"title":{},"name":{},"text":{"10":{}},"component":{}}],["pt2(&mat))).into",{"_index":463,"title":{},"name":{},"text":{"4":{}},"component":{}}],["pt2(&nums))).into",{"_index":808,"title":{},"name":{},"text":{"8":{}},"component":{}}],["pt2(&p).unwrap())).into",{"_index":1878,"title":{},"name":{},"text":{"17":{}},"component":{}}],["pt2(&paper",{"_index":1479,"title":{},"name":{},"text":{"14":{}},"component":{}}],["pt2(&polymer))).into",{"_index":1625,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pt2(&timers))).into",{"_index":776,"title":{},"name":{},"text":{"7":{}},"component":{}}],["pt2(&translations))).into",{"_index":2570,"title":{},"name":{},"text":{"20":{}},"component":{}}],["pt2())).into",{"_index":3091,"title":{},"name":{},"text":{"24":{}},"component":{}}],["pt2(block",{"_index":3211,"title":{},"name":{},"text":{"25":{}},"component":{}}],["pt2(cave",{"_index":1393,"title":{},"name":{},"text":{"13":{}},"component":{}}],["pt2(directions.iter()))).into",{"_index":396,"title":{},"name":{},"text":{"3":{}},"component":{}}],["pt2(endpoint",{"_index":712,"title":{},"name":{},"text":{"6":{}},"component":{}}],["pt2(game2))).into",{"_index":625,"title":{},"name":{},"text":{"5":{}},"component":{}}],["pt2(grid",{"_index":1732,"title":{},"name":{},"text":{"16":{}},"component":{}}],["pt2(hm",{"_index":1190,"title":{},"name":{},"text":{"10":{}},"component":{}}],["pt2(im",{"_index":2662,"title":{},"name":{},"text":{"21":{}},"component":{}}],["pt2(im2))).into",{"_index":2656,"title":{},"name":{},"text":{"21":{}},"component":{}}],["pt2(input",{"_index":349,"title":{},"name":{},"text":{"2":{},"19":{}},"component":{}}],["pt2(input))).into",{"_index":342,"title":{},"name":{},"text":{"2":{},"19":{}},"component":{}}],["pt2(mat",{"_index":511,"title":{},"name":{},"text":{"4":{}},"component":{}}],["pt2(mut",{"_index":633,"title":{},"name":{},"text":{"5":{},"12":{}},"component":{}}],["pt2(octopi))).into",{"_index":1297,"title":{},"name":{},"text":{"12":{}},"component":{}}],["pt2(output_digits.iter()))).into",{"_index":1099,"title":{},"name":{},"text":{"9":{}},"component":{}}],["pt2(packet",{"_index":1904,"title":{},"name":{},"text":{"17":{}},"component":{}}],["pt2(parsed_lines.iter()))).into",{"_index":1245,"title":{},"name":{},"text":{"11":{}},"component":{}}],["pt2(player",{"_index":2714,"title":{},"name":{},"text":{"22":{}},"component":{}}],["pt2(polym",{"_index":1627,"title":{},"name":{},"text":{"15":{}},"component":{}}],["pt2(steps.iter()))).into",{"_index":2895,"title":{},"name":{},"text":{"23":{}},"component":{}}],["pt2(timer",{"_index":781,"title":{},"name":{},"text":{"7":{}},"component":{}}],["pt2(trajectories.iter()))).into",{"_index":2049,"title":{},"name":{},"text":{"18":{}},"component":{}}],["pt2)).into",{"_index":189,"title":{},"name":{},"text":{"1":{}},"component":{}}],["pt2:expr",{"_index":187,"title":{},"name":{},"text":{"1":{}},"component":{}}],["pt2>(num",{"_index":820,"title":{},"name":{},"text":{"8":{}},"component":{}}],["pt2>(out_digit",{"_index":1105,"title":{},"name":{},"text":{"9":{}},"component":{}}],["pt2>(pr",{"_index":1254,"title":{},"name":{},"text":{"11":{}},"component":{}}],["pt2>(step",{"_index":401,"title":{},"name":{},"text":{"3":{},"23":{}},"component":{}}],["pt2>(translat",{"_index":2573,"title":{},"name":{},"text":{"20":{}},"component":{}}],["pt2_val",{"_index":1921,"title":{},"name":{},"text":{"17":{}},"component":{}}],["pub",{"_index":128,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["pub(crat",{"_index":119,"title":{},"name":{},"text":{"1":{}},"component":{}}],["purpos",{"_index":83,"title":{},"name":{},"text":{"1":{}},"component":{}}],["push",{"_index":1342,"title":{},"name":{},"text":{"13":{},"17":{}},"component":{}}],["push(cave::new(dest",{"_index":1368,"title":{},"name":{},"text":{"13":{}},"component":{}}],["puzzl",{"_index":2380,"title":{},"name":{},"text":{"20":{}},"component":{}}],["python",{"_index":54,"title":{},"name":{},"text":{"1":{}},"component":{}}],["quantiti",{"_index":1775,"title":{},"name":{},"text":{"17":{}},"component":{}}],["quarter",{"_index":2470,"title":{},"name":{},"text":{"20":{}},"component":{}}],["quartet",{"_index":1751,"title":{},"name":{},"text":{"17":{}},"component":{}}],["queri",{"_index":1267,"title":{},"name":{},"text":{"12":{}},"component":{}}],["question",{"_index":743,"title":{},"name":{},"text":{"6":{},"23":{}},"component":{}}],["queue",{"_index":1638,"title":{},"name":{},"text":{"16":{},"24":{}},"component":{}}],["quickli",{"_index":2931,"title":{},"name":{},"text":{"24":{}},"component":{}}],["quot",{"_index":728,"title":{},"name":{},"text":{"6":{}},"component":{}}],["r",{"_index":589,"title":{},"name":{},"text":{"5":{},"10":{},"11":{},"12":{},"18":{},"20":{},"21":{},"25":{}},"component":{}}],["r.borrow",{"_index":1248,"title":{},"name":{},"text":{"11":{}},"component":{}}],["r1",{"_index":2733,"title":{},"name":{},"text":{"22":{}},"component":{}}],["r2",{"_index":2735,"title":{},"name":{},"text":{"22":{}},"component":{}}],["r3",{"_index":2736,"title":{},"name":{},"text":{"22":{}},"component":{}}],["r=[x_\\mathrm{min",{"_index":1967,"title":{},"name":{},"text":{"18":{}},"component":{}}],["r\\)'",{"_index":1980,"title":{},"name":{},"text":{"18":{}},"component":{}}],["r_elem",{"_index":2198,"title":{},"name":{},"text":{"19":{}},"component":{}}],["r_idx",{"_index":2197,"title":{},"name":{},"text":{"19":{}},"component":{}}],["r_min",{"_index":1702,"title":{},"name":{},"text":{"16":{}},"component":{}}],["rang",{"_index":665,"title":{},"name":{},"text":{"6":{},"22":{},"24":{},"25":{}},"component":{}}],["range_between(a",{"_index":663,"title":{},"name":{},"text":{"6":{}},"component":{}}],["range_between(x1",{"_index":702,"title":{},"name":{},"text":{"6":{}},"component":{}}],["range_between(y1",{"_index":703,"title":{},"name":{},"text":{"6":{}},"component":{}}],["rd",{"_index":1861,"title":{},"name":{},"text":{"17":{}},"component":{}}],["re",{"_index":1571,"title":{},"name":{},"text":{"15":{},"18":{}},"component":{}}],["re.captures(input.trim",{"_index":2007,"title":{},"name":{},"text":{"18":{}},"component":{}}],["reach",{"_index":1663,"title":{},"name":{},"text":{"16":{},"18":{}},"component":{}}],["reachabl",{"_index":1338,"title":{},"name":{},"text":{"13":{}},"component":{}}],["reactor",{"_index":272,"title":{"23":{}},"name":{},"text":{"1":{}},"component":{}}],["read",{"_index":40,"title":{},"name":{},"text":{"1":{},"4":{},"5":{},"6":{},"8":{},"14":{},"20":{},"25":{}},"component":{}}],["read_input(",{"_index":385,"title":{},"name":{},"text":{"3":{},"8":{},"20":{},"22":{},"25":{}},"component":{}}],["read_input(input",{"_index":443,"title":{},"name":{},"text":{"4":{},"7":{},"9":{},"11":{},"14":{},"16":{},"17":{},"18":{},"23":{}},"component":{}}],["read_input(input).unwrap",{"_index":394,"title":{},"name":{},"text":{"3":{},"4":{},"7":{},"8":{},"11":{},"16":{},"18":{},"20":{},"22":{},"23":{},"25":{}},"component":{}}],["read_input::(include_str!(\"sample_input.txt\")).unwrap",{"_index":1498,"title":{},"name":{},"text":{"14":{}},"component":{}}],["read_input::(input).unwrap",{"_index":1476,"title":{},"name":{},"text":{"14":{}},"component":{}}],["read_input_into_gam",{"_index":559,"title":{},"name":{},"text":{"5":{}},"component":{}}],["reader",{"_index":2086,"title":{},"name":{},"text":{"18":{}},"component":{}}],["real",{"_index":2153,"title":{},"name":{},"text":{"19":{}},"component":{}}],["realiz",{"_index":2911,"title":{},"name":{},"text":{"24":{}},"component":{}}],["realli",{"_index":361,"title":{},"name":{},"text":{"3":{},"16":{},"17":{}},"component":{}}],["realm",{"_index":2688,"title":{},"name":{},"text":{"22":{}},"component":{}}],["reason",{"_index":61,"title":{},"name":{},"text":{"1":{},"5":{}},"component":{}}],["reboot",{"_index":273,"title":{"23":{}},"name":{},"text":{"1":{}},"component":{}}],["rebootstep",{"_index":2860,"title":{},"name":{},"text":{"23":{}},"component":{}}],["receiv",{"_index":928,"title":{},"name":{},"text":{"9":{}},"component":{}}],["record",{"_index":931,"title":{},"name":{},"text":{"9":{},"19":{},"23":{}},"component":{}}],["rect",{"_index":1996,"title":{},"name":{},"text":{"18":{}},"component":{}}],["rectangular",{"_index":1966,"title":{},"name":{},"text":{"18":{},"23":{}},"component":{}}],["recurs",{"_index":2374,"title":{},"name":{},"text":{"19":{}},"component":{}}],["reduc",{"_index":1882,"title":{},"name":{},"text":{"17":{},"19":{}},"component":{}}],["reduce(&mut",{"_index":2184,"title":{},"name":{},"text":{"19":{}},"component":{}}],["reduce(max",{"_index":1900,"title":{},"name":{},"text":{"17":{}},"component":{}}],["reduce(min",{"_index":1899,"title":{},"name":{},"text":{"17":{}},"component":{}}],["reduce(product",{"_index":1898,"title":{},"name":{},"text":{"17":{}},"component":{}}],["reduce(reduc",{"_index":1895,"title":{},"name":{},"text":{"17":{}},"component":{}}],["reduce(sum",{"_index":1897,"title":{},"name":{},"text":{"17":{}},"component":{}}],["reduce(|a",{"_index":205,"title":{},"name":{},"text":{"1":{}},"component":{}}],["reduce_once(&mut",{"_index":2181,"title":{},"name":{},"text":{"19":{}},"component":{}}],["reduced(&self",{"_index":2231,"title":{},"name":{},"text":{"19":{}},"component":{}}],["reducer.ident",{"_index":1911,"title":{},"name":{},"text":{"17":{}},"component":{}}],["redund",{"_index":1048,"title":{},"name":{},"text":{"9":{}},"component":{}}],["redundant_key",{"_index":1053,"title":{},"name":{},"text":{"9":{}},"component":{}}],["redundant_keys.insert(segment_union",{"_index":1061,"title":{},"name":{},"text":{"9":{}},"component":{}}],["refer",{"_index":1323,"title":{},"name":{},"text":{"13":{},"20":{},"21":{},"23":{},"25":{}},"component":{}}],["refin",{"_index":1113,"title":{},"name":{},"text":{"9":{}},"component":{}}],["reflect",{"_index":1428,"title":{},"name":{},"text":{"14":{}},"component":{}}],["reg(regist",{"_index":3118,"title":{},"name":{},"text":{"25":{}},"component":{}}],["reg(register::from_str(",{"_index":3120,"title":{},"name":{},"text":{"25":{}},"component":{}}],["regardless",{"_index":1943,"title":{},"name":{},"text":{"17":{}},"component":{}}],["regex::new(r\"(\\d+),(\\d+)\\",{"_index":679,"title":{},"name":{},"text":{"6":{}},"component":{}}],["regex::regex",{"_index":669,"title":{},"name":{},"text":{"6":{}},"component":{}}],["regex::regex::new(r\"target",{"_index":2004,"title":{},"name":{},"text":{"18":{}},"component":{}}],["region",{"_index":1126,"title":{},"name":{},"text":{"10":{},"18":{},"20":{},"23":{}},"component":{}}],["regist",{"_index":3103,"title":{},"name":{},"text":{"25":{}},"component":{}}],["register::from_str(splat.next",{"_index":3152,"title":{},"name":{},"text":{"25":{}},"component":{}}],["register::z",{"_index":3182,"title":{},"name":{},"text":{"25":{}},"component":{}}],["rel",{"_index":856,"title":{},"name":{},"text":{"8":{}},"component":{}}],["relax",{"_index":1406,"title":{},"name":{},"text":{"13":{}},"component":{}}],["releas",{"_index":2589,"title":{},"name":{},"text":{"20":{},"25":{}},"component":{}}],["remain",{"_index":1424,"title":{},"name":{},"text":{"14":{},"17":{},"21":{},"23":{}},"component":{}}],["remaining.is_empti",{"_index":1820,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata",{"_index":1805,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::nbits(0",{"_index":1810,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::nbits(n",{"_index":1830,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::nbits(n_bit",{"_index":1851,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::npackets(0",{"_index":1811,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::npackets(1",{"_index":1816,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::npackets(_",{"_index":1862,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::npackets(n",{"_index":1831,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::npackets(n_packet",{"_index":1849,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remainingdata::numbit",{"_index":1868,"title":{},"name":{},"text":{"17":{}},"component":{}}],["remov",{"_index":535,"title":{},"name":{},"text":{"5":{},"9":{},"15":{},"20":{},"23":{}},"component":{}}],["reorder",{"_index":2921,"title":{},"name":{},"text":{"24":{}},"component":{}}],["repeat",{"_index":1672,"title":{},"name":{},"text":{"16":{},"20":{}},"component":{}}],["repeatedli",{"_index":1111,"title":{},"name":{},"text":{"9":{},"20":{}},"component":{}}],["replac",{"_index":1669,"title":{},"name":{},"text":{"16":{},"19":{},"21":{}},"component":{}}],["repr(us",{"_index":2953,"title":{},"name":{},"text":{"24":{}},"component":{}}],["repres",{"_index":523,"title":{},"name":{},"text":{"5":{},"13":{}},"component":{}}],["request",{"_index":1529,"title":{},"name":{},"text":{"15":{}},"component":{}}],["requir",{"_index":410,"title":{},"name":{},"text":{"4":{},"6":{},"7":{},"17":{},"18":{},"20":{},"21":{},"25":{}},"component":{}}],["residu",{"_index":92,"title":{},"name":{},"text":{"1":{}},"component":{}}],["respect",{"_index":1549,"title":{},"name":{},"text":{"15":{},"19":{},"20":{},"23":{}},"component":{}}],["rest",{"_index":2538,"title":{},"name":{},"text":{"20":{},"21":{}},"component":{}}],["rest.is_empti",{"_index":2541,"title":{},"name":{},"text":{"20":{}},"component":{}}],["rest.iter().enumer",{"_index":2544,"title":{},"name":{},"text":{"20":{}},"component":{}}],["result",{"_index":68,"title":{},"name":{},"text":{"1":{},"9":{},"11":{},"14":{},"15":{},"17":{},"19":{},"21":{},"23":{},"25":{}},"component":{}}],["result.into",{"_index":1073,"title":{},"name":{},"text":{"9":{}},"component":{}}],["ret",{"_index":2710,"title":{},"name":{},"text":{"22":{}},"component":{}}],["retrac",{"_index":2053,"title":{},"name":{},"text":{"18":{}},"component":{}}],["return",{"_index":381,"title":{},"name":{},"text":{"3":{},"5":{},"6":{},"9":{},"11":{},"14":{},"16":{},"18":{},"19":{},"20":{},"23":{},"24":{},"25":{}},"component":{}}],["rev",{"_index":199,"title":{},"name":{},"text":{"1":{},"9":{}},"component":{}}],["rewir",{"_index":914,"title":{},"name":{},"text":{"9":{}},"component":{}}],["rh",{"_index":976,"title":{},"name":{},"text":{"9":{}},"component":{}}],["right",{"_index":1215,"title":{},"name":{},"text":{"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"26":{}},"component":{}}],["right.magnitud",{"_index":2269,"title":{},"name":{},"text":{"19":{}},"component":{}}],["rights.insert(loc",{"_index":3225,"title":{},"name":{},"text":{"26":{}},"component":{}}],["rins",{"_index":2405,"title":{},"name":{},"text":{"20":{}},"component":{}}],["roll",{"_index":2670,"title":{},"name":{},"text":{"22":{}},"component":{}}],["roll(&mut",{"_index":2706,"title":{},"name":{},"text":{"22":{}},"component":{}}],["roll_deterministic_die(&mut",{"_index":2698,"title":{},"name":{},"text":{"22":{}},"component":{}}],["roll_valu",{"_index":2742,"title":{},"name":{},"text":{"22":{}},"component":{}}],["roll_value(&mut",{"_index":2693,"title":{},"name":{},"text":{"22":{}},"component":{}}],["room",{"_index":2918,"title":{},"name":{},"text":{"24":{}},"component":{}}],["room’",{"_index":2922,"title":{},"name":{},"text":{"24":{}},"component":{}}],["root",{"_index":293,"title":{},"name":{},"text":{"18":{}},"component":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}}}],["roots::sqrt(&n",{"_index":2011,"title":{},"name":{},"text":{"18":{}},"component":{}}],["rotat",{"_index":2384,"title":{},"name":{},"text":{"20":{}},"component":{}}],["rotation_about_up",{"_index":2473,"title":{},"name":{},"text":{"20":{}},"component":{}}],["rotationccw",{"_index":2469,"title":{},"name":{},"text":{"20":{}},"component":{}}],["rotationccw::it",{"_index":2518,"title":{},"name":{},"text":{"20":{}},"component":{}}],["rotationccw::zero",{"_index":2476,"title":{},"name":{},"text":{"20":{}},"component":{}}],["roughli",{"_index":1749,"title":{},"name":{},"text":{"17":{},"24":{}},"component":{}}],["round",{"_index":839,"title":{},"name":{},"text":{"8":{},"19":{}},"component":{}}],["row",{"_index":532,"title":{},"name":{},"text":{"5":{},"10":{},"12":{},"16":{},"20":{},"24":{},"26":{}},"component":{}}],["row(&self",{"_index":2439,"title":{},"name":{},"text":{"20":{}},"component":{}}],["row/column",{"_index":544,"title":{},"name":{},"text":{"5":{}},"component":{}}],["rule",{"_index":1755,"title":{},"name":{},"text":{"17":{},"19":{},"21":{},"24":{}},"component":{}}],["ruleset",{"_index":2917,"title":{},"name":{},"text":{"24":{}},"component":{}}],["run",{"_index":302,"title":{},"name":{},"text":{"2":{},"15":{},"18":{},"24":{},"25":{}},"component":{}}],["run_block(&mut",{"_index":3131,"title":{},"name":{},"text":{"25":{}},"component":{}}],["run_until_no_movement(&mut",{"_index":3240,"title":{},"name":{},"text":{"26":{}},"component":{}}],["rust",{"_index":11,"title":{},"name":{},"text":{"1":{}},"component":{}}],["rust’",{"_index":98,"title":{},"name":{},"text":{"1":{},"24":{}},"component":{}}],["s",{"_index":379,"title":{},"name":{},"text":{"3":{},"16":{},"17":{},"20":{},"23":{},"25":{}},"component":{}}],["s*(\\d+),(\\d+)\").ok",{"_index":680,"title":{},"name":{},"text":{"6":{}},"component":{}}],["s*y=([\\d",{"_index":2006,"title":{},"name":{},"text":{"18":{}},"component":{}}],["s.borrow",{"_index":2545,"title":{},"name":{},"text":{"20":{}},"component":{}}],["s.byte",{"_index":971,"title":{},"name":{},"text":{"9":{}},"component":{}}],["s.line",{"_index":386,"title":{},"name":{},"text":{"3":{},"10":{},"12":{},"15":{},"21":{},"22":{}},"component":{}}],["s.lines().chain(std::iter::onc",{"_index":603,"title":{},"name":{},"text":{"5":{},"20":{}},"component":{}}],["s.lines().chain(std::iter::once(\"inp",{"_index":3144,"title":{},"name":{},"text":{"25":{}},"component":{}}],["s.lines().count",{"_index":1140,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["s.lines().enumer",{"_index":2985,"title":{},"name":{},"text":{"24":{}},"component":{}}],["s.lines().next()?.chars().count",{"_index":1138,"title":{},"name":{},"text":{"10":{}},"component":{}}],["s.lines().next()?.len",{"_index":1272,"title":{},"name":{},"text":{"12":{}},"component":{}}],["s.lines().nth_back(0)?.trim().len",{"_index":2622,"title":{},"name":{},"text":{"21":{}},"component":{}}],["s.parse().ok",{"_index":761,"title":{},"name":{},"text":{"7":{},"25":{}},"component":{}}],["s.parse::().ok",{"_index":607,"title":{},"name":{},"text":{"5":{}},"component":{}}],["s.split",{"_index":2853,"title":{},"name":{},"text":{"23":{}},"component":{}}],["s.split_whitespac",{"_index":1435,"title":{},"name":{},"text":{"14":{}},"component":{}}],["s.trim",{"_index":804,"title":{},"name":{},"text":{"8":{}},"component":{}}],["s.trim().char",{"_index":1799,"title":{},"name":{},"text":{"17":{}},"component":{}}],["same",{"_index":15,"title":{},"name":{},"text":{"1":{},"2":{},"5":{},"9":{},"15":{},"19":{},"21":{},"23":{}},"component":{}}],["satisfi",{"_index":415,"title":{},"name":{},"text":{"4":{},"6":{},"18":{}},"component":{}}],["save",{"_index":2905,"title":{},"name":{},"text":{"23":{}},"component":{}}],["scanner",{"_index":264,"title":{"20":{}},"name":{},"text":{"1":{},"20":{}},"component":{}}],["scanner.beacons.len",{"_index":2572,"title":{},"name":{},"text":{"20":{}},"component":{}}],["scanner::merge_al",{"_index":2415,"title":{},"name":{},"text":{"20":{}},"component":{}}],["scanner::merge_all(new_scann",{"_index":2555,"title":{},"name":{},"text":{"20":{}},"component":{}}],["scanner::merge_all(scanners).unwrap",{"_index":2566,"title":{},"name":{},"text":{"20":{}},"component":{}}],["scanner::new(self.beacons.iter().map(|&p",{"_index":2513,"title":{},"name":{},"text":{"20":{}},"component":{}}],["scanners.as_ref",{"_index":2537,"title":{},"name":{},"text":{"20":{}},"component":{}}],["scanners.push(scanner::new(this_scanner_beacons.clon",{"_index":2560,"title":{},"name":{},"text":{"20":{}},"component":{}}],["scanners.split_first().unwrap",{"_index":2539,"title":{},"name":{},"text":{"20":{}},"component":{}}],["scanner’",{"_index":2594,"title":{},"name":{},"text":{"20":{}},"component":{}}],["schemat",{"_index":887,"title":{},"name":{},"text":{"9":{}},"component":{}}],["scheme",{"_index":924,"title":{},"name":{},"text":{"9":{}},"component":{}}],["score",{"_index":239,"title":{"11":{}},"name":{},"text":{"1":{},"11":{},"22":{}},"component":{}}],["scores.sort_unst",{"_index":1261,"title":{},"name":{},"text":{"11":{}},"component":{}}],["scores[scores.len",{"_index":1262,"title":{},"name":{},"text":{"11":{}},"component":{}}],["se",{"_index":1543,"title":{},"name":{},"text":{"15":{}},"component":{}}],["sea",{"_index":281,"title":{"26":{}},"name":{},"text":{"1":{}},"component":{}}],["seagarden",{"_index":3215,"title":{},"name":{},"text":{"26":{}},"component":{}}],["seagarden::from_str(input",{"_index":3242,"title":{},"name":{},"text":{"26":{}},"component":{}}],["search",{"_index":233,"title":{"9":{}},"name":{},"text":{"1":{},"24":{}},"component":{}}],["second",{"_index":1410,"title":{},"name":{},"text":{"13":{},"15":{},"16":{},"17":{},"19":{}},"component":{}}],["second_po",{"_index":1604,"title":{},"name":{},"text":{"15":{}},"component":{}}],["second_pos)).or_default",{"_index":1608,"title":{},"name":{},"text":{"15":{}},"component":{}}],["section",{"_index":435,"title":{},"name":{},"text":{"4":{},"13":{}},"component":{}}],["see",{"_index":434,"title":{},"name":{},"text":{"4":{},"9":{},"11":{},"15":{},"16":{}},"component":{}}],["seen",{"_index":936,"title":{},"name":{},"text":{"9":{},"24":{}},"component":{}}],["seen.contains(&st",{"_index":3028,"title":{},"name":{},"text":{"24":{}},"component":{}}],["seen.insert(st",{"_index":3029,"title":{},"name":{},"text":{"24":{}},"component":{}}],["segment",{"_index":232,"title":{"9":{}},"name":{},"text":{"1":{},"9":{}},"component":{}}],["segment_union",{"_index":1059,"title":{},"name":{},"text":{"9":{}},"component":{}}],["segments.iter().filter(|&&b",{"_index":969,"title":{},"name":{},"text":{"9":{}},"component":{}}],["segments.map(|i",{"_index":992,"title":{},"name":{},"text":{"9":{}},"component":{}}],["segments[usize::from(i",{"_index":973,"title":{},"name":{},"text":{"9":{}},"component":{}}],["self",{"_index":173,"title":{},"name":{},"text":{"1":{},"5":{},"9":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["self([0",{"_index":2493,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self([x[0",{"_index":2430,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self(entri",{"_index":2455,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.0",{"_index":1802,"title":{},"name":{},"text":{"17":{},"20":{}},"component":{}}],["self.0.iter().enumerate().map(|(i",{"_index":2970,"title":{},"name":{},"text":{"24":{}},"component":{}}],["self.0[3",{"_index":2441,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.0[i",{"_index":2444,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.0[self::index_for(am",{"_index":2972,"title":{},"name":{},"text":{"24":{}},"component":{}}],["self._bin_op(rh",{"_index":983,"title":{},"name":{},"text":{"9":{}},"component":{}}],["self.algo[index",{"_index":2629,"title":{},"name":{},"text":{"21":{}},"component":{}}],["self.algo[usize::try_from(to_decimal(surrounding_pixels)).unwrap",{"_index":2646,"title":{},"name":{},"text":{"21":{}},"component":{}}],["self.arr",{"_index":1285,"title":{},"name":{},"text":{"12":{}},"component":{}}],["self.arr.dim",{"_index":1156,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["self.arr.mapv_inplace(|x",{"_index":1282,"title":{},"name":{},"text":{"12":{}},"component":{}}],["self.arr[[base_row",{"_index":1292,"title":{},"name":{},"text":{"12":{}},"component":{}}],["self.arr[idx",{"_index":1155,"title":{},"name":{},"text":{"10":{}},"component":{}}],["self.arr[nghbr_idx",{"_index":1185,"title":{},"name":{},"text":{"10":{}},"component":{}}],["self.as_pair",{"_index":2266,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self.beacon",{"_index":2525,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.beacons.union(&other.beacons).copied().collect",{"_index":2510,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.bound",{"_index":2876,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.burrow.til",{"_index":3005,"title":{},"name":{},"text":{"24":{}},"component":{}}],["self.clon",{"_index":1464,"title":{},"name":{},"text":{"14":{}},"component":{}}],["self.cols[col",{"_index":582,"title":{},"name":{},"text":{"5":{}},"component":{}}],["self.cuboid",{"_index":2866,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.depth",{"_index":2247,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self.dot",{"_index":1460,"title":{},"name":{},"text":{"14":{}},"component":{}}],["self.dots.contains(&point(x",{"_index":1489,"title":{},"name":{},"text":{"14":{}},"component":{}}],["self.down",{"_index":3236,"title":{},"name":{},"text":{"26":{}},"component":{}}],["self.downs.contains(&new_loc",{"_index":3232,"title":{},"name":{},"text":{"26":{}},"component":{}}],["self.downs.contains(p",{"_index":3222,"title":{},"name":{},"text":{"26":{}},"component":{}}],["self.edges[curr_cav",{"_index":1376,"title":{},"name":{},"text":{"13":{}},"component":{}}],["self.elem",{"_index":2194,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self.elems.as_ref",{"_index":2245,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self.elems.as_ref().is_empti",{"_index":2272,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self.explode_first().is_som",{"_index":2182,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self.get_initial_char_pair_count",{"_index":1597,"title":{},"name":{},"text":{"15":{}},"component":{}}],["self.grid.keys().copied().sum",{"_index":602,"title":{},"name":{},"text":{"5":{}},"component":{}}],["self.grid.remove(&n",{"_index":594,"title":{},"name":{},"text":{"5":{}},"component":{}}],["self.h",{"_index":371,"title":{},"name":{},"text":{"3":{}},"component":{}}],["self.has_won",{"_index":580,"title":{},"name":{},"text":{"5":{}},"component":{}}],["self.height",{"_index":3217,"title":{},"name":{},"text":{"26":{}},"component":{}}],["self.intersection(oth",{"_index":2808,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.is_lower_than_neighbors([r",{"_index":1163,"title":{},"name":{},"text":{"10":{}},"component":{}}],["self.mapping.get(&(c1",{"_index":1602,"title":{},"name":{},"text":{"15":{}},"component":{}}],["self.mat",{"_index":2648,"title":{},"name":{},"text":{"21":{}},"component":{}}],["self.mat.ncol",{"_index":2632,"title":{},"name":{},"text":{"21":{}},"component":{}}],["self.mat.nrow",{"_index":2633,"title":{},"name":{},"text":{"21":{}},"component":{}}],["self.mat[[r",{"_index":2617,"title":{},"name":{},"text":{"21":{}},"component":{}}],["self.max",{"_index":2708,"title":{},"name":{},"text":{"22":{}},"component":{}}],["self.min",{"_index":2709,"title":{},"name":{},"text":{"22":{}},"component":{}}],["self.n_rol",{"_index":2711,"title":{},"name":{},"text":{"22":{}},"component":{}}],["self.next",{"_index":2707,"title":{},"name":{},"text":{"22":{}},"component":{}}],["self.on_cuboid",{"_index":2880,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.on_cuboids.iter().enumer",{"_index":2884,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.on_cuboids.iter().skip(i",{"_index":2886,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.on_cuboids.push(cuboid",{"_index":2878,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.orientation.flip",{"_index":1218,"title":{},"name":{},"text":{"11":{}},"component":{}}],["self.posit",{"_index":2695,"title":{},"name":{},"text":{"22":{}},"component":{}}],["self.progress.handle_entry(r",{"_index":597,"title":{},"name":{},"text":{"5":{}},"component":{}}],["self.progress.has_won",{"_index":599,"title":{},"name":{},"text":{"5":{}},"component":{}}],["self.reduce_onc",{"_index":2185,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self.registers[regist",{"_index":3130,"title":{},"name":{},"text":{"25":{}},"component":{}}],["self.right",{"_index":3230,"title":{},"name":{},"text":{"26":{}},"component":{}}],["self.rights.contains(&new_loc",{"_index":3231,"title":{},"name":{},"text":{"26":{}},"component":{}}],["self.rights.contains(p",{"_index":3221,"title":{},"name":{},"text":{"26":{}},"component":{}}],["self.roll_value(board",{"_index":2703,"title":{},"name":{},"text":{"22":{}},"component":{}}],["self.rotation_about_up",{"_index":2487,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.row(r",{"_index":2448,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.rows[row",{"_index":581,"title":{},"name":{},"text":{"5":{}},"component":{}}],["self.scor",{"_index":2697,"title":{},"name":{},"text":{"22":{}},"component":{}}],["self.split_first().is_som",{"_index":2183,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self.stat",{"_index":2862,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.surround",{"_index":2614,"title":{},"name":{},"text":{"21":{}},"component":{}}],["self.template.len",{"_index":1591,"title":{},"name":{},"text":{"15":{}},"component":{}}],["self.tick",{"_index":2650,"title":{},"name":{},"text":{"21":{},"26":{}},"component":{}}],["self.til",{"_index":3013,"title":{},"name":{},"text":{"24":{}},"component":{}}],["self.tiles.nrow",{"_index":3033,"title":{},"name":{},"text":{"24":{}},"component":{}}],["self.translation.apply(self.swivel.apply(point",{"_index":2507,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.traverse_help",{"_index":1383,"title":{},"name":{},"text":{"13":{}},"component":{}}],["self.up_fac",{"_index":2479,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self.v",{"_index":372,"title":{},"name":{},"text":{"3":{}},"component":{}}],["self.width",{"_index":3216,"title":{},"name":{},"text":{"26":{}},"component":{}}],["self.x_rang",{"_index":2786,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.y_rang",{"_index":2788,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self.z_rang",{"_index":2790,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self::by_adding_lines_in(input.lin",{"_index":2179,"title":{},"name":{},"text":{"19":{}},"component":{}}],["self::n_amphipods_per_kind",{"_index":2966,"title":{},"name":{},"text":{"24":{}},"component":{}}],["self::new(axis::posz",{"_index":2475,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self::new(seg",{"_index":974,"title":{},"name":{},"text":{"9":{}},"component":{}}],["self::new(self.segments.map(|b",{"_index":988,"title":{},"name":{},"text":{"9":{}},"component":{}}],["self::new(self.segments.zip(rhs.segments).map(|(x",{"_index":978,"title":{},"name":{},"text":{"9":{}},"component":{}}],["self::off",{"_index":2859,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self::on",{"_index":2858,"title":{},"name":{},"text":{"23":{}},"component":{}}],["self::output",{"_index":982,"title":{},"name":{},"text":{"9":{},"20":{},"24":{},"25":{}},"component":{}}],["self::x(valu",{"_index":1443,"title":{},"name":{},"text":{"14":{}},"component":{}}],["self::y(valu",{"_index":1444,"title":{},"name":{},"text":{"14":{}},"component":{}}],["self[block.in_reg",{"_index":3132,"title":{},"name":{},"text":{"25":{}},"component":{}}],["self[regist",{"_index":3135,"title":{},"name":{},"text":{"25":{}},"component":{}}],["self_row",{"_index":2447,"title":{},"name":{},"text":{"20":{}},"component":{}}],["self_row[i",{"_index":2453,"title":{},"name":{},"text":{"20":{}},"component":{}}],["send",{"_index":894,"title":{},"name":{},"text":{"9":{}},"component":{}}],["sens",{"_index":22,"title":{},"name":{},"text":{"1":{},"17":{},"24":{}},"component":{}}],["sensibl",{"_index":89,"title":{},"name":{},"text":{"1":{}},"component":{}}],["sent",{"_index":952,"title":{},"name":{},"text":{"9":{}},"component":{}}],["separ",{"_index":2602,"title":{},"name":{},"text":{"21":{},"24":{}},"component":{}}],["sequenc",{"_index":1516,"title":{},"name":{},"text":{"15":{},"22":{},"23":{},"24":{}},"component":{}}],["sequenti",{"_index":2758,"title":{},"name":{},"text":{"23":{}},"component":{}}],["serv",{"_index":563,"title":{},"name":{},"text":{"5":{}},"component":{}}],["set",{"_index":571,"title":{},"name":{},"text":{"5":{},"9":{},"10":{},"13":{},"14":{},"16":{},"17":{},"18":{},"19":{},"23":{},"25":{},"26":{}},"component":{}}],["set::new",{"_index":1031,"title":{},"name":{},"text":{"9":{},"10":{},"14":{},"25":{},"26":{}},"component":{}}],["setup",{"_index":0,"title":{"1-1":{},"2-1":{},"3-1":{},"4-1":{},"5-1":{},"6-1":{},"7-1":{},"8-1":{},"9-1":{},"10-1":{},"11-1":{},"12-1":{},"13-1":{},"14-1":{},"15-1":{},"16-1":{},"17-1":{},"18-1":{},"19-1":{},"20-1":{},"21-1":{},"22-1":{},"23-1":{},"24-1":{},"25-1":{},"26-1":{}},"name":{},"text":{"4":{},"9":{},"13":{},"24":{},"25":{}},"component":{}}],["setup(&mut",{"_index":3139,"title":{},"name":{},"text":{"25":{}},"component":{}}],["seven",{"_index":231,"title":{"9":{}},"name":{},"text":{"1":{},"9":{},"22":{}},"component":{}}],["share",{"_index":1783,"title":{},"name":{},"text":{"17":{},"20":{},"21":{}},"component":{}}],["shift",{"_index":754,"title":{},"name":{},"text":{"7":{}},"component":{}}],["shortcut",{"_index":800,"title":{},"name":{},"text":{"8":{}},"component":{}}],["shot",{"_index":259,"title":{"18":{}},"name":{},"text":{"1":{}},"component":{}}],["shouldn't",{"_index":1856,"title":{},"name":{},"text":{"17":{}},"component":{}}],["side",{"_index":871,"title":{},"name":{},"text":{"8":{},"22":{},"24":{}},"component":{}}],["sideroom(_",{"_index":2978,"title":{},"name":{},"text":{"24":{}},"component":{}}],["sideroom(amphipodkind",{"_index":2977,"title":{},"name":{},"text":{"24":{}},"component":{}}],["sideroom(amphipodkind::for_col(col",{"_index":2991,"title":{},"name":{},"text":{"24":{}},"component":{}}],["sideroom_last_empty_row",{"_index":3064,"title":{},"name":{},"text":{"24":{}},"component":{}}],["sideroom_max_row",{"_index":3032,"title":{},"name":{},"text":{"24":{}},"component":{}}],["siderooms_available_for_amphipod",{"_index":3051,"title":{},"name":{},"text":{"24":{}},"component":{}}],["siderooms_available_for_amphipods[am.kind",{"_index":3060,"title":{},"name":{},"text":{"24":{}},"component":{}}],["sign",{"_index":2043,"title":{},"name":{},"text":{"18":{}},"component":{}}],["signific",{"_index":431,"title":{},"name":{},"text":{"4":{}},"component":{}}],["simpl",{"_index":2105,"title":{},"name":{},"text":{"18":{},"22":{},"25":{},"26":{}},"component":{}}],["simpli",{"_index":647,"title":{},"name":{},"text":{"5":{},"6":{},"8":{},"9":{},"15":{},"16":{},"18":{},"19":{},"20":{},"24":{}},"component":{}}],["simplic",{"_index":2764,"title":{},"name":{},"text":{"23":{}},"component":{}}],["simplif",{"_index":2916,"title":{},"name":{},"text":{"24":{}},"component":{}}],["simul",{"_index":2668,"title":{},"name":{},"text":{"22":{}},"component":{}}],["singl",{"_index":1409,"title":{},"name":{},"text":{"13":{},"14":{},"15":{},"17":{},"19":{},"21":{},"23":{},"24":{}},"component":{}}],["singleamphipodst",{"_index":3022,"title":{},"name":{},"text":{"24":{}},"component":{}}],["singleton",{"_index":2367,"title":{},"name":{},"text":{"19":{}},"component":{}}],["six",{"_index":2399,"title":{},"name":{},"text":{"20":{},"23":{}},"component":{}}],["size",{"_index":421,"title":{},"name":{},"text":{"4":{},"22":{},"24":{}},"component":{}}],["size(&self",{"_index":2906,"title":{},"name":{},"text":{"23":{}},"component":{}}],["slightli",{"_index":1405,"title":{},"name":{},"text":{"13":{}},"component":{}}],["slope",{"_index":733,"title":{},"name":{},"text":{"6":{}},"component":{}}],["slow",{"_index":1974,"title":{},"name":{},"text":{"18":{}},"component":{}}],["small",{"_index":1130,"title":{},"name":{},"text":{"10":{},"13":{},"23":{}},"component":{}}],["smaller",{"_index":876,"title":{},"name":{},"text":{"8":{}},"component":{}}],["smoke",{"_index":235,"title":{"10":{}},"name":{},"text":{"1":{}},"component":{}}],["sn",{"_index":2232,"title":{},"name":{},"text":{"19":{}},"component":{}}],["sn.reduc",{"_index":2234,"title":{},"name":{},"text":{"19":{}},"component":{}}],["sn1",{"_index":2282,"title":{},"name":{},"text":{"19":{}},"component":{}}],["sn1.add(sn2).magnitud",{"_index":2287,"title":{},"name":{},"text":{"19":{}},"component":{}}],["sn2",{"_index":2284,"title":{},"name":{},"text":{"19":{}},"component":{}}],["sn2.add(sn1).magnitud",{"_index":2289,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snail",{"_index":2189,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snail_num",{"_index":2274,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snail_num.magnitud",{"_index":2278,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snail_nums.iter().enumer",{"_index":2283,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snail_nums.iter().skip(i",{"_index":2285,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailfish",{"_index":261,"title":{"19":{}},"name":{},"text":{"1":{}},"component":{}}],["snailnum",{"_index":2157,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnum::borrowing(left",{"_index":2257,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnum::borrowing(right",{"_index":2258,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnum::owning(addend",{"_index":2173,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumborrow",{"_index":2160,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumown",{"_index":2159,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::by_adding_lines_in(vec",{"_index":2337,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::by_adding_lines_in(vec![\"[1,1",{"_index":2329,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::explode_first",{"_index":2305,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1",{"_index":2342,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4",{"_index":2333,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5",{"_index":2336,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6",{"_index":2340,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7",{"_index":2353,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduc",{"_index":2341,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(aft",{"_index":2302,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(input",{"_index":2296,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_line(lines.next().unwrap().as_ref",{"_index":2177,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::from_str(input",{"_index":2275,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::own",{"_index":2297,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::owning(elem",{"_index":2240,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::owning(self.elems.as_ref().to_own",{"_index":2233,"title":{},"name":{},"text":{"19":{}},"component":{}}],["snailnumowned::split_first",{"_index":2307,"title":{},"name":{},"text":{"19":{}},"component":{}}],["soln",{"_index":294,"title":{},"name":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"text":{},"component":{}}],["solut",{"_index":2,"title":{"1-2":{}},"name":{},"text":{"1":{},"2":{},"5":{},"8":{},"9":{},"16":{},"17":{},"18":{},"20":{},"24":{}},"component":{}}],["solv",{"_index":80,"title":{},"name":{},"text":{"1":{},"16":{},"18":{},"20":{},"24":{}},"component":{}}],["solvabl",{"_index":2909,"title":{},"name":{},"text":{"24":{}},"component":{}}],["solve(&self",{"_index":3018,"title":{},"name":{},"text":{"24":{}},"component":{}}],["some(&c",{"_index":1601,"title":{},"name":{},"text":{"15":{}},"component":{}}],["some(&prev",{"_index":1229,"title":{},"name":{},"text":{"11":{}},"component":{}}],["some(((i1",{"_index":2206,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some((i",{"_index":2217,"title":{},"name":{},"text":{"19":{},"22":{}},"component":{}}],["some((in_digit",{"_index":1085,"title":{},"name":{},"text":{"9":{}},"component":{}}],["some((k",{"_index":1600,"title":{},"name":{},"text":{"15":{}},"component":{}}],["some((new_row",{"_index":1692,"title":{},"name":{},"text":{"16":{}},"component":{}}],["some((non",{"_index":2310,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some((pap",{"_index":1475,"title":{},"name":{},"text":{"14":{}},"component":{}}],["some((some(2",{"_index":2319,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some((some(3",{"_index":2315,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some((std::iter::once(transform).chain(transforms).collect",{"_index":2557,"title":{},"name":{},"text":{"20":{}},"component":{}}],["some((total_st",{"_index":3039,"title":{},"name":{},"text":{"24":{}},"component":{}}],["some((transform",{"_index":2556,"title":{},"name":{},"text":{"20":{}},"component":{}}],["some((vec![transform::ident",{"_index":2542,"title":{},"name":{},"text":{"20":{}},"component":{}}],["some(1",{"_index":2311,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some(2",{"_index":2192,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some(3",{"_index":2081,"title":{},"name":{},"text":{"18":{},"19":{}},"component":{}}],["some(4",{"_index":2320,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some(45",{"_index":2078,"title":{},"name":{},"text":{"18":{}},"component":{}}],["some(6",{"_index":2326,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some([intersection_span[1",{"_index":2807,"title":{},"name":{},"text":{"23":{}},"component":{}}],["some([my_span[0",{"_index":2802,"title":{},"name":{},"text":{"23":{}},"component":{}}],["some(am",{"_index":3009,"title":{},"name":{},"text":{"24":{}},"component":{}}],["some(arg",{"_index":1912,"title":{},"name":{},"text":{"17":{}},"component":{}}],["some(arg_stack.first()?.valu",{"_index":1915,"title":{},"name":{},"text":{"17":{}},"component":{}}],["some(base_row",{"_index":1294,"title":{},"name":{},"text":{"12":{}},"component":{}}],["some(block",{"_index":3155,"title":{},"name":{},"text":{"25":{}},"component":{}}],["some(bound",{"_index":2875,"title":{},"name":{},"text":{"23":{}},"component":{}}],["some(c",{"_index":1161,"title":{},"name":{},"text":{"10":{},"23":{}},"component":{}}],["some(center_row",{"_index":2643,"title":{},"name":{},"text":{"21":{}},"component":{}}],["some(coord",{"_index":595,"title":{},"name":{},"text":{"5":{}},"component":{}}],["some(cuboid",{"_index":2834,"title":{},"name":{},"text":{"23":{}},"component":{}}],["some(curr_depth",{"_index":2254,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some(endpointpair(point(x1",{"_index":689,"title":{},"name":{},"text":{"6":{}},"component":{}}],["some(first_idx",{"_index":1175,"title":{},"name":{},"text":{"10":{}},"component":{}}],["some(i",{"_index":508,"title":{},"name":{},"text":{"4":{}},"component":{}}],["some(idx",{"_index":1180,"title":{},"name":{},"text":{"10":{},"19":{}},"component":{}}],["some(intersection_span",{"_index":2803,"title":{},"name":{},"text":{"23":{}},"component":{}}],["some(match",{"_index":378,"title":{},"name":{},"text":{"3":{},"11":{},"14":{},"23":{},"24":{},"25":{}},"component":{}}],["some(merged_cuboid",{"_index":2848,"title":{},"name":{},"text":{"23":{}},"component":{}}],["some(n_increas",{"_index":339,"title":{},"name":{},"text":{"2":{}},"component":{}}],["some(parse_st",{"_index":1817,"title":{},"name":{},"text":{"17":{}},"component":{}}],["some(point(x",{"_index":1472,"title":{},"name":{},"text":{"14":{}},"component":{}}],["some(polym",{"_index":1588,"title":{},"name":{},"text":{"15":{}},"component":{}}],["some(prev_depth",{"_index":2260,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some(pt2_v",{"_index":1922,"title":{},"name":{},"text":{"17":{}},"component":{}}],["some(r",{"_index":1160,"title":{},"name":{},"text":{"10":{},"25":{}},"component":{}}],["some(register::from_str(splat.next",{"_index":3149,"title":{},"name":{},"text":{"25":{}},"component":{}}],["some(s.borrow",{"_index":2553,"title":{},"name":{},"text":{"20":{}},"component":{}}],["some(scann",{"_index":2565,"title":{},"name":{},"text":{"20":{}},"component":{}}],["some(scor",{"_index":1260,"title":{},"name":{},"text":{"11":{}},"component":{}}],["some(self",{"_index":619,"title":{},"name":{},"text":{"5":{},"10":{},"11":{},"12":{},"13":{},"21":{},"23":{},"24":{}},"component":{}}],["some(self.cmp(oth",{"_index":2952,"title":{},"name":{},"text":{"24":{}},"component":{}}],["some(split_idx",{"_index":2224,"title":{},"name":{},"text":{"19":{}},"component":{}}],["some(sqrt",{"_index":2012,"title":{},"name":{},"text":{"18":{}},"component":{}}],["some(step",{"_index":392,"title":{},"name":{},"text":{"3":{}},"component":{}}],["some(this_board.len",{"_index":618,"title":{},"name":{},"text":{"5":{}},"component":{}}],["some(tim",{"_index":763,"title":{},"name":{},"text":{"7":{}},"component":{}}],["some(turn",{"_index":2738,"title":{},"name":{},"text":{"22":{}},"component":{}}],["some(upd",{"_index":3069,"title":{},"name":{},"text":{"24":{}},"component":{}}],["some(usize::from(x",{"_index":500,"title":{},"name":{},"text":{"4":{}},"component":{}}],["some(v",{"_index":2061,"title":{},"name":{},"text":{"18":{},"25":{}},"component":{}}],["some(velo",{"_index":2016,"title":{},"name":{},"text":{"18":{}},"component":{}}],["some(vx",{"_index":2022,"title":{},"name":{},"text":{"18":{}},"component":{}}],["someon",{"_index":1575,"title":{},"name":{},"text":{"15":{}},"component":{}}],["someth",{"_index":3106,"title":{},"name":{},"text":{"25":{}},"component":{}}],["somewhat",{"_index":2365,"title":{},"name":{},"text":{"19":{}},"component":{}}],["somewher",{"_index":2927,"title":{},"name":{},"text":{"24":{}},"component":{}}],["sonar",{"_index":214,"title":{"2":{}},"name":{},"text":{"1":{}},"component":{}}],["sourc",{"_index":1322,"title":{},"name":{},"text":{"13":{}},"component":{}}],["space",{"_index":2757,"title":{},"name":{},"text":{"23":{}},"component":{}}],["span",{"_index":2774,"title":{},"name":{},"text":{"23":{}},"component":{}}],["span1",{"_index":2799,"title":{},"name":{},"text":{"23":{}},"component":{}}],["span1[0].max(span2[0",{"_index":2795,"title":{},"name":{},"text":{"23":{}},"component":{}}],["span1[1].min(span2[1",{"_index":2796,"title":{},"name":{},"text":{"23":{}},"component":{}}],["span2",{"_index":2793,"title":{},"name":{},"text":{"23":{}},"component":{}}],["span3",{"_index":2804,"title":{},"name":{},"text":{"23":{}},"component":{}}],["span[0",{"_index":2776,"title":{},"name":{},"text":{"23":{}},"component":{}}],["span_intersection(span1",{"_index":2792,"title":{},"name":{},"text":{"23":{}},"component":{}}],["speak",{"_index":2915,"title":{},"name":{},"text":{"24":{}},"component":{}}],["special",{"_index":305,"title":{},"name":{},"text":{"2":{}},"component":{}}],["specif",{"_index":938,"title":{},"name":{},"text":{"9":{},"15":{},"25":{}},"component":{}}],["specifi",{"_index":1520,"title":{},"name":{},"text":{"15":{},"17":{}},"component":{}}],["speed",{"_index":1655,"title":{},"name":{},"text":{"16":{},"18":{}},"component":{}}],["splat",{"_index":1361,"title":{},"name":{},"text":{"13":{},"15":{},"25":{}},"component":{}}],["splat.next",{"_index":1362,"title":{},"name":{},"text":{"13":{},"25":{}},"component":{}}],["splat.next()?.char",{"_index":1583,"title":{},"name":{},"text":{"15":{}},"component":{}}],["splat.next()?.chars().next",{"_index":1586,"title":{},"name":{},"text":{"15":{}},"component":{}}],["splat.parse().ok",{"_index":2856,"title":{},"name":{},"text":{"23":{}},"component":{}}],["split",{"_index":605,"title":{},"name":{},"text":{"5":{},"7":{},"8":{},"17":{},"19":{},"23":{}},"component":{}}],["split_ascii_whitespac",{"_index":1076,"title":{},"name":{},"text":{"9":{}},"component":{}}],["split_first",{"_index":2187,"title":{},"name":{},"text":{"19":{}},"component":{}}],["split_idx",{"_index":2214,"title":{},"name":{},"text":{"19":{}},"component":{}}],["spot",{"_index":2924,"title":{},"name":{},"text":{"24":{}},"component":{}}],["sqrt",{"_index":2010,"title":{},"name":{},"text":{"18":{}},"component":{}}],["sqrt(discriminant).and_then(|sqrt_disc",{"_index":2025,"title":{},"name":{},"text":{"18":{}},"component":{}}],["sqrt_disc",{"_index":2026,"title":{},"name":{},"text":{"18":{}},"component":{}}],["squar",{"_index":864,"title":{},"name":{},"text":{"8":{},"11":{},"18":{},"24":{}},"component":{}}],["squid",{"_index":85,"title":{"5":{}},"name":{},"text":{"1":{}},"component":{}}],["src/lib.r",{"_index":104,"title":{},"name":{},"text":{"1":{}},"component":{}}],["src/utils.r",{"_index":105,"title":{},"name":{},"text":{"1":{}},"component":{}}],["stack",{"_index":1199,"title":{},"name":{},"text":{"11":{},"13":{},"17":{},"19":{}},"component":{}}],["stack.pop",{"_index":1818,"title":{},"name":{},"text":{"17":{}},"component":{}}],["stack.push(parsest",{"_index":1832,"title":{},"name":{},"text":{"17":{}},"component":{}}],["stage",{"_index":1523,"title":{},"name":{},"text":{"15":{},"23":{},"24":{}},"component":{}}],["standpoint",{"_index":1761,"title":{},"name":{},"text":{"17":{}},"component":{}}],["start",{"_index":1365,"title":{},"name":{},"text":{"13":{},"15":{},"20":{},"21":{},"24":{}},"component":{}}],["state",{"_index":366,"title":{},"name":{},"text":{"3":{},"12":{},"17":{},"21":{},"23":{},"24":{}},"component":{}}],["state.is_don",{"_index":3059,"title":{},"name":{},"text":{"24":{}},"component":{}}],["state.loc",{"_index":3047,"title":{},"name":{},"text":{"24":{}},"component":{}}],["state::from_str(str_comps.next",{"_index":2869,"title":{},"name":{},"text":{"23":{}},"component":{}}],["state::off",{"_index":2864,"title":{},"name":{},"text":{"23":{}},"component":{}}],["state::on",{"_index":2863,"title":{},"name":{},"text":{"23":{}},"component":{}}],["statement",{"_index":1756,"title":{},"name":{},"text":{"17":{},"24":{}},"component":{}}],["static",{"_index":2934,"title":{},"name":{},"text":{"24":{}},"component":{}}],["statist",{"_index":798,"title":{},"name":{},"text":{"8":{}},"component":{}}],["std",{"_index":568,"title":{},"name":{},"text":{"5":{},"24":{},"25":{}},"component":{}}],["std::cmp::ord",{"_index":2946,"title":{},"name":{},"text":{"24":{}},"component":{}}],["std::cmp::order",{"_index":2948,"title":{},"name":{},"text":{"24":{}},"component":{}}],["std::cmp::partialord",{"_index":2950,"title":{},"name":{},"text":{"24":{}},"component":{}}],["std::cmp::reverse(s",{"_index":1193,"title":{},"name":{},"text":{"10":{}},"component":{}}],["std::cmp::reverse(self.0).cmp(&std::cmp::reverse(other.0",{"_index":2949,"title":{},"name":{},"text":{"24":{}},"component":{}}],["std::collections::btreemap",{"_index":1350,"title":{},"name":{},"text":{"13":{},"15":{}},"component":{}}],["std::collections::btreeset",{"_index":1133,"title":{},"name":{},"text":{"10":{},"18":{}},"component":{}}],["std::collections::vecdequ",{"_index":328,"title":{},"name":{},"text":{"2":{}},"component":{}}],["std::collections::{btree_map::entri",{"_index":961,"title":{},"name":{},"text":{"9":{}},"component":{}}],["std::fmt::debug",{"_index":2292,"title":{},"name":{},"text":{"19":{}},"component":{}}],["std::fmt::display",{"_index":2784,"title":{},"name":{},"text":{"23":{},"24":{},"26":{}},"component":{}}],["std::fmt::formatt",{"_index":171,"title":{},"name":{},"text":{"1":{},"14":{},"19":{},"21":{},"23":{},"24":{},"26":{}},"component":{}}],["std::fmt::result",{"_index":172,"title":{},"name":{},"text":{"1":{},"14":{},"17":{},"19":{},"21":{},"23":{},"24":{},"26":{}},"component":{}}],["std::fmt::{debug",{"_index":117,"title":{},"name":{},"text":{"1":{},"19":{}},"component":{}}],["std::fmt::{display",{"_index":1793,"title":{},"name":{},"text":{"17":{},"21":{},"23":{}},"component":{}}],["std::iter::once(&merged_scann",{"_index":2551,"title":{},"name":{},"text":{"20":{}},"component":{}}],["std::iter::once(0).collect",{"_index":3188,"title":{},"name":{},"text":{"25":{}},"component":{}}],["std::iter::once(first_line).chain(lin",{"_index":452,"title":{},"name":{},"text":{"4":{}},"component":{}}],["std::ops::bitand",{"_index":984,"title":{},"name":{},"text":{"9":{}},"component":{}}],["std::ops::bitor",{"_index":980,"title":{},"name":{},"text":{"9":{}},"component":{}}],["std::ops::index",{"_index":2459,"title":{},"name":{},"text":{"20":{},"24":{}},"component":{}}],["std::ops::indexmut",{"_index":2973,"title":{},"name":{},"text":{"24":{}},"component":{}}],["std::ops::not",{"_index":986,"title":{},"name":{},"text":{"9":{}},"component":{}}],["std::{borrow::borrow",{"_index":2419,"title":{},"name":{},"text":{"20":{}},"component":{}}],["std::{collections::btreemap",{"_index":670,"title":{},"name":{},"text":{"6":{}},"component":{}}],["std::{collections::btreeset",{"_index":1505,"title":{},"name":{},"text":{"14":{},"26":{}},"component":{}}],["step",{"_index":383,"title":{},"name":{},"text":{"3":{},"6":{},"15":{},"18":{},"20":{},"21":{},"23":{}},"component":{}}],["step.borrow",{"_index":403,"title":{},"name":{},"text":{"3":{}},"component":{}}],["stepping_from(&self",{"_index":1682,"title":{},"name":{},"text":{"16":{}},"component":{}}],["still",{"_index":42,"title":{},"name":{},"text":{"1":{},"2":{},"9":{}},"component":{}}],["stop",{"_index":2417,"title":{},"name":{},"text":{"20":{}},"component":{}}],["store",{"_index":543,"title":{},"name":{},"text":{"5":{},"7":{},"15":{},"19":{},"21":{},"23":{}},"component":{}}],["str",{"_index":330,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["str::fromstr",{"_index":572,"title":{},"name":{},"text":{"5":{},"6":{},"14":{}},"component":{}}],["str_comp",{"_index":2867,"title":{},"name":{},"text":{"23":{}},"component":{}}],["straight",{"_index":57,"title":{},"name":{},"text":{"1":{}},"component":{}}],["strategi",{"_index":929,"title":{},"name":{},"text":{"9":{}},"component":{}}],["stream",{"_index":895,"title":{},"name":{},"text":{"9":{},"11":{},"17":{}},"component":{}}],["strict",{"_index":44,"title":{},"name":{},"text":{"1":{}},"component":{}}],["string",{"_index":1494,"title":{},"name":{},"text":{"14":{},"15":{},"17":{},"25":{}},"component":{}}],["strs.trim",{"_index":1075,"title":{},"name":{},"text":{"9":{}},"component":{}}],["struct",{"_index":159,"title":{},"name":{},"text":{"1":{},"3":{},"5":{},"6":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["structur",{"_index":1653,"title":{},"name":{},"text":{"16":{},"19":{}},"component":{}}],["strum::intoenumiter",{"_index":2421,"title":{},"name":{},"text":{"20":{}},"component":{}}],["strum_macros::enumit",{"_index":2422,"title":{},"name":{},"text":{"20":{}},"component":{}}],["submarin",{"_index":84,"title":{},"name":{},"text":{"1":{}},"component":{}}],["submiss",{"_index":1569,"title":{},"name":{},"text":{"15":{}},"component":{}}],["submit",{"_index":1572,"title":{},"name":{},"text":{"15":{}},"component":{}}],["suboptim",{"_index":1661,"title":{},"name":{},"text":{"16":{}},"component":{}}],["subreddit",{"_index":1955,"title":{},"name":{},"text":{"18":{}},"component":{}}],["subtract",{"_index":947,"title":{},"name":{},"text":{"9":{},"15":{},"17":{},"23":{}},"component":{}}],["success",{"_index":2593,"title":{},"name":{},"text":{"20":{}},"component":{}}],["successfulli",{"_index":2418,"title":{},"name":{},"text":{"20":{}},"component":{}}],["such",{"_index":725,"title":{},"name":{},"text":{"6":{},"16":{},"18":{},"25":{}},"component":{}}],["suffer",{"_index":1970,"title":{},"name":{},"text":{"18":{},"19":{}},"component":{}}],["suffici",{"_index":2392,"title":{},"name":{},"text":{"20":{}},"component":{}}],["sum",{"_index":303,"title":{},"name":{},"text":{"2":{},"4":{},"5":{},"6":{},"8":{},"9":{},"10":{},"11":{},"16":{},"17":{},"19":{},"22":{}},"component":{}}],["sum_{k=1}^n",{"_index":852,"title":{},"name":{},"text":{"8":{}},"component":{}}],["summari",{"_index":1941,"title":{},"name":{},"text":{"17":{}},"component":{}}],["super",{"_index":354,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["suppos",{"_index":940,"title":{},"name":{},"text":{"9":{}},"component":{}}],["surround",{"_index":2599,"title":{},"name":{},"text":{"21":{}},"component":{}}],["surrounding_pixel",{"_index":2640,"title":{},"name":{},"text":{"21":{}},"component":{}}],["surrounding_pixels.push(bit",{"_index":2645,"title":{},"name":{},"text":{"21":{}},"component":{}}],["surrounding_row",{"_index":2641,"title":{},"name":{},"text":{"21":{}},"component":{}}],["suspect",{"_index":1647,"title":{},"name":{},"text":{"16":{}},"component":{}}],["sweep",{"_index":215,"title":{"2":{}},"name":{},"text":{"1":{}},"component":{}}],["switch",{"_index":1411,"title":{},"name":{},"text":{"13":{},"21":{},"23":{}},"component":{}}],["swivel",{"_index":2402,"title":{},"name":{},"text":{"20":{}},"component":{}}],["swivel::ident",{"_index":2505,"title":{},"name":{},"text":{"20":{}},"component":{}}],["swivel::new(axis::posz",{"_index":2504,"title":{},"name":{},"text":{"20":{}},"component":{}}],["swivel::new(up_fac",{"_index":2519,"title":{},"name":{},"text":{"20":{}},"component":{}}],["swiveled_oth",{"_index":2520,"title":{},"name":{},"text":{"20":{}},"component":{}}],["swiveled_other.applying(transl",{"_index":2530,"title":{},"name":{},"text":{"20":{}},"component":{}}],["swiveled_other.beacon",{"_index":2523,"title":{},"name":{},"text":{"20":{}},"component":{}}],["swiveled_other_beacon",{"_index":2522,"title":{},"name":{},"text":{"20":{}},"component":{}}],["swiveled_other_beacon[i",{"_index":2528,"title":{},"name":{},"text":{"20":{}},"component":{}}],["syntax",{"_index":238,"title":{"11":{}},"name":{},"text":{"1":{}},"component":{}}],["system",{"_index":1321,"title":{},"name":{},"text":{"13":{}},"component":{}}],["t",{"_index":584,"title":{},"name":{},"text":{"5":{},"6":{},"11":{},"14":{},"18":{},"19":{},"20":{},"24":{}},"component":{}}],["t(e_1",{"_index":2408,"title":{},"name":{},"text":{"20":{}},"component":{}}],["t(e_n",{"_index":2410,"title":{},"name":{},"text":{"20":{}},"component":{}}],["t*(t",{"_index":2028,"title":{},"name":{},"text":{"18":{}},"component":{}}],["t,x,i",{"_index":2104,"title":{},"name":{},"text":{"18":{}},"component":{}}],["t.brace",{"_index":1250,"title":{},"name":{},"text":{"11":{}},"component":{}}],["t.flip()).collect",{"_index":1239,"title":{},"name":{},"text":{"11":{}},"component":{}}],["t.translation).collect",{"_index":2568,"title":{},"name":{},"text":{"20":{}},"component":{}}],["t1",{"_index":163,"title":{},"name":{},"text":{"1":{}},"component":{}}],["t2",{"_index":165,"title":{},"name":{},"text":{"1":{}},"component":{}}],["t=\\frac{1}{2}\\left((2v_y+1)\\pm\\sqrt{(2v_y+1)^2",{"_index":2119,"title":{},"name":{},"text":{"18":{}},"component":{}}],["t=v_x",{"_index":2100,"title":{},"name":{},"text":{"18":{}},"component":{}}],["t\\)",{"_index":2114,"title":{},"name":{},"text":{"18":{}},"component":{}}],["tag::add",{"_index":2236,"title":{},"name":{},"text":{"19":{}},"component":{}}],["tag::algo",{"_index":3161,"title":{},"name":{},"text":{"25":{}},"component":{}}],["tag::amphipod",{"_index":2940,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tag::cod",{"_index":192,"title":{},"name":{},"text":{"1":{}},"component":{}}],["tag::debug",{"_index":2230,"title":{},"name":{},"text":{"19":{},"21":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["tag::digit",{"_index":965,"title":{},"name":{},"text":{"9":{}},"component":{}}],["tag::explod",{"_index":2190,"title":{},"name":{},"text":{"19":{}},"component":{}}],["tag::get_traj",{"_index":2050,"title":{},"name":{},"text":{"18":{}},"component":{}}],["tag::magnitud",{"_index":2264,"title":{},"name":{},"text":{"19":{}},"component":{}}],["tag::mod",{"_index":122,"title":{},"name":{},"text":{"1":{}},"component":{}}],["tag::pair",{"_index":2243,"title":{},"name":{},"text":{"19":{}},"component":{}}],["tag::pt1",{"_index":345,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["tag::pt2",{"_index":348,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{}},"component":{}}],["tag::setup",{"_index":326,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"25":{},"26":{}},"component":{}}],["tag::setup_main",{"_index":1991,"title":{},"name":{},"text":{"18":{}},"component":{}}],["tag::snail_num",{"_index":2155,"title":{},"name":{},"text":{"19":{}},"component":{}}],["tag::solv",{"_index":3017,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tag::velo_find",{"_index":2014,"title":{},"name":{},"text":{"18":{}},"component":{}}],["take",{"_index":934,"title":{},"name":{},"text":{"9":{},"18":{},"24":{}},"component":{}}],["take_while(|lin",{"_index":1468,"title":{},"name":{},"text":{"14":{}},"component":{}}],["taken",{"_index":56,"title":{},"name":{},"text":{"1":{}},"component":{}}],["talli",{"_index":1535,"title":{},"name":{},"text":{"15":{},"22":{}},"component":{}}],["tally[player_index",{"_index":2747,"title":{},"name":{},"text":{"22":{}},"component":{}}],["target",{"_index":1984,"title":{},"name":{},"text":{"18":{}},"component":{}}],["technic",{"_index":2390,"title":{},"name":{},"text":{"20":{}},"component":{}}],["tell",{"_index":926,"title":{},"name":{},"text":{"9":{},"15":{},"17":{},"25":{}},"component":{}}],["templat",{"_index":1580,"title":{},"name":{},"text":{"15":{}},"component":{}}],["tend",{"_index":62,"title":{},"name":{},"text":{"1":{}},"component":{}}],["tent",{"_index":1662,"title":{},"name":{},"text":{"16":{}},"component":{}}],["test",{"_index":353,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["test_act",{"_index":2291,"title":{},"name":{},"text":{"19":{}},"component":{}}],["test_action(input",{"_index":2304,"title":{},"name":{},"text":{"19":{}},"component":{}}],["test_explod",{"_index":2303,"title":{},"name":{},"text":{"19":{}},"component":{}}],["test_input",{"_index":182,"title":{},"name":{},"text":{"1":{},"14":{}},"component":{}}],["test_input!(\"target",{"_index":2076,"title":{},"name":{},"text":{"18":{}},"component":{}}],["test_input!(&read_input(in_str",{"_index":1919,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_input!(include_str!(\"input.txt",{"_index":357,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"15":{},"16":{},"20":{},"21":{},"22":{},"23":{},"25":{},"26":{}},"component":{}}],["test_input!(include_str!(\"sample_input.txt",{"_index":356,"title":{},"name":{},"text":{"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"15":{},"16":{}},"component":{}}],["test_input!(include_str!(\"sample_input_1.txt",{"_index":1395,"title":{},"name":{},"text":{"13":{}},"component":{}}],["test_input!(include_str!(\"sample_input_2.txt",{"_index":1397,"title":{},"name":{},"text":{"13":{}},"component":{}}],["test_input!(include_str!(\"sample_input_3.txt",{"_index":1399,"title":{},"name":{},"text":{"13":{}},"component":{}}],["test_pt1",{"_index":3096,"title":{},"name":{},"text":{"24":{}},"component":{}}],["test_pt1(\"620080001611562c8802118e34",{"_index":1925,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt1(\"8a004a801a8002f478",{"_index":1924,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt1(\"a0016c880162017c3686b18a3d4780",{"_index":1927,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt1(\"c0015000016115a2e0802f182340",{"_index":1926,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt1(\"d2fe28",{"_index":1923,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt1(in_str",{"_index":1917,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt1(include_str!(\"input.txt",{"_index":1929,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2",{"_index":3099,"title":{},"name":{},"text":{"24":{}},"component":{}}],["test_pt2(\"04005ac33890",{"_index":1933,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(\"880086c3e88112",{"_index":1935,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(\"9c005ac2f8f0",{"_index":1939,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(\"9c0141080250320f1802104a08",{"_index":1940,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(\"c200b40a82",{"_index":1932,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(\"ce00c43d881120",{"_index":1936,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(\"d2fe28",{"_index":1931,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(\"d8005ac2a8f0",{"_index":1937,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(\"f600bc2d8f",{"_index":1938,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_pt2(in_str",{"_index":1920,"title":{},"name":{},"text":{"17":{}},"component":{}}],["test_reduct",{"_index":2328,"title":{},"name":{},"text":{"19":{}},"component":{}}],["test_split",{"_index":2306,"title":{},"name":{},"text":{"19":{}},"component":{}}],["test_velocity_find",{"_index":2071,"title":{},"name":{},"text":{"18":{}},"component":{}}],["text",{"_index":558,"title":{},"name":{},"text":{"5":{},"25":{}},"component":{}}],["thank",{"_index":2933,"title":{},"name":{},"text":{"24":{}},"component":{}}],["thankfulli",{"_index":1541,"title":{},"name":{},"text":{"15":{},"20":{},"22":{}},"component":{}}],["that'",{"_index":1715,"title":{},"name":{},"text":{"16":{}},"component":{}}],["that’",{"_index":1959,"title":{},"name":{},"text":{"18":{}},"component":{}}],["themselv",{"_index":2605,"title":{},"name":{},"text":{"21":{}},"component":{}}],["theoret",{"_index":72,"title":{},"name":{},"text":{"1":{},"16":{},"17":{}},"component":{}}],["theori",{"_index":1855,"title":{},"name":{},"text":{"17":{}},"component":{}}],["therefor",{"_index":19,"title":{},"name":{},"text":{"1":{},"18":{},"21":{},"24":{}},"component":{}}],["there’",{"_index":1768,"title":{},"name":{},"text":{"17":{}},"component":{}}],["they'r",{"_index":1047,"title":{},"name":{},"text":{"9":{}},"component":{}}],["thing",{"_index":418,"title":{},"name":{},"text":{"4":{},"9":{},"10":{},"14":{},"25":{}},"component":{}}],["this_beacon",{"_index":2524,"title":{},"name":{},"text":{"20":{}},"component":{}}],["this_beacon[i",{"_index":2527,"title":{},"name":{},"text":{"20":{}},"component":{}}],["this_board",{"_index":608,"title":{},"name":{},"text":{"5":{}},"component":{}}],["this_board.clear",{"_index":614,"title":{},"name":{},"text":{"5":{}},"component":{}}],["this_board.is_empti",{"_index":610,"title":{},"name":{},"text":{"5":{}},"component":{}}],["this_board.push(num",{"_index":616,"title":{},"name":{},"text":{"5":{}},"component":{}}],["this_dest_n_visit",{"_index":1378,"title":{},"name":{},"text":{"13":{}},"component":{}}],["this_scanner_beacon",{"_index":2558,"title":{},"name":{},"text":{"20":{}},"component":{}}],["this_scanner_beacons.clear",{"_index":2561,"title":{},"name":{},"text":{"20":{}},"component":{}}],["this_scanner_beacons.insert([x",{"_index":2564,"title":{},"name":{},"text":{"20":{}},"component":{}}],["those",{"_index":75,"title":{},"name":{},"text":{"1":{},"5":{},"6":{},"9":{},"13":{},"15":{},"19":{},"21":{},"23":{},"24":{}},"component":{}}],["though",{"_index":2098,"title":{},"name":{},"text":{"18":{}},"component":{}}],["thought",{"_index":1573,"title":{},"name":{},"text":{"15":{}},"component":{}}],["three",{"_index":944,"title":{},"name":{},"text":{"9":{},"17":{},"20":{},"22":{},"23":{}},"component":{}}],["threequart",{"_index":2471,"title":{},"name":{},"text":{"20":{}},"component":{}}],["through",{"_index":795,"title":{},"name":{},"text":{"8":{},"10":{},"13":{},"15":{},"16":{},"22":{},"24":{}},"component":{}}],["throughout",{"_index":1420,"title":{},"name":{},"text":{"14":{}},"component":{}}],["thrown",{"_index":53,"title":{},"name":{},"text":{"1":{}},"component":{}}],["thu",{"_index":2607,"title":{},"name":{},"text":{"21":{}},"component":{}}],["tick",{"_index":1972,"title":{},"name":{},"text":{"18":{}},"component":{}}],["tick(&mut",{"_index":2625,"title":{},"name":{},"text":{"21":{},"26":{}},"component":{}}],["tick(256",{"_index":782,"title":{},"name":{},"text":{"7":{}},"component":{}}],["tick(80",{"_index":779,"title":{},"name":{},"text":{"7":{}},"component":{}}],["tick(mut",{"_index":1298,"title":{},"name":{},"text":{"12":{}},"component":{}}],["tick(n_tim",{"_index":772,"title":{},"name":{},"text":{"7":{}},"component":{}}],["tick(octopi",{"_index":1302,"title":{},"name":{},"text":{"12":{}},"component":{}}],["tick_in_place(&mut",{"_index":774,"title":{},"name":{},"text":{"7":{}},"component":{}}],["tick_in_place(tim",{"_index":764,"title":{},"name":{},"text":{"7":{}},"component":{}}],["tick_in_place_and_count_flashes(&mut",{"_index":1274,"title":{},"name":{},"text":{"12":{}},"component":{}}],["tick_n_times(&mut",{"_index":2649,"title":{},"name":{},"text":{"21":{}},"component":{}}],["tile",{"_index":2975,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tile.to_char",{"_index":3016,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tile::doorway",{"_index":3079,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tile::sideroom(am.kind",{"_index":3045,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tile::sideroom(kind",{"_index":3014,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tile::wal",{"_index":3078,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tiles.clon",{"_index":3087,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tiles[[row",{"_index":2999,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tiles[new_loc",{"_index":3077,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tiles[state.loc",{"_index":3044,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tiles_map",{"_index":2982,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tiles_map.get(&(row",{"_index":2994,"title":{},"name":{},"text":{"24":{}},"component":{}}],["tiles_map.insert((row",{"_index":2992,"title":{},"name":{},"text":{"24":{}},"component":{}}],["time",{"_index":650,"title":{},"name":{},"text":{"5":{},"6":{},"13":{},"15":{},"16":{},"17":{},"18":{},"19":{},"22":{}},"component":{}}],["timer",{"_index":759,"title":{},"name":{},"text":{"7":{}},"component":{}}],["timers).iter().sum",{"_index":780,"title":{},"name":{},"text":{"7":{}},"component":{}}],["timers[0",{"_index":766,"title":{},"name":{},"text":{"7":{}},"component":{}}],["timers[6",{"_index":770,"title":{},"name":{},"text":{"7":{}},"component":{}}],["timers[8",{"_index":769,"title":{},"name":{},"text":{"7":{}},"component":{}}],["timers[i",{"_index":768,"title":{},"name":{},"text":{"7":{}},"component":{}}],["timers[num",{"_index":762,"title":{},"name":{},"text":{"7":{}},"component":{}}],["tini",{"_index":2929,"title":{},"name":{},"text":{"24":{}},"component":{}}],["to_big_decimal(&packet_bits[0..3",{"_index":1824,"title":{},"name":{},"text":{"17":{}},"component":{}}],["to_big_decimal(&packet_bits[3..6",{"_index":1826,"title":{},"name":{},"text":{"17":{}},"component":{}}],["to_big_decimal>(binary_digits_msbf",{"_index":208,"title":{},"name":{},"text":{"1":{}},"component":{}}],["to_char(self",{"_index":2959,"title":{},"name":{},"text":{"24":{}},"component":{}}],["to_decimal(col_has_more_ones_than_zeros.to_vec",{"_index":480,"title":{},"name":{},"text":{"4":{}},"component":{}}],["to_decimal(line.to_vec",{"_index":510,"title":{},"name":{},"text":{"4":{}},"component":{}}],["to_decimal>(binary_digits_msbf",{"_index":193,"title":{},"name":{},"text":{"1":{}},"component":{}}],["to_own",{"_index":1502,"title":{},"name":{},"text":{"14":{}},"component":{}}],["togeth",{"_index":2382,"title":{},"name":{},"text":{"20":{},"23":{}},"component":{}}],["token",{"_index":1198,"title":{},"name":{},"text":{"11":{}},"component":{}}],["token_scor",{"_index":1259,"title":{},"name":{},"text":{"11":{}},"component":{}}],["token_stack",{"_index":1224,"title":{},"name":{},"text":{"11":{}},"component":{}}],["token_stack.is_empti",{"_index":1236,"title":{},"name":{},"text":{"11":{}},"component":{}}],["token_stack.iter().rev().map(|t",{"_index":1238,"title":{},"name":{},"text":{"11":{}},"component":{}}],["token_stack.last",{"_index":1227,"title":{},"name":{},"text":{"11":{}},"component":{}}],["token_stack.pop",{"_index":1235,"title":{},"name":{},"text":{"11":{}},"component":{}}],["token_stack.push(curr",{"_index":1228,"title":{},"name":{},"text":{"11":{}},"component":{}}],["tokenizationerr",{"_index":1219,"title":{},"name":{},"text":{"11":{}},"component":{}}],["tokens_it",{"_index":388,"title":{},"name":{},"text":{"3":{}},"component":{}}],["tokens_iter.next()?.parse().ok",{"_index":391,"title":{},"name":{},"text":{"3":{}},"component":{}}],["ton",{"_index":286,"title":{},"name":{},"text":{"1":{}},"component":{}}],["took",{"_index":1643,"title":{},"name":{},"text":{"16":{},"17":{}},"component":{}}],["top",{"_index":1201,"title":{},"name":{},"text":{"11":{},"16":{},"19":{}},"component":{}}],["total",{"_index":1642,"title":{},"name":{},"text":{"16":{}},"component":{}}],["total_st",{"_index":3042,"title":{},"name":{},"text":{"24":{}},"component":{}}],["total_state.iter_item",{"_index":3049,"title":{},"name":{},"text":{"24":{}},"component":{}}],["total_state.iter_items().find_map(|(am",{"_index":3058,"title":{},"name":{},"text":{"24":{}},"component":{}}],["toward",{"_index":842,"title":{},"name":{},"text":{"8":{},"24":{}},"component":{}}],["track",{"_index":538,"title":{},"name":{},"text":{"5":{},"14":{},"15":{},"17":{},"20":{}},"component":{}}],["track_cal",{"_index":1916,"title":{},"name":{},"text":{"17":{},"19":{}},"component":{}}],["traj",{"_index":2068,"title":{},"name":{},"text":{"18":{}},"component":{}}],["traj.borrow",{"_index":2069,"title":{},"name":{},"text":{"18":{}},"component":{}}],["traj.velo.vi",{"_index":2070,"title":{},"name":{},"text":{"18":{}},"component":{}}],["trajectori",{"_index":2001,"title":{},"name":{},"text":{"18":{}},"component":{}}],["trajectories.push(trajectori",{"_index":2064,"title":{},"name":{},"text":{"18":{}},"component":{}}],["transform",{"_index":1517,"title":{},"name":{},"text":{"15":{},"20":{},"21":{}},"component":{}}],["transform.apply(p)).collect",{"_index":2514,"title":{},"name":{},"text":{"20":{}},"component":{}}],["transform.into",{"_index":2512,"title":{},"name":{},"text":{"20":{}},"component":{}}],["transformation’",{"_index":2595,"title":{},"name":{},"text":{"20":{}},"component":{}}],["transformed_oth",{"_index":2529,"title":{},"name":{},"text":{"20":{}},"component":{}}],["transformed_scann",{"_index":2546,"title":{},"name":{},"text":{"20":{}},"component":{}}],["transforms.insert(transform",{"_index":2533,"title":{},"name":{},"text":{"20":{}},"component":{}}],["transforms.iter().map(|t",{"_index":2567,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translat",{"_index":2403,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translate_line_to_digit",{"_index":1086,"title":{},"name":{},"text":{"9":{}},"component":{}}],["translate_line_to_digits((in_d.it",{"_index":1096,"title":{},"name":{},"text":{"9":{}},"component":{}}],["translation([0",{"_index":2502,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translation([x2",{"_index":2584,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translation(tripl",{"_index":2492,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translation1",{"_index":2576,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translation1.0",{"_index":2579,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translation2",{"_index":2580,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translation2.0",{"_index":2583,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translation::ident",{"_index":2506,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translations.as_ref",{"_index":2574,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translations.iter().enumer",{"_index":2577,"title":{},"name":{},"text":{"20":{}},"component":{}}],["translations.iter().skip(i",{"_index":2581,"title":{},"name":{},"text":{"20":{}},"component":{}}],["transpar",{"_index":247,"title":{"14":{}},"name":{},"text":{"1":{},"14":{}},"component":{}}],["travers",{"_index":1340,"title":{},"name":{},"text":{"13":{},"16":{},"19":{}},"component":{}}],["traversal_cost(&grid",{"_index":1733,"title":{},"name":{},"text":{"16":{}},"component":{}}],["traversal_cost(entry_cost",{"_index":1693,"title":{},"name":{},"text":{"16":{}},"component":{}}],["traversal_cost(grid",{"_index":1710,"title":{},"name":{},"text":{"16":{}},"component":{}}],["traverse(&'a",{"_index":1386,"title":{},"name":{},"text":{"13":{}},"component":{}}],["traverse_help",{"_index":1369,"title":{},"name":{},"text":{"13":{}},"component":{}}],["treacheri",{"_index":228,"title":{"8":{}},"name":{},"text":{"1":{}},"component":{}}],["tree",{"_index":1753,"title":{},"name":{},"text":{"17":{},"19":{}},"component":{}}],["trench",{"_index":266,"title":{"21":{}},"name":{},"text":{"1":{}},"component":{}}],["tri",{"_index":79,"title":{},"name":{},"text":{"1":{},"8":{},"9":{},"18":{},"20":{}},"component":{}}],["trick",{"_index":258,"title":{"18":{}},"name":{},"text":{"1":{}},"component":{}}],["tricki",{"_index":1782,"title":{},"name":{},"text":{"17":{},"19":{}},"component":{}}],["trillion",{"_index":1534,"title":{},"name":{},"text":{"15":{}},"component":{}}],["trim",{"_index":760,"title":{},"name":{},"text":{"7":{},"22":{}},"component":{}}],["tripl",{"_index":1550,"title":{},"name":{},"text":{"15":{},"20":{}},"component":{}}],["trivial",{"_index":1752,"title":{},"name":{},"text":{"17":{}},"component":{}}],["true",{"_index":424,"title":{},"name":{},"text":{"4":{},"5":{},"9":{},"19":{},"21":{},"22":{},"24":{},"26":{}},"component":{}}],["trust",{"_index":55,"title":{},"name":{},"text":{"1":{}},"component":{}}],["trustworthi",{"_index":1870,"title":{},"name":{},"text":{"17":{}},"component":{}}],["try_into",{"_index":2691,"title":{},"name":{},"text":{"22":{},"23":{},"24":{}},"component":{}}],["ts_and_vi",{"_index":2058,"title":{},"name":{},"text":{"18":{}},"component":{}}],["turn",{"_index":933,"title":{},"name":{},"text":{"9":{},"22":{},"23":{},"24":{}},"component":{}}],["turn_stack",{"_index":2728,"title":{},"name":{},"text":{"22":{}},"component":{}}],["turn_stack.pop",{"_index":2740,"title":{},"name":{},"text":{"22":{}},"component":{}}],["turn_stack.push(turn",{"_index":2748,"title":{},"name":{},"text":{"22":{}},"component":{}}],["twice",{"_index":1546,"title":{},"name":{},"text":{"15":{},"19":{}},"component":{}}],["two",{"_index":315,"title":{},"name":{},"text":{"2":{},"6":{},"8":{},"9":{},"13":{},"14":{},"15":{},"17":{},"18":{},"19":{},"20":{},"22":{},"23":{},"24":{},"25":{}},"component":{}}],["two_m",{"_index":2046,"title":{},"name":{},"text":{"18":{}},"component":{}}],["tx",{"_index":2494,"title":{},"name":{},"text":{"20":{}},"component":{}}],["ty",{"_index":2495,"title":{},"name":{},"text":{"20":{}},"component":{}}],["type",{"_index":101,"title":{},"name":{},"text":{"1":{},"6":{},"7":{},"9":{},"11":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{}},"component":{}}],["tz",{"_index":2496,"title":{},"name":{},"text":{"20":{}},"component":{}}],["u32",{"_index":195,"title":{},"name":{},"text":{"1":{},"4":{},"16":{},"19":{},"20":{}},"component":{}}],["u32::from(is_on",{"_index":203,"title":{},"name":{},"text":{"1":{}},"component":{}}],["u32::max",{"_index":1664,"title":{},"name":{},"text":{"16":{}},"component":{}}],["u32::min",{"_index":2280,"title":{},"name":{},"text":{"19":{},"20":{}},"component":{}}],["u32::try_from(x.ab",{"_index":2498,"title":{},"name":{},"text":{"20":{}},"component":{}}],["u64",{"_index":209,"title":{},"name":{},"text":{"1":{},"17":{}},"component":{}}],["u64::from(is_on",{"_index":210,"title":{},"name":{},"text":{"1":{}},"component":{}}],["un",{"_index":652,"title":{},"name":{},"text":{"5":{},"13":{}},"component":{}}],["unaffect",{"_index":1785,"title":{},"name":{},"text":{"17":{}},"component":{}}],["unambigu",{"_index":59,"title":{},"name":{},"text":{"1":{}},"component":{}}],["unbound",{"_index":2904,"title":{},"name":{},"text":{"23":{}},"component":{}}],["unchang",{"_index":848,"title":{},"name":{},"text":{"8":{},"17":{}},"component":{}}],["under",{"_index":1741,"title":{},"name":{},"text":{"16":{}},"component":{}}],["underflow",{"_index":1871,"title":{},"name":{},"text":{"17":{}},"component":{}}],["underli",{"_index":906,"title":{},"name":{},"text":{"9":{}},"component":{}}],["underwat",{"_index":1319,"title":{},"name":{},"text":{"13":{}},"component":{}}],["undirect",{"_index":1310,"title":{},"name":{},"text":{"13":{}},"component":{}}],["undrawn",{"_index":529,"title":{},"name":{},"text":{"5":{}},"component":{}}],["unfortun",{"_index":1524,"title":{},"name":{},"text":{"15":{},"24":{}},"component":{}}],["unicod",{"_index":1490,"title":{},"name":{},"text":{"14":{}},"component":{}}],["union",{"_index":2387,"title":{},"name":{},"text":{"20":{}},"component":{}}],["unit",{"_index":279,"title":{"25":{}},"name":{},"text":{"1":{}},"component":{}}],["unless",{"_index":2919,"title":{},"name":{},"text":{"24":{}},"component":{}}],["unmarked_sum",{"_index":601,"title":{},"name":{},"text":{"5":{}},"component":{}}],["unoccupi",{"_index":2926,"title":{},"name":{},"text":{"24":{}},"component":{}}],["unpack",{"_index":1769,"title":{},"name":{},"text":{"17":{}},"component":{}}],["unreach",{"_index":632,"title":{},"name":{},"text":{"5":{},"17":{},"19":{},"21":{},"26":{}},"component":{}}],["until",{"_index":649,"title":{},"name":{},"text":{"5":{},"9":{},"16":{},"18":{}},"component":{}}],["unwrap",{"_index":66,"title":{},"name":{},"text":{"1":{},"4":{},"9":{},"17":{},"18":{},"22":{},"24":{}},"component":{}}],["unwrap_or(0",{"_index":207,"title":{},"name":{},"text":{"1":{}},"component":{}}],["up",{"_index":375,"title":{},"name":{},"text":{"3":{},"8":{},"9":{},"14":{},"15":{},"16":{},"17":{},"19":{},"20":{},"22":{},"23":{},"25":{}},"component":{}}],["up_fac",{"_index":2472,"title":{},"name":{},"text":{"20":{}},"component":{}}],["updat",{"_index":365,"title":{},"name":{},"text":{"3":{},"5":{},"12":{},"21":{},"24":{}},"component":{}}],["update_that_moves_am_to_final_loc",{"_index":3057,"title":{},"name":{},"text":{"24":{}},"component":{}}],["updates.clear",{"_index":3041,"title":{},"name":{},"text":{"24":{}},"component":{}}],["updates.push(upd",{"_index":3080,"title":{},"name":{},"text":{"24":{}},"component":{}}],["upon",{"_index":2679,"title":{},"name":{},"text":{"22":{}},"component":{}}],["upper",{"_index":1421,"title":{},"name":{},"text":{"14":{},"23":{}},"component":{}}],["upright",{"_index":2759,"title":{},"name":{},"text":{"23":{}},"component":{}}],["us",{"_index":103,"title":{},"name":{},"text":{"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["usiz",{"_index":161,"title":{},"name":{},"text":{"1":{},"2":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{}},"component":{}}],["usize::from(*x)).sum_axis(axis(0",{"_index":469,"title":{},"name":{},"text":{"4":{}},"component":{}}],["usize::from(bit)).sum",{"_index":2661,"title":{},"name":{},"text":{"21":{}},"component":{}}],["usize::max",{"_index":1621,"title":{},"name":{},"text":{"15":{}},"component":{}}],["usize::try_from(d).ok",{"_index":1145,"title":{},"name":{},"text":{"10":{},"12":{}},"component":{}}],["usize::try_from(span[1",{"_index":2775,"title":{},"name":{},"text":{"23":{}},"component":{}}],["usize::try_from(to_big_decimal(&data_bits[1..n_bits_for_length",{"_index":1848,"title":{},"name":{},"text":{"17":{}},"component":{}}],["usize::try_from(to_decimal([self.surround",{"_index":2627,"title":{},"name":{},"text":{"21":{}},"component":{}}],["util",{"_index":121,"title":{},"name":{},"text":{"1":{}},"component":{}}],["utils.r",{"_index":179,"title":{},"name":{},"text":{"1":{}},"component":{}}],["v",{"_index":194,"title":{},"name":{},"text":{"1":{},"3":{},"6":{},"8":{},"9":{},"13":{},"15":{},"18":{},"19":{},"20":{},"24":{},"26":{}},"component":{}}],["v.as_ref",{"_index":1102,"title":{},"name":{},"text":{"9":{}},"component":{}}],["v.insert(new_good_candid",{"_index":1040,"title":{},"name":{},"text":{"9":{}},"component":{}}],["v.iter().next().copied().unwrap",{"_index":1068,"title":{},"name":{},"text":{"9":{}},"component":{}}],["v_i",{"_index":2085,"title":{},"name":{},"text":{"18":{}},"component":{}}],["v_x",{"_index":2084,"title":{},"name":{},"text":{"18":{}},"component":{}}],["v_x,v_i",{"_index":2102,"title":{},"name":{},"text":{"18":{}},"component":{}}],["v_x=\\begin{cas",{"_index":2108,"title":{},"name":{},"text":{"18":{}},"component":{}}],["v_x\\)",{"_index":1979,"title":{},"name":{},"text":{"18":{}},"component":{}}],["v_y)&=v_i",{"_index":2096,"title":{},"name":{},"text":{"18":{}},"component":{}}],["v_y=\\frac{2y+t(t",{"_index":2106,"title":{},"name":{},"text":{"18":{}},"component":{}}],["v_y>0",{"_index":2138,"title":{},"name":{},"text":{"18":{}},"component":{}}],["v_y\\)",{"_index":1981,"title":{},"name":{},"text":{"18":{}},"component":{}}],["val",{"_index":1107,"title":{},"name":{},"text":{"9":{},"10":{},"12":{},"19":{}},"component":{}}],["val.valu",{"_index":2170,"title":{},"name":{},"text":{"19":{}},"component":{}}],["valid",{"_index":996,"title":{},"name":{},"text":{"9":{},"13":{}},"component":{}}],["valid_z",{"_index":3156,"title":{},"name":{},"text":{"25":{}},"component":{}}],["valid_zs))).into",{"_index":3160,"title":{},"name":{},"text":{"25":{}},"component":{}}],["valid_zs.as_ref",{"_index":3204,"title":{},"name":{},"text":{"25":{}},"component":{}}],["valid_zs.extend(curr_zs.iter().copi",{"_index":3190,"title":{},"name":{},"text":{"25":{}},"component":{}}],["valu",{"_index":425,"title":{},"name":{},"text":{"4":{},"6":{},"7":{},"14":{},"17":{},"18":{},"19":{},"22":{},"25":{}},"component":{}}],["value_of_line_chosen_by_criterion",{"_index":483,"title":{},"name":{},"text":{"4":{}},"component":{}}],["value_of_line_chosen_by_criterion(mat",{"_index":516,"title":{},"name":{},"text":{"4":{}},"component":{}}],["var",{"_index":1440,"title":{},"name":{},"text":{"14":{}},"component":{}}],["variabl",{"_index":2601,"title":{},"name":{},"text":{"21":{}},"component":{}}],["variant",{"_index":93,"title":{},"name":{},"text":{"1":{}},"component":{}}],["variou",{"_index":896,"title":{},"name":{},"text":{"9":{}},"component":{}}],["vec",{"_index":574,"title":{},"name":{},"text":{"5":{},"9":{},"10":{},"14":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"23":{},"24":{},"25":{}},"component":{}}],["vec![(6",{"_index":2318,"title":{},"name":{},"text":{"19":{}},"component":{}}],["vec![(7",{"_index":2314,"title":{},"name":{},"text":{"19":{}},"component":{}}],["vec![(9",{"_index":2309,"title":{},"name":{},"text":{"19":{}},"component":{}}],["vec![*self",{"_index":2809,"title":{},"name":{},"text":{"23":{}},"component":{}}],["vec![0",{"_index":2732,"title":{},"name":{},"text":{"22":{}},"component":{}}],["vec![[usize::max",{"_index":3001,"title":{},"name":{},"text":{"24":{}},"component":{}}],["vec![c1",{"_index":2885,"title":{},"name":{},"text":{"23":{}},"component":{}}],["vec![candidatedigit",{"_index":3205,"title":{},"name":{},"text":{"25":{}},"component":{}}],["vec![first_idx",{"_index":1179,"title":{},"name":{},"text":{"10":{}},"component":{}}],["vec![map::new",{"_index":3167,"title":{},"name":{},"text":{"25":{}},"component":{}}],["vec![n_col",{"_index":577,"title":{},"name":{},"text":{"5":{}},"component":{}}],["vec![n_row",{"_index":578,"title":{},"name":{},"text":{"5":{}},"component":{}}],["vec![parsest",{"_index":1815,"title":{},"name":{},"text":{"17":{}},"component":{}}],["vec![set::new",{"_index":3187,"title":{},"name":{},"text":{"25":{}},"component":{}}],["vec![turn",{"_index":2729,"title":{},"name":{},"text":{"22":{}},"component":{}}],["vec::::new",{"_index":2163,"title":{},"name":{},"text":{"19":{},"23":{}},"component":{}}],["vec::new",{"_index":447,"title":{},"name":{},"text":{"4":{},"10":{},"11":{},"12":{},"24":{}},"component":{}}],["vec::with_capacity(s.len",{"_index":1798,"title":{},"name":{},"text":{"17":{}},"component":{}}],["vecdeque::with_capacity(n",{"_index":332,"title":{},"name":{},"text":{"2":{}},"component":{}}],["vector",{"_index":430,"title":{},"name":{},"text":{"4":{},"19":{},"20":{}},"component":{}}],["velo",{"_index":1993,"title":{},"name":{},"text":{"18":{}},"component":{}}],["velo.vi",{"_index":2062,"title":{},"name":{},"text":{"18":{}},"component":{}}],["velo.vx",{"_index":2063,"title":{},"name":{},"text":{"18":{}},"component":{}}],["veloc",{"_index":1962,"title":{},"name":{},"text":{"18":{}},"component":{}}],["ventur",{"_index":224,"title":{"6":{}},"name":{},"text":{"1":{}},"component":{}}],["veri",{"_index":43,"title":{},"name":{},"text":{"1":{},"17":{},"24":{}},"component":{}}],["version_numb",{"_index":1823,"title":{},"name":{},"text":{"17":{}},"component":{}}],["vertic",{"_index":724,"title":{},"name":{},"text":{"6":{},"14":{},"18":{}},"component":{}}],["visit",{"_index":1314,"title":{},"name":{},"text":{"13":{}},"component":{}}],["visited_idx",{"_index":1177,"title":{},"name":{},"text":{"10":{}},"component":{}}],["visited_idxs.contains(&nghbr_idx",{"_index":1186,"title":{},"name":{},"text":{"10":{}},"component":{}}],["visited_idxs.insert(idx",{"_index":1182,"title":{},"name":{},"text":{"10":{}},"component":{}}],["vx",{"_index":1994,"title":{},"name":{},"text":{"18":{}},"component":{}}],["vx1",{"_index":2019,"title":{},"name":{},"text":{"18":{}},"component":{}}],["vx2",{"_index":2023,"title":{},"name":{},"text":{"18":{}},"component":{}}],["vx_denom",{"_index":2021,"title":{},"name":{},"text":{"18":{}},"component":{}}],["vx_numer",{"_index":2020,"title":{},"name":{},"text":{"18":{}},"component":{}}],["vy",{"_index":1995,"title":{},"name":{},"text":{"18":{}},"component":{}}],["vy_denom",{"_index":2018,"title":{},"name":{},"text":{"18":{}},"component":{}}],["vy_num",{"_index":2017,"title":{},"name":{},"text":{"18":{}},"component":{}}],["w",{"_index":1681,"title":{},"name":{},"text":{"16":{},"25":{}},"component":{}}],["wall",{"_index":2976,"title":{},"name":{},"text":{"24":{}},"component":{}}],["want",{"_index":1659,"title":{},"name":{},"text":{"16":{},"18":{}},"component":{}}],["warn(clippy::pedant",{"_index":110,"title":{},"name":{},"text":{"1":{}},"component":{}}],["wasnt_pres",{"_index":2532,"title":{},"name":{},"text":{"20":{}},"component":{}}],["wasn’t",{"_index":1762,"title":{},"name":{},"text":{"17":{}},"component":{}}],["way",{"_index":957,"title":{},"name":{},"text":{"9":{},"15":{},"17":{},"18":{},"20":{},"22":{},"24":{}},"component":{}}],["we'r",{"_index":1853,"title":{},"name":{},"text":{"17":{}},"component":{}}],["weight",{"_index":2683,"title":{},"name":{},"text":{"22":{}},"component":{}}],["well",{"_index":867,"title":{},"name":{},"text":{"8":{},"9":{},"22":{}},"component":{}}],["went",{"_index":2675,"title":{},"name":{},"text":{"22":{}},"component":{}}],["we’d",{"_index":541,"title":{},"name":{},"text":{"5":{},"8":{}},"component":{}}],["we’ll",{"_index":1944,"title":{},"name":{},"text":{"17":{},"21":{},"23":{},"25":{}},"component":{}}],["we’r",{"_index":78,"title":{},"name":{},"text":{"1":{},"18":{},"20":{}},"component":{}}],["we’v",{"_index":1346,"title":{},"name":{},"text":{"13":{},"17":{},"18":{},"20":{}},"component":{}}],["whale",{"_index":229,"title":{"8":{}},"name":{},"text":{"1":{}},"component":{}}],["whenev",{"_index":860,"title":{},"name":{},"text":{"8":{},"19":{}},"component":{}}],["wherea",{"_index":1279,"title":{},"name":{},"text":{"12":{},"13":{}},"component":{}}],["where’",{"_index":1960,"title":{},"name":{},"text":{"18":{}},"component":{}}],["whether",{"_index":1566,"title":{},"name":{},"text":{"15":{},"18":{},"21":{}},"component":{}}],["whichev",{"_index":874,"title":{},"name":{},"text":{"8":{}},"component":{}}],["whitespace_sepd_strs_to_digits(in_out.next",{"_index":1083,"title":{},"name":{},"text":{"9":{}},"component":{}}],["whitespace_sepd_strs_to_digits(str",{"_index":1074,"title":{},"name":{},"text":{"9":{}},"component":{}}],["whose",{"_index":439,"title":{},"name":{},"text":{"4":{},"5":{},"6":{},"10":{},"19":{},"20":{},"21":{}},"component":{}}],["width",{"_index":1137,"title":{},"name":{},"text":{"10":{},"12":{},"24":{},"26":{}},"component":{}}],["width(span",{"_index":2773,"title":{},"name":{},"text":{"23":{}},"component":{}}],["width(x_rang",{"_index":2781,"title":{},"name":{},"text":{"23":{}},"component":{}}],["width(y_rang",{"_index":2782,"title":{},"name":{},"text":{"23":{}},"component":{}}],["width(z_rang",{"_index":2783,"title":{},"name":{},"text":{"23":{}},"component":{}}],["win",{"_index":653,"title":{},"name":{},"text":{"5":{},"22":{}},"component":{}}],["win_threshold",{"_index":2727,"title":{},"name":{},"text":{"22":{}},"component":{}}],["winning_num",{"_index":600,"title":{},"name":{},"text":{"5":{}},"component":{}}],["wire",{"_index":899,"title":{},"name":{},"text":{"9":{}},"component":{}}],["within",{"_index":1544,"title":{},"name":{},"text":{"15":{},"24":{}},"component":{}}],["without",{"_index":60,"title":{},"name":{},"text":{"1":{},"11":{},"17":{}},"component":{}}],["won",{"_index":548,"title":{},"name":{},"text":{"5":{}},"component":{}}],["won't",{"_index":1280,"title":{},"name":{},"text":{"12":{},"17":{}},"component":{}}],["won’t",{"_index":1743,"title":{},"name":{},"text":{"16":{}},"component":{}}],["word",{"_index":1434,"title":{},"name":{},"text":{"14":{},"17":{},"18":{},"20":{},"23":{},"24":{}},"component":{}}],["words.next",{"_index":1436,"title":{},"name":{},"text":{"14":{}},"component":{}}],["work",{"_index":33,"title":{},"name":{},"text":{"1":{},"4":{},"8":{},"15":{},"16":{},"18":{},"20":{}},"component":{}}],["worst",{"_index":846,"title":{},"name":{},"text":{"8":{}},"component":{}}],["worth",{"_index":2674,"title":{},"name":{},"text":{"22":{},"24":{}},"component":{}}],["wouldn’t",{"_index":74,"title":{},"name":{},"text":{"1":{}},"component":{}}],["wrapper",{"_index":2932,"title":{},"name":{},"text":{"24":{}},"component":{}}],["wrinkl",{"_index":925,"title":{},"name":{},"text":{"9":{},"13":{},"20":{}},"component":{}}],["write",{"_index":1794,"title":{},"name":{},"text":{"17":{},"21":{},"23":{},"24":{},"25":{}},"component":{}}],["write!(f",{"_index":174,"title":{},"name":{},"text":{"1":{},"19":{},"23":{}},"component":{}}],["writeln!(f",{"_index":2612,"title":{},"name":{},"text":{"21":{},"26":{}},"component":{}}],["written",{"_index":1044,"title":{},"name":{},"text":{"9":{}},"component":{}}],["wrong",{"_index":1548,"title":{},"name":{},"text":{"15":{}},"component":{}}],["wrote",{"_index":1758,"title":{},"name":{},"text":{"17":{}},"component":{}}],["x",{"_index":498,"title":{},"name":{},"text":{"4":{},"5":{},"6":{},"8":{},"9":{},"12":{},"14":{},"17":{},"18":{},"20":{},"24":{},"25":{}},"component":{}}],["x(t",{"_index":1432,"title":{},"name":{},"text":{"14":{},"18":{}},"component":{}}],["x,i",{"_index":1431,"title":{},"name":{},"text":{"14":{},"18":{}},"component":{}}],["x,y)\\in",{"_index":2103,"title":{},"name":{},"text":{"18":{}},"component":{}}],["x.into",{"_index":2427,"title":{},"name":{},"text":{"20":{}},"component":{}}],["x.max(i",{"_index":1889,"title":{},"name":{},"text":{"17":{}},"component":{}}],["x.min(i",{"_index":1888,"title":{},"name":{},"text":{"17":{}},"component":{}}],["x0",{"_index":2785,"title":{},"name":{},"text":{"23":{}},"component":{}}],["x1",{"_index":683,"title":{},"name":{},"text":{"6":{},"18":{},"20":{},"23":{}},"component":{}}],["x2",{"_index":685,"title":{},"name":{},"text":{"6":{},"18":{},"20":{}},"component":{}}],["x2).ab",{"_index":709,"title":{},"name":{},"text":{"6":{}},"component":{}}],["x2).zip(range_between(y1",{"_index":711,"title":{},"name":{},"text":{"6":{}},"component":{}}],["x=1000000..1001000",{"_index":1986,"title":{},"name":{},"text":{"18":{}},"component":{}}],["x=20..30",{"_index":2077,"title":{},"name":{},"text":{"18":{}},"component":{}}],["x=34..35",{"_index":2080,"title":{},"name":{},"text":{"18":{}},"component":{}}],["x=a",{"_index":1429,"title":{},"name":{},"text":{"14":{}},"component":{}}],["x[1",{"_index":2433,"title":{},"name":{},"text":{"20":{}},"component":{}}],["x[2",{"_index":2436,"title":{},"name":{},"text":{"20":{}},"component":{}}],["x_1",{"_index":657,"title":{},"name":{},"text":{"6":{},"23":{}},"component":{}}],["x_1,y,z",{"_index":2771,"title":{},"name":{},"text":{"23":{}},"component":{}}],["x_1|=|y_k",{"_index":739,"title":{},"name":{},"text":{"6":{}},"component":{}}],["x_2",{"_index":659,"title":{},"name":{},"text":{"6":{}},"component":{}}],["x_2,y,z",{"_index":2772,"title":{},"name":{},"text":{"23":{}},"component":{}}],["x_\\mathrm{max}]\\times[y_\\mathrm{min",{"_index":1968,"title":{},"name":{},"text":{"18":{}},"component":{}}],["x_k",{"_index":738,"title":{},"name":{},"text":{"6":{}},"component":{}}],["x_k,y_k",{"_index":737,"title":{},"name":{},"text":{"6":{}},"component":{}}],["x_max",{"_index":1998,"title":{},"name":{},"text":{"18":{}},"component":{}}],["x_min",{"_index":1997,"title":{},"name":{},"text":{"18":{}},"component":{}}],["x_min..=x_max",{"_index":2060,"title":{},"name":{},"text":{"18":{}},"component":{}}],["x_rang",{"_index":2778,"title":{},"name":{},"text":{"23":{}},"component":{}}],["x_ranges.iter().flatten",{"_index":2817,"title":{},"name":{},"text":{"23":{}},"component":{}}],["y",{"_index":514,"title":{},"name":{},"text":{"4":{},"6":{},"9":{},"14":{},"17":{},"18":{},"20":{},"25":{}},"component":{}}],["y(t",{"_index":1433,"title":{},"name":{},"text":{"14":{},"18":{}},"component":{}}],["y)).or_default",{"_index":705,"title":{},"name":{},"text":{"6":{}},"component":{}}],["y.ab",{"_index":2499,"title":{},"name":{},"text":{"20":{}},"component":{}}],["y.into",{"_index":2428,"title":{},"name":{},"text":{"20":{}},"component":{}}],["y0",{"_index":2787,"title":{},"name":{},"text":{"23":{}},"component":{}}],["y1",{"_index":684,"title":{},"name":{},"text":{"6":{},"18":{},"20":{},"23":{}},"component":{}}],["y2",{"_index":686,"title":{},"name":{},"text":{"6":{},"18":{},"20":{}},"component":{}}],["y2).ab",{"_index":710,"title":{},"name":{},"text":{"6":{}},"component":{}}],["y=0",{"_index":2139,"title":{},"name":{},"text":{"18":{}},"component":{}}],["y=v_i",{"_index":2118,"title":{},"name":{},"text":{"18":{}},"component":{}}],["y[0",{"_index":2431,"title":{},"name":{},"text":{"20":{}},"component":{}}],["y[1",{"_index":2434,"title":{},"name":{},"text":{"20":{}},"component":{}}],["y[2",{"_index":2437,"title":{},"name":{},"text":{"20":{}},"component":{}}],["y].map(|op",{"_index":515,"title":{},"name":{},"text":{"4":{}},"component":{}}],["y_1",{"_index":658,"title":{},"name":{},"text":{"6":{}},"component":{}}],["y_2",{"_index":660,"title":{},"name":{},"text":{"6":{}},"component":{}}],["y_\\mathrm{max",{"_index":1969,"title":{},"name":{},"text":{"18":{}},"component":{}}],["y_k",{"_index":740,"title":{},"name":{},"text":{"6":{}},"component":{}}],["y_max",{"_index":2000,"title":{},"name":{},"text":{"18":{}},"component":{}}],["y_min",{"_index":1999,"title":{},"name":{},"text":{"18":{}},"component":{}}],["y_min..=y_max",{"_index":2052,"title":{},"name":{},"text":{"18":{}},"component":{}}],["y_rang",{"_index":2779,"title":{},"name":{},"text":{"23":{}},"component":{}}],["y_ranges.iter().flatten",{"_index":2818,"title":{},"name":{},"text":{"23":{}},"component":{}}],["year’",{"_index":292,"title":{},"name":{},"text":{"1":{},"15":{}},"component":{}}],["you’r",{"_index":41,"title":{},"name":{},"text":{"1":{}},"component":{}}],["z",{"_index":2426,"title":{},"name":{},"text":{"20":{},"25":{}},"component":{}}],["z.abs()).unwrap",{"_index":2500,"title":{},"name":{},"text":{"20":{}},"component":{}}],["z.into",{"_index":2429,"title":{},"name":{},"text":{"20":{}},"component":{}}],["z0",{"_index":2789,"title":{},"name":{},"text":{"23":{}},"component":{}}],["z1",{"_index":2578,"title":{},"name":{},"text":{"20":{},"23":{}},"component":{}}],["z2",{"_index":2582,"title":{},"name":{},"text":{"20":{}},"component":{}}],["z[0",{"_index":2432,"title":{},"name":{},"text":{"20":{}},"component":{}}],["z[1",{"_index":2435,"title":{},"name":{},"text":{"20":{}},"component":{}}],["z[2",{"_index":2438,"title":{},"name":{},"text":{"20":{}},"component":{}}],["z_init",{"_index":3202,"title":{},"name":{},"text":{"25":{}},"component":{}}],["z_rang",{"_index":2780,"title":{},"name":{},"text":{"23":{}},"component":{}}],["z_ranges.iter().flatten",{"_index":2819,"title":{},"name":{},"text":{"23":{}},"component":{}}],["zero",{"_index":547,"title":{},"name":{},"text":{"5":{},"20":{}},"component":{}}],["zip(elems.iter().enumerate().skip(1",{"_index":2199,"title":{},"name":{},"text":{"19":{}},"component":{}}],["zip(self.template.chars().skip(1",{"_index":1592,"title":{},"name":{},"text":{"15":{}},"component":{}}]],"pipeline":["stemmer"]},"store":{"documents":{"1":{"id":1,"text":"This doc has my solutions for the 2021 Advent of Code. It assumes some familiarity with the Rust language. Advent of Code gives all participants the same problems, but gives different inputs to each participant. Therefore, it makes little sense to give the actual numeric answers to problems here. However, we do provide the input that was given to us in order to contextualize the input-parsing code. The solutions below should work for any input/output pair provided by Advent of Code. This document has the solutions out in the open! Don’t read it if you’re still working on Advent of Code. Rust is a very strict language and makes you explicitly handle all errors that might arise (as opposed to, say, exceptions implicitly being thrown on error, as Python does). However, we can trust our inputs, taken straight from Advent of Code, to be correct and give unambiguous answers without errors. For this reason, we tend to be pretty loosey-goosey about unwrapping the Options and Results that the Rust compiler correctly points out we could theoretically encounter. (There wouldn’t be any point to handling those cases gracefully; we’re just trying to solve Advent of Code, not create general-purpose a submarine-squid-bingo-player that can function sensibly even when the squid gives us nonsensical input. For our purposes, the residual variants of a Try object at the boundary of our program are ! (Rust’s bottom or “never” type).) Commonly used code, in src/lib.rs and src/utils.rs, is below: lib.rs #![feature(array_zip)] #![feature(map_first_last)] #![feature(bool_to_option)] #![warn(clippy::pedantic)] #![allow( clippy::enum_glob_use, clippy::missing_panics_doc, clippy::must_use_candidate, clippy::similar_names, clippy::too_many_lines )] use std::fmt::{Debug, Display}; pub(crate) mod utils; // tag::mods[] macro_rules! include_days { ($($mod_name:ident:$ft_name:literal),* $(,)?) => { $(#[cfg(feature = $ft_name)] pub mod $mod_name;)* }; } include_days!( day_01:\"day_01\", day_02:\"day_02\", day_03:\"day_03\", day_04:\"day_04\", day_05:\"day_05\", day_06:\"day_06\", day_07:\"day_07\", day_08:\"day_08\", day_09:\"day_09\", day_10:\"day_10\", day_11:\"day_11\", day_12:\"day_12\", day_13:\"day_13\", day_14:\"day_14\", day_15:\"day_15\", day_16:\"day_16\", day_17:\"day_17\", day_18:\"day_18\", day_19:\"day_19\", day_20:\"day_20\", day_21:\"day_21\", day_22:\"day_22\", day_23:\"day_23\", day_24:\"day_24\", day_25:\"day_25\", ); // end::mods[] #[derive(Debug, PartialEq, Eq)] pub struct Answer { day: usize, pt1: T1, pt2: T2, } impl Display for Answer { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let Answer { day, pt1, pt2 } = self; write!(f, \"Day: {:?} ; Part 1: {:?} ; Part 2: {:?}\", day, pt1, pt2) } } impl From for Answer { fn from((day, (pt1, pt2)): (usize, (T1, T2))) -> Self { Self { day, pt1, pt2 } } } utils.rs #![allow(dead_code)] #[macro_export] macro_rules! test_input { ($input:expr, day: $day:expr, ans: ($pt1:expr, $pt2:expr)) => { assert_eq!(ans_for_input($input), ($day, ($pt1, $pt2)).into()) }; ($input:expr, pt1: $pt1:expr) => { assert_eq!(pt1($input), $pt1); }; ($input:expr, pt2: $pt2:expr) => { assert_eq!(pt2($input), $pt2); }; } // tag::code[] pub(crate) fn to_decimal>(binary_digits_msbf: V) -> u32 { binary_digits_msbf .as_ref() .iter() .rev() .enumerate() .map(|(pow2, &is_on)| u32::from(is_on) * 2u32.pow(u32::try_from(pow2).unwrap())) .reduce(|a, b| a + b) .unwrap_or(0) } pub(crate) fn to_big_decimal>(binary_digits_msbf: V) -> u64 { binary_digits_msbf .as_ref() .iter() .rev() .enumerate() .map(|(pow2, &is_on)| u64::from(is_on) * 2u64.pow(u32::try_from(pow2).unwrap())) .reduce(|a, b| a + b) .unwrap_or(0) } pub(crate) fn abs_diff(a: usize, b: usize) -> usize { if a > b { a - b } else { b - a } } // end::code[] Day 1: Sonar Sweep Day 2: Dive! Day 3: Binary Diagnostic Day 4: Giant Squid Day 5: Hydrothermal Venture Day 6: Lanternfish Day 7: The Treachery of Whales Day 8: Seven Segment Search Day 9: Smoke Basin Day 10: Syntax Scoring Day 11: Dumbo Octopus Day 12: Passage Pathing Day 13: Transparent Origami Day 14: Extended Polymerization Day 15: Chiton Day 16: Packet Decoder Day 17: Trick Shot Day 18: Snailfish Day 19: Beacon Scanner Day 20: Trench Map Day 21: Dirac Dice Day 22: Reactor Reboot Day 23: Amphipod Day 24: Arithmetic Logic Unit Day 25: Sea Cucumber This was a lot of work, but a lot of fun, and I learned a ton, both about algorithms in general and about Rust. Looking forward to next year’s Advent of Code!","title":"Advent of Code 2021","component":"ROOT","version":"","name":"index","url":"/","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Problems and Solutions","hash":"_problems_and_solutions","id":2},{"text":"Conclusion","hash":"_conclusion","id":3}]},"2":{"id":2,"text":"Day #1 problem description │ Problem input Part 1 asks to find when the current depth is greater than the previous depth. Part 2 asks to find when the current running sum of depths is greater than the previous running sum, with a running sum of length 3. These are both special cases of finding when the current length-\\(n\\) running sum of depths is greater than the previous length-\\(n\\) running sum, with Part 1 using a length of \\(n=1\\) and Part 2 using \\(n=3\\). The solution uses a CircularBuffer to keep the past \\(n\\) depths. Since the “interior” components of the current and previous running sums are the same, we can compare the two running sums by merely checking the incoming number against the outgoing number, i.e., the new depth against the oldest depth still in the buffer. If the current depth is greater, then so is the current running sum. // tag::setup[] use crate::Answer; use std::collections::VecDeque; fn get_n_increasing_running_sum_of_depths(input: &str, n: usize) -> Option { let mut depth_buf = VecDeque::with_capacity(n); let mut depths = input.lines().map(|line| line.parse::().unwrap()); depth_buf.extend(depths.by_ref().take(n)); if depth_buf.len() old_depth { n_increasing += 1; } } Some(n_increasing) } fn ans_for_input(input: &str) -> Answer { (1, (pt1(input), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(input: &str) -> usize { get_n_increasing_running_sum_of_depths(input, 1).unwrap() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> usize { get_n_increasing_running_sum_of_depths(input, 3).unwrap() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 1, ans: (7, 5)); test_input!(include_str!(\"input.txt\"), day: 1, ans: (1681, 1704)); } } // tag::setup[] use crate::Answer; use std::collections::VecDeque; fn get_n_increasing_running_sum_of_depths(input: &str, n: usize) -> Option { let mut depth_buf = VecDeque::with_capacity(n); let mut depths = input.lines().map(|line| line.parse::().unwrap()); depth_buf.extend(depths.by_ref().take(n)); if depth_buf.len() old_depth { n_increasing += 1; } } Some(n_increasing) } fn ans_for_input(input: &str) -> Answer { (1, (pt1(input), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(input: &str) -> usize { get_n_increasing_running_sum_of_depths(input, 1).unwrap() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> usize { get_n_increasing_running_sum_of_depths(input, 3).unwrap() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 1, ans: (7, 5)); test_input!(include_str!(\"input.txt\"), day: 1, ans: (1681, 1704)); } }","title":"Day 1: Sonar Sweep","component":"ROOT","version":"","name":"soln","url":"/src/day_01/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Parts 1 and 2","hash":"_parts_1_and_2","id":2}]},"3":{"id":3,"text":"Day #2 problem description │ Problem input There isn’t really anything too deep to go into here. You just have to update the current state correctly. use crate::Answer; // tag::setup[] struct Position { h: i32, v: i32, } impl Position { fn get_ans(&self) -> i32 { self.h * self.v } } enum Direction { Forward, Up, Down, } impl Direction { fn from_str(s: &str) -> Option { use Direction::*; Some(match s { \"forward\" => Forward, \"up\" => Up, \"down\" => Down, _ => return None, }) } } struct Step { direction: Direction, dist: i32, } fn read_input(s: &str) -> Option> { s.lines() .map(|line| { let mut tokens_iter = line.split_whitespace(); let direction = Direction::from_str(tokens_iter.next()?)?; let dist = tokens_iter.next()?.parse().ok()?; Some(Step { direction, dist }) }) .collect() } fn ans_for_input(input: &str) -> Answer { let directions = read_input(input).unwrap(); (2, (pt1(directions.iter()), pt2(directions.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(steps: impl Iterator) -> i32 { use Direction::*; let mut h = 0; let mut v = 0; for step in steps { let Step { direction, dist } = &*step; match direction { Forward => h += dist, Up => v -= dist, Down => v += dist, }; } Position { h, v }.get_ans() } // end::pt1[] // tag::pt2[] fn pt2>(steps: impl Iterator) -> i32 { use Direction::*; let mut h = 0; let mut v = 0; let mut aim = 0; for step in steps { let Step { direction, dist } = step.borrow(); let dist = *dist; match direction { Forward => { h += dist; v += aim * dist; } Up => aim -= dist, Down => aim += dist, }; } Position { h, v }.get_ans() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 2, ans: (150, 900)); test_input!(include_str!(\"input.txt\"), day: 2, ans: (1_459_206, 1_320_534_480)); } } use crate::Answer; // tag::setup[] struct Position { h: i32, v: i32, } impl Position { fn get_ans(&self) -> i32 { self.h * self.v } } enum Direction { Forward, Up, Down, } impl Direction { fn from_str(s: &str) -> Option { use Direction::*; Some(match s { \"forward\" => Forward, \"up\" => Up, \"down\" => Down, _ => return None, }) } } struct Step { direction: Direction, dist: i32, } fn read_input(s: &str) -> Option> { s.lines() .map(|line| { let mut tokens_iter = line.split_whitespace(); let direction = Direction::from_str(tokens_iter.next()?)?; let dist = tokens_iter.next()?.parse().ok()?; Some(Step { direction, dist }) }) .collect() } fn ans_for_input(input: &str) -> Answer { let directions = read_input(input).unwrap(); (2, (pt1(directions.iter()), pt2(directions.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(steps: impl Iterator) -> i32 { use Direction::*; let mut h = 0; let mut v = 0; for step in steps { let Step { direction, dist } = &*step; match direction { Forward => h += dist, Up => v -= dist, Down => v += dist, }; } Position { h, v }.get_ans() } // end::pt1[] // tag::pt2[] fn pt2>(steps: impl Iterator) -> i32 { use Direction::*; let mut h = 0; let mut v = 0; let mut aim = 0; for step in steps { let Step { direction, dist } = step.borrow(); let dist = *dist; match direction { Forward => { h += dist; v += aim * dist; } Up => aim -= dist, Down => aim += dist, }; } Position { h, v }.get_ans() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 2, ans: (150, 900)); test_input!(include_str!(\"input.txt\"), day: 2, ans: (1_459_206, 1_320_534_480)); } } use crate::Answer; // tag::setup[] struct Position { h: i32, v: i32, } impl Position { fn get_ans(&self) -> i32 { self.h * self.v } } enum Direction { Forward, Up, Down, } impl Direction { fn from_str(s: &str) -> Option { use Direction::*; Some(match s { \"forward\" => Forward, \"up\" => Up, \"down\" => Down, _ => return None, }) } } struct Step { direction: Direction, dist: i32, } fn read_input(s: &str) -> Option> { s.lines() .map(|line| { let mut tokens_iter = line.split_whitespace(); let direction = Direction::from_str(tokens_iter.next()?)?; let dist = tokens_iter.next()?.parse().ok()?; Some(Step { direction, dist }) }) .collect() } fn ans_for_input(input: &str) -> Answer { let directions = read_input(input).unwrap(); (2, (pt1(directions.iter()), pt2(directions.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(steps: impl Iterator) -> i32 { use Direction::*; let mut h = 0; let mut v = 0; for step in steps { let Step { direction, dist } = &*step; match direction { Forward => h += dist, Up => v -= dist, Down => v += dist, }; } Position { h, v }.get_ans() } // end::pt1[] // tag::pt2[] fn pt2>(steps: impl Iterator) -> i32 { use Direction::*; let mut h = 0; let mut v = 0; let mut aim = 0; for step in steps { let Step { direction, dist } = step.borrow(); let dist = *dist; match direction { Forward => { h += dist; v += aim * dist; } Up => aim -= dist, Down => aim += dist, }; } Position { h, v }.get_ans() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 2, ans: (150, 900)); test_input!(include_str!(\"input.txt\"), day: 2, ans: (1_459_206, 1_320_534_480)); } }","title":"Day 2: Dive!","component":"ROOT","version":"","name":"soln","url":"/src/day_02/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"4":{"id":4,"text":"Day #3 problem description │ Problem input This challenge mostly just requires filtering arrays and counting elements satisfying a condition. The first thing we do is read the input file into a ndarray::Array2 of size (n_rows, n_cols), where a true value corresponds to a 1 character in the input, and a false to a 0. We also created a function that converts a binary vector, most significant digit first, to a (decimal) number (see the Setup section). For example, given 10011, we compute [1, 0, 0, 1, 1] .* [16, 8, 4, 2, 1] = [16, 0, 0, 2, 1], whose sum is 19. (This is just how positional notation works.) // tag::setup[] use crate::{utils::to_decimal, Answer}; use ndarray::prelude::*; fn read_input(input: &str) -> Option> { let mut lines = input.lines(); let mut bit_vec = Vec::new(); let first_line = lines.next()?; let line_length = first_line.len(); for line in std::iter::once(first_line).chain(lines) { for c in line.bytes() { bit_vec.push(c == b'1'); } } let n_lines = bit_vec.len() / line_length; Array2::from_shape_vec((n_lines, line_length), bit_vec).ok() } fn ans_for_input(input: &str) -> Answer { let mat = read_input(input).unwrap(); (3, (pt1(&mat), pt2(&mat))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mat: &Array2) -> u32 { let (n_rows, n_cols) = mat.dim(); let n_ones = mat.map(|x| usize::from(*x)).sum_axis(Axis(0)); let n_zeros = n_ones.map(|n| n_rows - n); let col_has_more_ones_than_zeros = ndarray::Zip::from(&n_ones) .and(&n_zeros) .map_collect(|n_o, n_z| n_o > n_z) .into_shape((n_cols,)) .unwrap(); let gamma_rate = to_decimal(col_has_more_ones_than_zeros.to_vec()); let epsilon_rate = (2u32.pow(u32::try_from(n_cols).unwrap()) - 1) - gamma_rate; gamma_rate * epsilon_rate } // end::pt1[] // tag::pt2[] fn value_of_line_chosen_by_criterion( mat: &Array2, cmp_predicate: impl Fn(usize, usize) -> bool, ) -> u32 { let (n_rows, n_cols) = mat.dim(); let mut candidates = Array1::::from_shape_simple_fn((n_rows,), || true); for i in 0..n_cols { let n_candidates_remaining = candidates.mapv(|c| if c { 1usize } else { 0 }).sum(); if n_candidates_remaining == 1 { break; } let column = mat.index_axis(Axis(1), i); let digit_sum = column .iter() .enumerate() .filter_map(|(i, &x)| { if candidates[[i]] { Some(usize::from(x)) } else { None } }) .sum::(); let most_common_digit = cmp_predicate(2 * digit_sum, n_candidates_remaining); candidates = ndarray::Zip::from(&candidates) .and(&column) .map_collect(|&candidate, &digit| candidate && digit == most_common_digit); } let index = candidates .into_iter() .enumerate() .find_map(|(i, x)| if x { Some(i) } else { None }) .unwrap(); let line = mat.index_axis(Axis(0), index); to_decimal(line.to_vec()) } fn pt2(mat: &Array2) -> u32 { let [oxy_rate, co2_rate] = [|x, y| x >= y, |x, y| x Option> { let mut lines = input.lines(); let mut bit_vec = Vec::new(); let first_line = lines.next()?; let line_length = first_line.len(); for line in std::iter::once(first_line).chain(lines) { for c in line.bytes() { bit_vec.push(c == b'1'); } } let n_lines = bit_vec.len() / line_length; Array2::from_shape_vec((n_lines, line_length), bit_vec).ok() } fn ans_for_input(input: &str) -> Answer { let mat = read_input(input).unwrap(); (3, (pt1(&mat), pt2(&mat))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mat: &Array2) -> u32 { let (n_rows, n_cols) = mat.dim(); let n_ones = mat.map(|x| usize::from(*x)).sum_axis(Axis(0)); let n_zeros = n_ones.map(|n| n_rows - n); let col_has_more_ones_than_zeros = ndarray::Zip::from(&n_ones) .and(&n_zeros) .map_collect(|n_o, n_z| n_o > n_z) .into_shape((n_cols,)) .unwrap(); let gamma_rate = to_decimal(col_has_more_ones_than_zeros.to_vec()); let epsilon_rate = (2u32.pow(u32::try_from(n_cols).unwrap()) - 1) - gamma_rate; gamma_rate * epsilon_rate } // end::pt1[] // tag::pt2[] fn value_of_line_chosen_by_criterion( mat: &Array2, cmp_predicate: impl Fn(usize, usize) -> bool, ) -> u32 { let (n_rows, n_cols) = mat.dim(); let mut candidates = Array1::::from_shape_simple_fn((n_rows,), || true); for i in 0..n_cols { let n_candidates_remaining = candidates.mapv(|c| if c { 1usize } else { 0 }).sum(); if n_candidates_remaining == 1 { break; } let column = mat.index_axis(Axis(1), i); let digit_sum = column .iter() .enumerate() .filter_map(|(i, &x)| { if candidates[[i]] { Some(usize::from(x)) } else { None } }) .sum::(); let most_common_digit = cmp_predicate(2 * digit_sum, n_candidates_remaining); candidates = ndarray::Zip::from(&candidates) .and(&column) .map_collect(|&candidate, &digit| candidate && digit == most_common_digit); } let index = candidates .into_iter() .enumerate() .find_map(|(i, x)| if x { Some(i) } else { None }) .unwrap(); let line = mat.index_axis(Axis(0), index); to_decimal(line.to_vec()) } fn pt2(mat: &Array2) -> u32 { let [oxy_rate, co2_rate] = [|x, y| x >= y, |x, y| x Option> { let mut lines = input.lines(); let mut bit_vec = Vec::new(); let first_line = lines.next()?; let line_length = first_line.len(); for line in std::iter::once(first_line).chain(lines) { for c in line.bytes() { bit_vec.push(c == b'1'); } } let n_lines = bit_vec.len() / line_length; Array2::from_shape_vec((n_lines, line_length), bit_vec).ok() } fn ans_for_input(input: &str) -> Answer { let mat = read_input(input).unwrap(); (3, (pt1(&mat), pt2(&mat))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mat: &Array2) -> u32 { let (n_rows, n_cols) = mat.dim(); let n_ones = mat.map(|x| usize::from(*x)).sum_axis(Axis(0)); let n_zeros = n_ones.map(|n| n_rows - n); let col_has_more_ones_than_zeros = ndarray::Zip::from(&n_ones) .and(&n_zeros) .map_collect(|n_o, n_z| n_o > n_z) .into_shape((n_cols,)) .unwrap(); let gamma_rate = to_decimal(col_has_more_ones_than_zeros.to_vec()); let epsilon_rate = (2u32.pow(u32::try_from(n_cols).unwrap()) - 1) - gamma_rate; gamma_rate * epsilon_rate } // end::pt1[] // tag::pt2[] fn value_of_line_chosen_by_criterion( mat: &Array2, cmp_predicate: impl Fn(usize, usize) -> bool, ) -> u32 { let (n_rows, n_cols) = mat.dim(); let mut candidates = Array1::::from_shape_simple_fn((n_rows,), || true); for i in 0..n_cols { let n_candidates_remaining = candidates.mapv(|c| if c { 1usize } else { 0 }).sum(); if n_candidates_remaining == 1 { break; } let column = mat.index_axis(Axis(1), i); let digit_sum = column .iter() .enumerate() .filter_map(|(i, &x)| { if candidates[[i]] { Some(usize::from(x)) } else { None } }) .sum::(); let most_common_digit = cmp_predicate(2 * digit_sum, n_candidates_remaining); candidates = ndarray::Zip::from(&candidates) .and(&column) .map_collect(|&candidate, &digit| candidate && digit == most_common_digit); } let index = candidates .into_iter() .enumerate() .find_map(|(i, x)| if x { Some(i) } else { None }) .unwrap(); let line = mat.index_axis(Axis(0), index); to_decimal(line.to_vec()) } fn pt2(mat: &Array2) -> u32 { let [oxy_rate, co2_rate] = [|x, y| x >= y, |x, y| x < y].map(|op| value_of_line_chosen_by_criterion(mat, op)); oxy_rate * co2_rate } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 3, ans: (198, 230)); test_input!(include_str!(\"input.txt\"), day: 3, ans: (2_743_844, 6_677_951)); } }","title":"Day 3: Binary Diagnostic","component":"ROOT","version":"","name":"soln","url":"/src/day_03/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"5":{"id":5,"text":"Day #4 problem description │ Problem input The game is represented as a list of boards and a list of drawn numbers. Each board has: A dictionary grid that maps undrawn numbers on the board to their Cartesian coordinates (a pair (row, col)) on the board. When a number is drawn, its Cartesian coordinates are used to update progress (below), and then the number is removed from the dictionary. The only reason drawn numbers are removed from a board’s dictionary is that Advent of Code asks for the sum of the board’s undrawn numbers to compute the answer, so we need to keep track of which numbers on a given board haven’t been drawn yet. Otherwise, we’d have had no reason to mutate the dictionary at all. progress, which stores for each row and column the count of numbers in that row/column have not yet been drawn. If one of those counts hit zero, then every number in that row/column has been drawn, and so the board has a \"Bingo\" (i.e., has won). The row and column indices have the same meaning as the Cartesian coordinates in the dictionary described above: if number 25 is drawn, and 25’s position on a particular board is (2, 3), then progress.rows[2] and progress.cols[3] each get decremented. Reading the input text into a game (numbers and boards) is in read_input_into_game, whose (not particularly interesting) implementation should serve as its docs. get_answer_from_final_game_state is just used to prove to Advent of Code that we actually got the solution. // tag::setup[] use crate::Answer; use num::{integer::div_mod_floor, Integer}; use std::{ collections::{BTreeMap as Map, BTreeSet as Set}, str::FromStr, }; #[derive(Debug)] struct BoardProgress { rows: Vec, cols: Vec, has_won: bool, } impl BoardProgress { fn new(n_rows: usize, n_cols: usize) -> Self { let rows = vec![n_cols; n_rows]; let cols = vec![n_rows; n_cols]; Self { rows, cols, has_won: false, } } fn handle_entry(&mut self, row: usize, col: usize) { if self.has_won { return; } self.rows[row] -= 1; self.cols[col] -= 1; if self.rows[row] == 0 || self.cols[col] == 0 { self.has_won = true; } } } #[derive(Debug)] struct Board { grid: Map, progress: BoardProgress, } impl Board { fn new(nums: &[T], n_cols: usize) -> Self { let n_rows = nums.len() / n_cols; assert_eq!(n_rows * n_cols, nums.len()); let mut grid = Map::new(); for (i, &x) in nums.iter().enumerate() { let (r, c) = div_mod_floor(i, n_cols); grid.insert(x, (r, c)); } Self { grid, progress: BoardProgress::new(n_rows, n_cols), } } fn play_number(&mut self, n: T) { let (r, c) = match self.grid.remove(&n) { Some(coords) => coords, None => return, }; self.progress.handle_entry(r, c); } fn has_won(&self) -> bool { self.progress.has_won } fn get_ans(&self, winning_num: T) -> T { let unmarked_sum = self.grid.keys().copied().sum::(); winning_num * unmarked_sum } } struct Game { boards: Vec>, numbers: Vec, } impl Game { fn from_str(s: &str) -> Option { let mut lines = s.lines().chain(std::iter::once(\"\")); let nums = lines .next()? .split(',') .map(|s| s.parse::().ok()) .collect::>>()?; let mut boards = vec![]; let mut this_board = vec![]; let mut n_cols = None; for line in lines { if line.is_empty() { if !this_board.is_empty() { let board = Board::new(this_board.as_slice(), n_cols.unwrap()); boards.push(board); this_board.clear(); } } else { for num in line.split_whitespace().map(|s| s.parse::().ok()) { let num = num?; this_board.push(num); } if matches!(n_cols, None) { n_cols = Some(this_board.len()); } } } Some(Self { boards, numbers: nums, }) } } fn ans_for_input(input: &str) -> Answer { let [game1, game2] = [0; 2].map(|_| Game::from_str(input).unwrap()); (4, (pt1(game1), pt2(game2))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mut game: Game) -> i32 { for &num in &game.numbers { for board in &mut game.boards { board.play_number(num); if board.has_won() { return board.get_ans(num); } } } unreachable!(); } // end::pt1[] // tag::pt2[] fn pt2(mut game: Game) -> i32 { let mut ongoing_game_idxs = (0..game.boards.len()).collect::>(); for &num in &game.numbers { for (board_idx, board) in game.boards.iter_mut().enumerate() { let already_won = !ongoing_game_idxs.contains(&board_idx); if already_won { continue; } board.play_number(num); if board.has_won() { if ongoing_game_idxs.len() == 1 { return board.get_ans(num); } ongoing_game_idxs.remove(&board_idx); } } } unreachable!(); } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 4, ans: (4512, 1924)); test_input!(include_str!(\"input.txt\"), day: 4, ans: (87456, 15561)); } } We simply draw numbers until a board has won, then get the answer. // tag::setup[] use crate::Answer; use num::{integer::div_mod_floor, Integer}; use std::{ collections::{BTreeMap as Map, BTreeSet as Set}, str::FromStr, }; #[derive(Debug)] struct BoardProgress { rows: Vec, cols: Vec, has_won: bool, } impl BoardProgress { fn new(n_rows: usize, n_cols: usize) -> Self { let rows = vec![n_cols; n_rows]; let cols = vec![n_rows; n_cols]; Self { rows, cols, has_won: false, } } fn handle_entry(&mut self, row: usize, col: usize) { if self.has_won { return; } self.rows[row] -= 1; self.cols[col] -= 1; if self.rows[row] == 0 || self.cols[col] == 0 { self.has_won = true; } } } #[derive(Debug)] struct Board { grid: Map, progress: BoardProgress, } impl Board { fn new(nums: &[T], n_cols: usize) -> Self { let n_rows = nums.len() / n_cols; assert_eq!(n_rows * n_cols, nums.len()); let mut grid = Map::new(); for (i, &x) in nums.iter().enumerate() { let (r, c) = div_mod_floor(i, n_cols); grid.insert(x, (r, c)); } Self { grid, progress: BoardProgress::new(n_rows, n_cols), } } fn play_number(&mut self, n: T) { let (r, c) = match self.grid.remove(&n) { Some(coords) => coords, None => return, }; self.progress.handle_entry(r, c); } fn has_won(&self) -> bool { self.progress.has_won } fn get_ans(&self, winning_num: T) -> T { let unmarked_sum = self.grid.keys().copied().sum::(); winning_num * unmarked_sum } } struct Game { boards: Vec>, numbers: Vec, } impl Game { fn from_str(s: &str) -> Option { let mut lines = s.lines().chain(std::iter::once(\"\")); let nums = lines .next()? .split(',') .map(|s| s.parse::().ok()) .collect::>>()?; let mut boards = vec![]; let mut this_board = vec![]; let mut n_cols = None; for line in lines { if line.is_empty() { if !this_board.is_empty() { let board = Board::new(this_board.as_slice(), n_cols.unwrap()); boards.push(board); this_board.clear(); } } else { for num in line.split_whitespace().map(|s| s.parse::().ok()) { let num = num?; this_board.push(num); } if matches!(n_cols, None) { n_cols = Some(this_board.len()); } } } Some(Self { boards, numbers: nums, }) } } fn ans_for_input(input: &str) -> Answer { let [game1, game2] = [0; 2].map(|_| Game::from_str(input).unwrap()); (4, (pt1(game1), pt2(game2))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mut game: Game) -> i32 { for &num in &game.numbers { for board in &mut game.boards { board.play_number(num); if board.has_won() { return board.get_ans(num); } } } unreachable!(); } // end::pt1[] // tag::pt2[] fn pt2(mut game: Game) -> i32 { let mut ongoing_game_idxs = (0..game.boards.len()).collect::>(); for &num in &game.numbers { for (board_idx, board) in game.boards.iter_mut().enumerate() { let already_won = !ongoing_game_idxs.contains(&board_idx); if already_won { continue; } board.play_number(num); if board.has_won() { if ongoing_game_idxs.len() == 1 { return board.get_ans(num); } ongoing_game_idxs.remove(&board_idx); } } } unreachable!(); } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 4, ans: (4512, 1924)); test_input!(include_str!(\"input.txt\"), day: 4, ans: (87456, 15561)); } } This time, we keep track of all of the boards that haven’t won yet. When the last un-won boards wins, we use it to compute the answer. // tag::setup[] use crate::Answer; use num::{integer::div_mod_floor, Integer}; use std::{ collections::{BTreeMap as Map, BTreeSet as Set}, str::FromStr, }; #[derive(Debug)] struct BoardProgress { rows: Vec, cols: Vec, has_won: bool, } impl BoardProgress { fn new(n_rows: usize, n_cols: usize) -> Self { let rows = vec![n_cols; n_rows]; let cols = vec![n_rows; n_cols]; Self { rows, cols, has_won: false, } } fn handle_entry(&mut self, row: usize, col: usize) { if self.has_won { return; } self.rows[row] -= 1; self.cols[col] -= 1; if self.rows[row] == 0 || self.cols[col] == 0 { self.has_won = true; } } } #[derive(Debug)] struct Board { grid: Map, progress: BoardProgress, } impl Board { fn new(nums: &[T], n_cols: usize) -> Self { let n_rows = nums.len() / n_cols; assert_eq!(n_rows * n_cols, nums.len()); let mut grid = Map::new(); for (i, &x) in nums.iter().enumerate() { let (r, c) = div_mod_floor(i, n_cols); grid.insert(x, (r, c)); } Self { grid, progress: BoardProgress::new(n_rows, n_cols), } } fn play_number(&mut self, n: T) { let (r, c) = match self.grid.remove(&n) { Some(coords) => coords, None => return, }; self.progress.handle_entry(r, c); } fn has_won(&self) -> bool { self.progress.has_won } fn get_ans(&self, winning_num: T) -> T { let unmarked_sum = self.grid.keys().copied().sum::(); winning_num * unmarked_sum } } struct Game { boards: Vec>, numbers: Vec, } impl Game { fn from_str(s: &str) -> Option { let mut lines = s.lines().chain(std::iter::once(\"\")); let nums = lines .next()? .split(',') .map(|s| s.parse::().ok()) .collect::>>()?; let mut boards = vec![]; let mut this_board = vec![]; let mut n_cols = None; for line in lines { if line.is_empty() { if !this_board.is_empty() { let board = Board::new(this_board.as_slice(), n_cols.unwrap()); boards.push(board); this_board.clear(); } } else { for num in line.split_whitespace().map(|s| s.parse::().ok()) { let num = num?; this_board.push(num); } if matches!(n_cols, None) { n_cols = Some(this_board.len()); } } } Some(Self { boards, numbers: nums, }) } } fn ans_for_input(input: &str) -> Answer { let [game1, game2] = [0; 2].map(|_| Game::from_str(input).unwrap()); (4, (pt1(game1), pt2(game2))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mut game: Game) -> i32 { for &num in &game.numbers { for board in &mut game.boards { board.play_number(num); if board.has_won() { return board.get_ans(num); } } } unreachable!(); } // end::pt1[] // tag::pt2[] fn pt2(mut game: Game) -> i32 { let mut ongoing_game_idxs = (0..game.boards.len()).collect::>(); for &num in &game.numbers { for (board_idx, board) in game.boards.iter_mut().enumerate() { let already_won = !ongoing_game_idxs.contains(&board_idx); if already_won { continue; } board.play_number(num); if board.has_won() { if ongoing_game_idxs.len() == 1 { return board.get_ans(num); } ongoing_game_idxs.remove(&board_idx); } } } unreachable!(); } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 4, ans: (4512, 1924)); test_input!(include_str!(\"input.txt\"), day: 4, ans: (87456, 15561)); } }","title":"Day 4: Giant Squid","component":"ROOT","version":"","name":"soln","url":"/src/day_04/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"6":{"id":6,"text":"Day #5 problem description │ Problem input This challenge requires iterating the integer points between two other points on the plane. First, we read the input into a list of lines of the form \\(((x_1, y_1), (x_2, y_2))\\). We also define the helpful range_between(a, b) function, which returns the (nonempty!) range of integers between a and b, inclusive. The range is ascending if and only if a b.) // tag::setup[] use crate::Answer; use num::Integer; use regex::Regex; use std::{collections::BTreeMap as Map, str::FromStr}; #[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] struct Point(T, T); struct EndpointPair(Point, Point); type PointCounter = Map, usize>; fn get_lines(input: &str) -> Option>> { let line_re = Regex::new(r\"(\\d+),(\\d+)\\s*->\\s*(\\d+),(\\d+)\").ok()?; input .lines() .map(|line| { let caps = line_re.captures(line)?; let [x1, y1, x2, y2] = [1, 2, 3, 4].map(|i| caps.get(i)?.as_str().parse::().ok()); Some(EndpointPair(Point(x1?, y1?), Point(x2?, y2?))) }) .collect::>>() } fn range_between(a: i32, b: i32) -> num::iter::RangeStepInclusive { let step = if a (counter: &PointCounter) -> usize { counter .values() .map(|count| if *count >= 2 { 1 } else { 0 }) .sum() } fn ans_for_input(input: &str) -> Answer { let endpoints = get_lines(input).unwrap(); (5, (pt1(&endpoints), pt2(&endpoints))).into() } pub fn ans() -> Answer { let input = include_str!(\"input.txt\"); ans_for_input(input) } // end::setup[] // tag::pt1[] fn get_hv_point_counts(endpoints: &[EndpointPair]) -> PointCounter { let mut counter = Map::new(); for &EndpointPair(Point(x1, y1), Point(x2, y2)) in endpoints { if x1 != x2 && y1 != y2 { continue; } for x in range_between(x1, x2) { for y in range_between(y1, y2) { *counter.entry(Point(x, y)).or_default() += 1; } } } counter } fn pt1(endpoints: &[EndpointPair]) -> usize { get_ans(&get_hv_point_counts(endpoints)) } // end::pt1[] // tag::pt2[] fn get_diag_point_counts(endpoints: &[EndpointPair]) -> PointCounter { let mut counter = Map::new(); for &EndpointPair(Point(x1, y1), Point(x2, y2)) in endpoints { if (x1 - x2).abs() != (y1 - y2).abs() { continue; } for (x, y) in range_between(x1, x2).zip(range_between(y1, y2)) { *counter.entry(Point(x, y)).or_default() += 1; } } counter } fn pt2(endpoints: &[EndpointPair]) -> usize { let hv_counter = get_hv_point_counts(endpoints); let all_counter = { let mut diag_counter = get_diag_point_counts(endpoints); for (k, v) in hv_counter { *diag_counter.entry(k).or_default() += v; } diag_counter }; get_ans(&all_counter) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 5, ans: (5, 12)); test_input!(include_str!(\"input.txt\"), day: 5, ans: (5576, 18144)); } } Part 1 asks us to count how many times each point belongs to some horizontal or vertical line. These are lines \\(((x_1, y_1), (x_2, y_2))\\) for which \\(x_1 = x_2\\) or \\(y_1 = y_2\\). Such a line’s points are the Cartesian “product” of the ranges range_between(x1, x2) and range_between(y1, y2) (“product” in quotes because one of those ranges has length 1, so it’s not much of a product). // tag::setup[] use crate::Answer; use num::Integer; use regex::Regex; use std::{collections::BTreeMap as Map, str::FromStr}; #[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] struct Point(T, T); struct EndpointPair(Point, Point); type PointCounter = Map, usize>; fn get_lines(input: &str) -> Option>> { let line_re = Regex::new(r\"(\\d+),(\\d+)\\s*->\\s*(\\d+),(\\d+)\").ok()?; input .lines() .map(|line| { let caps = line_re.captures(line)?; let [x1, y1, x2, y2] = [1, 2, 3, 4].map(|i| caps.get(i)?.as_str().parse::().ok()); Some(EndpointPair(Point(x1?, y1?), Point(x2?, y2?))) }) .collect::>>() } fn range_between(a: i32, b: i32) -> num::iter::RangeStepInclusive { let step = if a (counter: &PointCounter) -> usize { counter .values() .map(|count| if *count >= 2 { 1 } else { 0 }) .sum() } fn ans_for_input(input: &str) -> Answer { let endpoints = get_lines(input).unwrap(); (5, (pt1(&endpoints), pt2(&endpoints))).into() } pub fn ans() -> Answer { let input = include_str!(\"input.txt\"); ans_for_input(input) } // end::setup[] // tag::pt1[] fn get_hv_point_counts(endpoints: &[EndpointPair]) -> PointCounter { let mut counter = Map::new(); for &EndpointPair(Point(x1, y1), Point(x2, y2)) in endpoints { if x1 != x2 && y1 != y2 { continue; } for x in range_between(x1, x2) { for y in range_between(y1, y2) { *counter.entry(Point(x, y)).or_default() += 1; } } } counter } fn pt1(endpoints: &[EndpointPair]) -> usize { get_ans(&get_hv_point_counts(endpoints)) } // end::pt1[] // tag::pt2[] fn get_diag_point_counts(endpoints: &[EndpointPair]) -> PointCounter { let mut counter = Map::new(); for &EndpointPair(Point(x1, y1), Point(x2, y2)) in endpoints { if (x1 - x2).abs() != (y1 - y2).abs() { continue; } for (x, y) in range_between(x1, x2).zip(range_between(y1, y2)) { *counter.entry(Point(x, y)).or_default() += 1; } } counter } fn pt2(endpoints: &[EndpointPair]) -> usize { let hv_counter = get_hv_point_counts(endpoints); let all_counter = { let mut diag_counter = get_diag_point_counts(endpoints); for (k, v) in hv_counter { *diag_counter.entry(k).or_default() += v; } diag_counter }; get_ans(&all_counter) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 5, ans: (5, 12)); test_input!(include_str!(\"input.txt\"), day: 5, ans: (5576, 18144)); } } Part 2 asks us to count how many times each point belongs to either a horizontal line, a vertical line, or a \\(45^\\circ\\) diagonal line (whose slope must be \\(\\pm1\\)). We already found the points on horizontal and vertical lines in Part 1. Diagonal lines are lines \\(((x_1, y_1), (x_2, y_2))\\) whose points \\( (x_k,y_k)\\) satisfy \\(|x_k-x_1|=|y_k-y_1|\\) with \\(x_k\\) between \\(x_1\\) and \\(x_2\\) and \\(y_k\\) between \\(y_k\\) and \\(y_2\\) (inclusive). Since the \\(k\\)th element of range_between(a, b) is \\(k\\) away from \\(a\\), the points of the diagonal line in question are in fact simply the elements of range_between(x1, x2).zip(range_between(y1, y2)). // tag::setup[] use crate::Answer; use num::Integer; use regex::Regex; use std::{collections::BTreeMap as Map, str::FromStr}; #[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] struct Point(T, T); struct EndpointPair(Point, Point); type PointCounter = Map, usize>; fn get_lines(input: &str) -> Option>> { let line_re = Regex::new(r\"(\\d+),(\\d+)\\s*->\\s*(\\d+),(\\d+)\").ok()?; input .lines() .map(|line| { let caps = line_re.captures(line)?; let [x1, y1, x2, y2] = [1, 2, 3, 4].map(|i| caps.get(i)?.as_str().parse::().ok()); Some(EndpointPair(Point(x1?, y1?), Point(x2?, y2?))) }) .collect::>>() } fn range_between(a: i32, b: i32) -> num::iter::RangeStepInclusive { let step = if a (counter: &PointCounter) -> usize { counter .values() .map(|count| if *count >= 2 { 1 } else { 0 }) .sum() } fn ans_for_input(input: &str) -> Answer { let endpoints = get_lines(input).unwrap(); (5, (pt1(&endpoints), pt2(&endpoints))).into() } pub fn ans() -> Answer { let input = include_str!(\"input.txt\"); ans_for_input(input) } // end::setup[] // tag::pt1[] fn get_hv_point_counts(endpoints: &[EndpointPair]) -> PointCounter { let mut counter = Map::new(); for &EndpointPair(Point(x1, y1), Point(x2, y2)) in endpoints { if x1 != x2 && y1 != y2 { continue; } for x in range_between(x1, x2) { for y in range_between(y1, y2) { *counter.entry(Point(x, y)).or_default() += 1; } } } counter } fn pt1(endpoints: &[EndpointPair]) -> usize { get_ans(&get_hv_point_counts(endpoints)) } // end::pt1[] // tag::pt2[] fn get_diag_point_counts(endpoints: &[EndpointPair]) -> PointCounter { let mut counter = Map::new(); for &EndpointPair(Point(x1, y1), Point(x2, y2)) in endpoints { if (x1 - x2).abs() != (y1 - y2).abs() { continue; } for (x, y) in range_between(x1, x2).zip(range_between(y1, y2)) { *counter.entry(Point(x, y)).or_default() += 1; } } counter } fn pt2(endpoints: &[EndpointPair]) -> usize { let hv_counter = get_hv_point_counts(endpoints); let all_counter = { let mut diag_counter = get_diag_point_counts(endpoints); for (k, v) in hv_counter { *diag_counter.entry(k).or_default() += v; } diag_counter }; get_ans(&all_counter) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 5, ans: (5, 12)); test_input!(include_str!(\"input.txt\"), day: 5, ans: (5576, 18144)); } }","title":"Day 5: Hydrothermal Venture","component":"ROOT","version":"","name":"soln","url":"/src/day_05/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"7":{"id":7,"text":"Day #6 problem description │ Problem input At a high level, this problem requires modifying a map from ints to ints in a controlled fashion. At a low level: This map’s keys are actually the integers from 0 to 8 (inclusive), so it can just be stored in an array. The “controlled fashion” is merely shifting most values over. In one case we have to also add to said values. // tag::setup[] use crate::Answer; const N_TIMERS: usize = 9; type Timers = [usize; N_TIMERS]; fn read_input(input: &str) -> Option { let mut timers = [0; N_TIMERS]; let nums = input .trim() .split(',') .map(|s| s.parse().ok()) .collect::>>()?; for num in nums { timers[num] += 1; } Some(timers) } fn tick_in_place(timers: &mut Timers) { let initial = timers[0]; for i in 0..(N_TIMERS - 1) { timers[i] = timers[i + 1]; } timers[8] = initial; timers[6] += initial; } // [usize; 9] implements Copy fn tick(n_times: usize, timers: &Timers) -> Timers { let mut timers = *timers; for _ in 0..n_times { tick_in_place(&mut timers); } timers } fn ans_for_input(input: &str) -> Answer { let timers = read_input(input).unwrap(); (6, (pt1(&timers), pt2(&timers))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"sample_input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(timers: &Timers) -> usize { tick(80, timers).iter().sum() } // end::pt1[] // tag::pt2[] fn pt2(timers: &Timers) -> usize { tick(256, timers).iter().sum() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 6, ans: (5934, 26_984_457_539)); test_input!(include_str!(\"input.txt\"), day: 6, ans: (372_984, 1_681_503_251_694)); } } // tag::setup[] use crate::Answer; const N_TIMERS: usize = 9; type Timers = [usize; N_TIMERS]; fn read_input(input: &str) -> Option { let mut timers = [0; N_TIMERS]; let nums = input .trim() .split(',') .map(|s| s.parse().ok()) .collect::>>()?; for num in nums { timers[num] += 1; } Some(timers) } fn tick_in_place(timers: &mut Timers) { let initial = timers[0]; for i in 0..(N_TIMERS - 1) { timers[i] = timers[i + 1]; } timers[8] = initial; timers[6] += initial; } // [usize; 9] implements Copy fn tick(n_times: usize, timers: &Timers) -> Timers { let mut timers = *timers; for _ in 0..n_times { tick_in_place(&mut timers); } timers } fn ans_for_input(input: &str) -> Answer { let timers = read_input(input).unwrap(); (6, (pt1(&timers), pt2(&timers))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"sample_input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(timers: &Timers) -> usize { tick(80, timers).iter().sum() } // end::pt1[] // tag::pt2[] fn pt2(timers: &Timers) -> usize { tick(256, timers).iter().sum() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 6, ans: (5934, 26_984_457_539)); test_input!(include_str!(\"input.txt\"), day: 6, ans: (372_984, 1_681_503_251_694)); } }","title":"Day 6: Lanternfish","component":"ROOT","version":"","name":"soln","url":"/src/day_06/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Parts 1 and 2","hash":"_parts_1_and_2","id":2}]},"8":{"id":8,"text":"Day #7 problem description │ Problem input This problem asks us, in effect, to find the number that minimizes the sum of particular measures of error. (Since the number of points is fixed, we will use “sum” and “mean” of the errors interchangeably, as they merely differ by a constant factor, the number of points.) A naive solution would iterate through all possibilities, but knowledge of statistics offers us a shortcut. In both parts, we aim to minimize an \\(l_p\\)-norm. Reading in the input: // tag::setup[] use crate::{utils::abs_diff, Answer}; fn read_input(s: &str) -> Option> { s.trim() .split(',') .map(|n| n.parse().ok()) .collect::>>() } fn ans_for_input(input: &str) -> Answer { let nums = read_input(input).unwrap(); (7, (pt1(&nums), pt2(&nums))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(nums: V) -> usize { let mut nums = nums.as_ref().to_vec(); nums.sort_unstable(); let datum_below = nums[nums.len() / 2]; let datum_above = nums[1 + (nums.len() - 1) / 2]; let median = (datum_below + datum_above) / 2; nums.iter().map(|&n| abs_diff(n, median)).sum() } // end::pt1[] // tag::pt2[] fn pt2>(nums: V) -> usize { fn cost(mean: usize, nums: &[usize]) -> usize { nums.iter() .map(|&n| { let diff = abs_diff(n, mean); diff * (diff + 1) / 2 }) .sum() } let nums = nums.as_ref(); let sum = nums.iter().sum::(); let len = nums.len(); let mean_rounded_down = sum / len; if sum % len == 0 { cost(mean_rounded_down, nums) } else { let mean_rounded_up = (sum - 1) / len + 1; cost(mean_rounded_down, nums).min(cost(mean_rounded_up, nums)) } } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 7, ans: (328_187, 91_257_582)); } } Part 1 asks us, in effect, to find the number \\(x\\) that minimizes the mean absolute deviation, or the \\(l_1\\)-norm of the error. The number that does this is simply the median of the dataset. (In this problem, the median may be a half-integer, but the solution has to be an integer, so we can just round the median down.) Proof: If you are not at the median and move towards it, you are moving toward at least as many data points as you are moving away from, which at best decreases the mean absolute deviation and at worst leaves it unchanged. // tag::setup[] use crate::{utils::abs_diff, Answer}; fn read_input(s: &str) -> Option> { s.trim() .split(',') .map(|n| n.parse().ok()) .collect::>>() } fn ans_for_input(input: &str) -> Answer { let nums = read_input(input).unwrap(); (7, (pt1(&nums), pt2(&nums))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(nums: V) -> usize { let mut nums = nums.as_ref().to_vec(); nums.sort_unstable(); let datum_below = nums[nums.len() / 2]; let datum_above = nums[1 + (nums.len() - 1) / 2]; let median = (datum_below + datum_above) / 2; nums.iter().map(|&n| abs_diff(n, median)).sum() } // end::pt1[] // tag::pt2[] fn pt2>(nums: V) -> usize { fn cost(mean: usize, nums: &[usize]) -> usize { nums.iter() .map(|&n| { let diff = abs_diff(n, mean); diff * (diff + 1) / 2 }) .sum() } let nums = nums.as_ref(); let sum = nums.iter().sum::(); let len = nums.len(); let mean_rounded_down = sum / len; if sum % len == 0 { cost(mean_rounded_down, nums) } else { let mean_rounded_up = (sum - 1) / len + 1; cost(mean_rounded_down, nums).min(cost(mean_rounded_up, nums)) } } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 7, ans: (328_187, 91_257_582)); } } In Part 2, the cost associated with a distance of \\(n\\) is \\(\\sum_{k=1}^n k = \\frac{n(n+1)}{2}\\). Since \\(n\\) is an integer, \\(n^2\\ge n\\), and so \\(n^2+n\\) is “not relatively penalized more than” \\(n^2\\) would be, which means the mean of the \\(\\frac{n(n+1)}{2}\\) will be minimized whenever the mean of \\(n^2\\) is minimized. (It would be a problem if \\(n\\) exceeded \\(n^2\\), as then it might dominate in the sum and we’d no longer be looking to minimize the mean of the \\(n^2\\).) This is the mean squared error (MSE, or \\(l_2\\)-norm of the error), and it is a well-known fact of statistics that the MSE is minimized by the arithmetic mean of the data. The only catch is that the arithmetic mean need not be an integer, but the solution to the problem must be. Naturally we simply try the two integers on either side of the arithmetic mean (which will both be the arithmetic mean itself if it’s an integer) and pick whichever of the two leads to a smaller error. This works because the error is concave up, i.e., a local minimum is the global minimum. // tag::setup[] use crate::{utils::abs_diff, Answer}; fn read_input(s: &str) -> Option> { s.trim() .split(',') .map(|n| n.parse().ok()) .collect::>>() } fn ans_for_input(input: &str) -> Answer { let nums = read_input(input).unwrap(); (7, (pt1(&nums), pt2(&nums))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(nums: V) -> usize { let mut nums = nums.as_ref().to_vec(); nums.sort_unstable(); let datum_below = nums[nums.len() / 2]; let datum_above = nums[1 + (nums.len() - 1) / 2]; let median = (datum_below + datum_above) / 2; nums.iter().map(|&n| abs_diff(n, median)).sum() } // end::pt1[] // tag::pt2[] fn pt2>(nums: V) -> usize { fn cost(mean: usize, nums: &[usize]) -> usize { nums.iter() .map(|&n| { let diff = abs_diff(n, mean); diff * (diff + 1) / 2 }) .sum() } let nums = nums.as_ref(); let sum = nums.iter().sum::(); let len = nums.len(); let mean_rounded_down = sum / len; if sum % len == 0 { cost(mean_rounded_down, nums) } else { let mean_rounded_up = (sum - 1) / len + 1; cost(mean_rounded_down, nums).min(cost(mean_rounded_up, nums)) } } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 7, ans: (328_187, 91_257_582)); } }","title":"Day 7: The Treachery of Whales","component":"ROOT","version":"","name":"soln","url":"/src/day_07/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"9":{"id":9,"text":"Day #8 problem description │ Problem input What an interesting problem! We are asked to deduce the manner in which a computer has been incorrectly hooked up to a seven-segment display (7SD): We will use the following display schematic, with the segments labeled A–G: 0: 1: 2: 3: 4: AAAA AAAA AAAA B C C C C B C B C C C C B C DDDD DDDD DDDD E F F E F F E F F E F F GGGG GGGG GGGG 5: 6: 7: 8: 9: AAAA AAAA AAAA AAAA AAAA B B C B C B C B B C B C B C DDDD DDDD DDDD DDDD F E F F E F F F E F F E F F GGGG GGGG GGGG GGGG The computer sends a stream of digits that we see as various patterns of lit segments on the 7SD. The computer has the correct logic to display digits, but its wires to the 7SD got crossed during setup, so the digits it attempts to display end up looking like gibberish to us. But because the computer’s underlying logic still holds, we can still deduce things from its output. For instance, if it lights up only two segments, we know that it is trying to display a 1 (because 1 is the only digit made of exactly two segments), and so the two segments it lit up should be rewired to the two segments CF (although we still don’t know in which order). If it lights up five segments, then it could be trying to display either a 2 (ACDEG), 3 (ACDFG), or 5 (ABDFG). By observing the patterns it lights up, and using our knowledge of how the digits 0–9 should have been displayed, we can deduce the full wiring scheme and how the computer must be rewired to the display in order to function correctly. The only other wrinkle is we don’t even get to tell the computer which digits to attempt to display; that is entirely up to it. We simply receive a stream of some digits, and from that must deduce the wiring scheme. The Solution The strategy is as follows: for each garbled digit we see, record its pattern and the list of candidate digits (those having the same number of segments turned on). Then, by taking set differences and intersections between the patterns seen and their candidates, we can derive more specific information about the rewiring. For instance: Suppose the computer sends two digits and lights up ABD and AB. ABD only has one candidate, 7 (ACF), because only 7 has three segments turned on. AB only has one candidate, 1 (CF), because only 1 has two segments turned on. Then we take the difference of the displayed segments — ABD − AB = D — and all pairwise differences between their corresponding candidates (just one in this case) — ACF − CF = A — to deduce that D must be rewired to A. We continue this logic, subtracting (say) the map D ➜ A from other display-candidate pairs to narrow them down. We are done when we know the one segment that each segment needs to be rewired to. Suppose the computer sends ABCDE; its candidates would be 2 (ACDEG), 3 (ACDFG), and 5 (ABDFG). If it then sends DEF, its candidates would be just 7 (ACF). The intersection of the two sent digits is DE. Taking the pairwise intersections between the candidates, and keeping only those with the same length as DE, we see that the candidates for DE are AC and AF. Subtracting D ➜ A from this, we deduce that E must be mapped to either C or F. Subtracting D ➜ A and E ➜ C|F from DEF ➜ ACF, we see that F ➜ C|F as well. Continuing this way, we can eventually deduce all the mappings. First, we model the notion of a digit. // tag::setup[] use crate::Answer; use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set}; const N_SEGMENTS: usize = 7; // end::setup[] // tag::digit[] #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)] struct Digit { segments: [bool; N_SEGMENTS], n_on: usize, } impl Digit { fn new(segments: [bool; N_SEGMENTS]) -> Self { Self { segments, n_on: segments.iter().filter(|&&b| b).count(), } } fn from_str(s: &str) -> Self { let mut segments = [false; N_SEGMENTS]; for c in s.bytes() { let i = c - b'a'; segments[usize::from(i)] = true; } Self::new(segments) } fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -> bool) -> Self { Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y))) } } impl std::ops::BitOr for Digit { type Output = Self; fn bitor(self, rhs: Self) -> Self::Output { self._bin_op(rhs, |x, y| x | y) } } impl std::ops::BitAnd for Digit { type Output = Self; fn bitand(self, rhs: Self) -> Self::Output { self._bin_op(rhs, |x, y| x & y) } } impl std::ops::Not for Digit { type Output = Self; fn not(self) -> Self::Output { Self::new(self.segments.map(|b| !b)) } } impl From for Digit { fn from(n: usize) -> Self { let segments = match n { /* -----[A, B, C, D, E, F, G] */ 0 => [1, 1, 1, 0, 1, 1, 1], 1 => [0, 0, 1, 0, 0, 1, 0], 2 => [1, 0, 1, 1, 1, 0, 1], 3 => [1, 0, 1, 1, 0, 1, 1], 4 => [0, 1, 1, 1, 0, 1, 0], 5 => [1, 1, 0, 1, 0, 1, 1], 6 => [1, 1, 0, 1, 1, 1, 1], 7 => [1, 0, 1, 0, 0, 1, 0], 8 => [1, 1, 1, 1, 1, 1, 1], 9 => [1, 1, 1, 1, 0, 1, 1], _ => panic!(\"Cannot make digit for n={}\", n), }; let segments = segments.map(|i| i != 0); Self::new(segments) } } impl From for usize { fn from(digit: Digit) -> Self { let segments = digit.segments.map(u8::from); match segments { /* [A, B, C, D, E, F, G] */ [1, 1, 1, 0, 1, 1, 1] => 0, [0, 0, 1, 0, 0, 1, 0] => 1, [1, 0, 1, 1, 1, 0, 1] => 2, [1, 0, 1, 1, 0, 1, 1] => 3, [0, 1, 1, 1, 0, 1, 0] => 4, [1, 1, 0, 1, 0, 1, 1] => 5, [1, 1, 0, 1, 1, 1, 1] => 6, [1, 0, 1, 0, 0, 1, 0] => 7, [1, 1, 1, 1, 1, 1, 1] => 8, [1, 1, 1, 1, 0, 1, 1] => 9, _ => panic!(\"Digit {:?} is not valid\", digit), } } } // end::digit[] // tag::setup[] fn get_mapping_from_garbled_digits>( garbled_digits: impl Iterator, ) -> Result, Map>> { let mut mappings = Map::new(); { let mut grouped_by_n_on = Map::new(); for n in 0..=9 { let digit = Digit::from(n); grouped_by_n_on .entry(digit.n_on) .or_insert_with(Set::new) .insert(digit); } for gd in garbled_digits { let gd = *gd.borrow(); let digits_w_same_n_segments = &grouped_by_n_on[&gd.n_on]; mappings.insert(gd, digits_w_same_n_segments.clone()); } } let identity: &dyn Fn(Digit) -> _ = &(|x| x); let bitwise_not: &dyn Fn(Digit) -> _ = &(|x| !x); loop { let mut new_mappings = Map::new(); for (i, (&garbled1, choices1)) in mappings.iter().enumerate() { for (&garbled2, choices2) in mappings.iter().skip(i + 1) { for (op1, op2) in [ (identity, identity), (identity, bitwise_not), (bitwise_not, identity), ] { let new_garbled = op1(garbled1) & op2(garbled2); if new_garbled.n_on == 0 { continue; } let mut new_good_candidates = Set::new(); for &good_digit1 in choices1 { for &good_digit2 in choices2 { let candidate = op1(good_digit1) & op2(good_digit2); if candidate.n_on == new_garbled.n_on { new_good_candidates.insert(candidate); } } } match new_mappings.entry(new_garbled) { MapEntry::Vacant(v) => { v.insert(new_good_candidates); } MapEntry::Occupied(mut o) => { o.insert(o.get() & &new_good_candidates); } } } } } // Remove all keys that can be written as the disjoint-bitwise-or of two other // keys, as they're redundant. This means if e.g., A and BC are present, then // remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB // and BC are not disjoint) let mut redundant_keys = Set::new(); let new_garbled_keys = new_mappings.keys().copied().collect::>(); for (i, &garbled1) in new_garbled_keys.iter().enumerate() { for &garbled2 in new_garbled_keys.iter().skip(i + 1) { if (garbled1 & garbled2).n_on != 0 { continue; } let segment_union = garbled1 | garbled2; if new_garbled_keys.contains(&segment_union) { redundant_keys.insert(segment_union); } } } for k in &redundant_keys { new_mappings.remove(k); } if mappings.len() == N_SEGMENTS && mappings.values().all(|m| m.len() == 1) { return Ok(mappings .into_iter() .map(|(k, v)| (k, v.iter().next().copied().unwrap())) .collect()); } else if mappings == new_mappings { return Err(mappings); } mappings = new_mappings; } } fn apply_mapping_to_garbled_digit(mapping: &Map, garbled_digit: Digit) -> usize { let mut result = Digit::new([false; 7]); for (&k, &v) in mapping { if (garbled_digit & k).n_on > 0 { result = result | v; } } result.into() } fn read_input(input: &str) -> Vec, Vec)> { fn whitespace_sepd_strs_to_digits(strs: &str) -> Vec { strs.trim() .split_ascii_whitespace() .map(Digit::from_str) .collect() } input .lines() .filter_map(|line| { let line = line.trim(); if line.is_empty() { return None; } let mut in_out = line.split('|'); let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?); let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?); Some((in_digits, out_digits)) }) .collect() } fn translate_line_to_digits>( idod: (impl Iterator, impl Iterator), ) -> Option> { let (in_digits, out_digits) = idod; let mapping = get_mapping_from_garbled_digits(in_digits).ok()?; Some( out_digits .map(|d| apply_mapping_to_garbled_digit(&mapping, *d.borrow())) .collect(), ) } fn ans_for_input(input: &str) -> Answer { let in_out_lines = read_input(input); let output_digits = in_out_lines .iter() .map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter()))) .collect::>>() .unwrap(); (8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(out_digits: impl Iterator) -> usize { out_digits .map(|v| { v.as_ref() .iter() .filter(|&n| [1, 4, 7, 8].contains(n)) .count() }) .sum() } // end::pt1[] // tag::pt2[] fn pt2>(out_digits: impl Iterator) -> usize { out_digits .map(|v| { v.as_ref() .iter() .rev() .enumerate() .map(|(pow10, &val)| val * 10_usize.pow(u32::try_from(pow10).unwrap())) .sum::() }) .sum() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 8, ans: (237, 1_009_098)); } } The Algorithm We repeatedly take the intersection and set-differences between digits, getting a more and more refined mapping until finally we are left with a 1:1 mapping. // tag::setup[] use crate::Answer; use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set}; const N_SEGMENTS: usize = 7; // end::setup[] // tag::digit[] #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)] struct Digit { segments: [bool; N_SEGMENTS], n_on: usize, } impl Digit { fn new(segments: [bool; N_SEGMENTS]) -> Self { Self { segments, n_on: segments.iter().filter(|&&b| b).count(), } } fn from_str(s: &str) -> Self { let mut segments = [false; N_SEGMENTS]; for c in s.bytes() { let i = c - b'a'; segments[usize::from(i)] = true; } Self::new(segments) } fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -> bool) -> Self { Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y))) } } impl std::ops::BitOr for Digit { type Output = Self; fn bitor(self, rhs: Self) -> Self::Output { self._bin_op(rhs, |x, y| x | y) } } impl std::ops::BitAnd for Digit { type Output = Self; fn bitand(self, rhs: Self) -> Self::Output { self._bin_op(rhs, |x, y| x & y) } } impl std::ops::Not for Digit { type Output = Self; fn not(self) -> Self::Output { Self::new(self.segments.map(|b| !b)) } } impl From for Digit { fn from(n: usize) -> Self { let segments = match n { /* -----[A, B, C, D, E, F, G] */ 0 => [1, 1, 1, 0, 1, 1, 1], 1 => [0, 0, 1, 0, 0, 1, 0], 2 => [1, 0, 1, 1, 1, 0, 1], 3 => [1, 0, 1, 1, 0, 1, 1], 4 => [0, 1, 1, 1, 0, 1, 0], 5 => [1, 1, 0, 1, 0, 1, 1], 6 => [1, 1, 0, 1, 1, 1, 1], 7 => [1, 0, 1, 0, 0, 1, 0], 8 => [1, 1, 1, 1, 1, 1, 1], 9 => [1, 1, 1, 1, 0, 1, 1], _ => panic!(\"Cannot make digit for n={}\", n), }; let segments = segments.map(|i| i != 0); Self::new(segments) } } impl From for usize { fn from(digit: Digit) -> Self { let segments = digit.segments.map(u8::from); match segments { /* [A, B, C, D, E, F, G] */ [1, 1, 1, 0, 1, 1, 1] => 0, [0, 0, 1, 0, 0, 1, 0] => 1, [1, 0, 1, 1, 1, 0, 1] => 2, [1, 0, 1, 1, 0, 1, 1] => 3, [0, 1, 1, 1, 0, 1, 0] => 4, [1, 1, 0, 1, 0, 1, 1] => 5, [1, 1, 0, 1, 1, 1, 1] => 6, [1, 0, 1, 0, 0, 1, 0] => 7, [1, 1, 1, 1, 1, 1, 1] => 8, [1, 1, 1, 1, 0, 1, 1] => 9, _ => panic!(\"Digit {:?} is not valid\", digit), } } } // end::digit[] // tag::setup[] fn get_mapping_from_garbled_digits>( garbled_digits: impl Iterator, ) -> Result, Map>> { let mut mappings = Map::new(); { let mut grouped_by_n_on = Map::new(); for n in 0..=9 { let digit = Digit::from(n); grouped_by_n_on .entry(digit.n_on) .or_insert_with(Set::new) .insert(digit); } for gd in garbled_digits { let gd = *gd.borrow(); let digits_w_same_n_segments = &grouped_by_n_on[&gd.n_on]; mappings.insert(gd, digits_w_same_n_segments.clone()); } } let identity: &dyn Fn(Digit) -> _ = &(|x| x); let bitwise_not: &dyn Fn(Digit) -> _ = &(|x| !x); loop { let mut new_mappings = Map::new(); for (i, (&garbled1, choices1)) in mappings.iter().enumerate() { for (&garbled2, choices2) in mappings.iter().skip(i + 1) { for (op1, op2) in [ (identity, identity), (identity, bitwise_not), (bitwise_not, identity), ] { let new_garbled = op1(garbled1) & op2(garbled2); if new_garbled.n_on == 0 { continue; } let mut new_good_candidates = Set::new(); for &good_digit1 in choices1 { for &good_digit2 in choices2 { let candidate = op1(good_digit1) & op2(good_digit2); if candidate.n_on == new_garbled.n_on { new_good_candidates.insert(candidate); } } } match new_mappings.entry(new_garbled) { MapEntry::Vacant(v) => { v.insert(new_good_candidates); } MapEntry::Occupied(mut o) => { o.insert(o.get() & &new_good_candidates); } } } } } // Remove all keys that can be written as the disjoint-bitwise-or of two other // keys, as they're redundant. This means if e.g., A and BC are present, then // remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB // and BC are not disjoint) let mut redundant_keys = Set::new(); let new_garbled_keys = new_mappings.keys().copied().collect::>(); for (i, &garbled1) in new_garbled_keys.iter().enumerate() { for &garbled2 in new_garbled_keys.iter().skip(i + 1) { if (garbled1 & garbled2).n_on != 0 { continue; } let segment_union = garbled1 | garbled2; if new_garbled_keys.contains(&segment_union) { redundant_keys.insert(segment_union); } } } for k in &redundant_keys { new_mappings.remove(k); } if mappings.len() == N_SEGMENTS && mappings.values().all(|m| m.len() == 1) { return Ok(mappings .into_iter() .map(|(k, v)| (k, v.iter().next().copied().unwrap())) .collect()); } else if mappings == new_mappings { return Err(mappings); } mappings = new_mappings; } } fn apply_mapping_to_garbled_digit(mapping: &Map, garbled_digit: Digit) -> usize { let mut result = Digit::new([false; 7]); for (&k, &v) in mapping { if (garbled_digit & k).n_on > 0 { result = result | v; } } result.into() } fn read_input(input: &str) -> Vec, Vec)> { fn whitespace_sepd_strs_to_digits(strs: &str) -> Vec { strs.trim() .split_ascii_whitespace() .map(Digit::from_str) .collect() } input .lines() .filter_map(|line| { let line = line.trim(); if line.is_empty() { return None; } let mut in_out = line.split('|'); let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?); let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?); Some((in_digits, out_digits)) }) .collect() } fn translate_line_to_digits>( idod: (impl Iterator, impl Iterator), ) -> Option> { let (in_digits, out_digits) = idod; let mapping = get_mapping_from_garbled_digits(in_digits).ok()?; Some( out_digits .map(|d| apply_mapping_to_garbled_digit(&mapping, *d.borrow())) .collect(), ) } fn ans_for_input(input: &str) -> Answer { let in_out_lines = read_input(input); let output_digits = in_out_lines .iter() .map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter()))) .collect::>>() .unwrap(); (8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(out_digits: impl Iterator) -> usize { out_digits .map(|v| { v.as_ref() .iter() .filter(|&n| [1, 4, 7, 8].contains(n)) .count() }) .sum() } // end::pt1[] // tag::pt2[] fn pt2>(out_digits: impl Iterator) -> usize { out_digits .map(|v| { v.as_ref() .iter() .rev() .enumerate() .map(|(pow10, &val)| val * 10_usize.pow(u32::try_from(pow10).unwrap())) .sum::() }) .sum() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 8, ans: (237, 1_009_098)); } } // tag::setup[] use crate::Answer; use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set}; const N_SEGMENTS: usize = 7; // end::setup[] // tag::digit[] #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)] struct Digit { segments: [bool; N_SEGMENTS], n_on: usize, } impl Digit { fn new(segments: [bool; N_SEGMENTS]) -> Self { Self { segments, n_on: segments.iter().filter(|&&b| b).count(), } } fn from_str(s: &str) -> Self { let mut segments = [false; N_SEGMENTS]; for c in s.bytes() { let i = c - b'a'; segments[usize::from(i)] = true; } Self::new(segments) } fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -> bool) -> Self { Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y))) } } impl std::ops::BitOr for Digit { type Output = Self; fn bitor(self, rhs: Self) -> Self::Output { self._bin_op(rhs, |x, y| x | y) } } impl std::ops::BitAnd for Digit { type Output = Self; fn bitand(self, rhs: Self) -> Self::Output { self._bin_op(rhs, |x, y| x & y) } } impl std::ops::Not for Digit { type Output = Self; fn not(self) -> Self::Output { Self::new(self.segments.map(|b| !b)) } } impl From for Digit { fn from(n: usize) -> Self { let segments = match n { /* -----[A, B, C, D, E, F, G] */ 0 => [1, 1, 1, 0, 1, 1, 1], 1 => [0, 0, 1, 0, 0, 1, 0], 2 => [1, 0, 1, 1, 1, 0, 1], 3 => [1, 0, 1, 1, 0, 1, 1], 4 => [0, 1, 1, 1, 0, 1, 0], 5 => [1, 1, 0, 1, 0, 1, 1], 6 => [1, 1, 0, 1, 1, 1, 1], 7 => [1, 0, 1, 0, 0, 1, 0], 8 => [1, 1, 1, 1, 1, 1, 1], 9 => [1, 1, 1, 1, 0, 1, 1], _ => panic!(\"Cannot make digit for n={}\", n), }; let segments = segments.map(|i| i != 0); Self::new(segments) } } impl From for usize { fn from(digit: Digit) -> Self { let segments = digit.segments.map(u8::from); match segments { /* [A, B, C, D, E, F, G] */ [1, 1, 1, 0, 1, 1, 1] => 0, [0, 0, 1, 0, 0, 1, 0] => 1, [1, 0, 1, 1, 1, 0, 1] => 2, [1, 0, 1, 1, 0, 1, 1] => 3, [0, 1, 1, 1, 0, 1, 0] => 4, [1, 1, 0, 1, 0, 1, 1] => 5, [1, 1, 0, 1, 1, 1, 1] => 6, [1, 0, 1, 0, 0, 1, 0] => 7, [1, 1, 1, 1, 1, 1, 1] => 8, [1, 1, 1, 1, 0, 1, 1] => 9, _ => panic!(\"Digit {:?} is not valid\", digit), } } } // end::digit[] // tag::setup[] fn get_mapping_from_garbled_digits>( garbled_digits: impl Iterator, ) -> Result, Map>> { let mut mappings = Map::new(); { let mut grouped_by_n_on = Map::new(); for n in 0..=9 { let digit = Digit::from(n); grouped_by_n_on .entry(digit.n_on) .or_insert_with(Set::new) .insert(digit); } for gd in garbled_digits { let gd = *gd.borrow(); let digits_w_same_n_segments = &grouped_by_n_on[&gd.n_on]; mappings.insert(gd, digits_w_same_n_segments.clone()); } } let identity: &dyn Fn(Digit) -> _ = &(|x| x); let bitwise_not: &dyn Fn(Digit) -> _ = &(|x| !x); loop { let mut new_mappings = Map::new(); for (i, (&garbled1, choices1)) in mappings.iter().enumerate() { for (&garbled2, choices2) in mappings.iter().skip(i + 1) { for (op1, op2) in [ (identity, identity), (identity, bitwise_not), (bitwise_not, identity), ] { let new_garbled = op1(garbled1) & op2(garbled2); if new_garbled.n_on == 0 { continue; } let mut new_good_candidates = Set::new(); for &good_digit1 in choices1 { for &good_digit2 in choices2 { let candidate = op1(good_digit1) & op2(good_digit2); if candidate.n_on == new_garbled.n_on { new_good_candidates.insert(candidate); } } } match new_mappings.entry(new_garbled) { MapEntry::Vacant(v) => { v.insert(new_good_candidates); } MapEntry::Occupied(mut o) => { o.insert(o.get() & &new_good_candidates); } } } } } // Remove all keys that can be written as the disjoint-bitwise-or of two other // keys, as they're redundant. This means if e.g., A and BC are present, then // remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB // and BC are not disjoint) let mut redundant_keys = Set::new(); let new_garbled_keys = new_mappings.keys().copied().collect::>(); for (i, &garbled1) in new_garbled_keys.iter().enumerate() { for &garbled2 in new_garbled_keys.iter().skip(i + 1) { if (garbled1 & garbled2).n_on != 0 { continue; } let segment_union = garbled1 | garbled2; if new_garbled_keys.contains(&segment_union) { redundant_keys.insert(segment_union); } } } for k in &redundant_keys { new_mappings.remove(k); } if mappings.len() == N_SEGMENTS && mappings.values().all(|m| m.len() == 1) { return Ok(mappings .into_iter() .map(|(k, v)| (k, v.iter().next().copied().unwrap())) .collect()); } else if mappings == new_mappings { return Err(mappings); } mappings = new_mappings; } } fn apply_mapping_to_garbled_digit(mapping: &Map, garbled_digit: Digit) -> usize { let mut result = Digit::new([false; 7]); for (&k, &v) in mapping { if (garbled_digit & k).n_on > 0 { result = result | v; } } result.into() } fn read_input(input: &str) -> Vec, Vec)> { fn whitespace_sepd_strs_to_digits(strs: &str) -> Vec { strs.trim() .split_ascii_whitespace() .map(Digit::from_str) .collect() } input .lines() .filter_map(|line| { let line = line.trim(); if line.is_empty() { return None; } let mut in_out = line.split('|'); let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?); let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?); Some((in_digits, out_digits)) }) .collect() } fn translate_line_to_digits>( idod: (impl Iterator, impl Iterator), ) -> Option> { let (in_digits, out_digits) = idod; let mapping = get_mapping_from_garbled_digits(in_digits).ok()?; Some( out_digits .map(|d| apply_mapping_to_garbled_digit(&mapping, *d.borrow())) .collect(), ) } fn ans_for_input(input: &str) -> Answer { let in_out_lines = read_input(input); let output_digits = in_out_lines .iter() .map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter()))) .collect::>>() .unwrap(); (8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(out_digits: impl Iterator) -> usize { out_digits .map(|v| { v.as_ref() .iter() .filter(|&n| [1, 4, 7, 8].contains(n)) .count() }) .sum() } // end::pt1[] // tag::pt2[] fn pt2>(out_digits: impl Iterator) -> usize { out_digits .map(|v| { v.as_ref() .iter() .rev() .enumerate() .map(|(pow10, &val)| val * 10_usize.pow(u32::try_from(pow10).unwrap())) .sum::() }) .sum() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 8, ans: (237, 1_009_098)); } } // tag::setup[] use crate::Answer; use std::collections::{btree_map::Entry as MapEntry, BTreeMap as Map, BTreeSet as Set}; const N_SEGMENTS: usize = 7; // end::setup[] // tag::digit[] #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)] struct Digit { segments: [bool; N_SEGMENTS], n_on: usize, } impl Digit { fn new(segments: [bool; N_SEGMENTS]) -> Self { Self { segments, n_on: segments.iter().filter(|&&b| b).count(), } } fn from_str(s: &str) -> Self { let mut segments = [false; N_SEGMENTS]; for c in s.bytes() { let i = c - b'a'; segments[usize::from(i)] = true; } Self::new(segments) } fn _bin_op(self, rhs: Self, f: impl Fn(bool, bool) -> bool) -> Self { Self::new(self.segments.zip(rhs.segments).map(|(x, y)| f(x, y))) } } impl std::ops::BitOr for Digit { type Output = Self; fn bitor(self, rhs: Self) -> Self::Output { self._bin_op(rhs, |x, y| x | y) } } impl std::ops::BitAnd for Digit { type Output = Self; fn bitand(self, rhs: Self) -> Self::Output { self._bin_op(rhs, |x, y| x & y) } } impl std::ops::Not for Digit { type Output = Self; fn not(self) -> Self::Output { Self::new(self.segments.map(|b| !b)) } } impl From for Digit { fn from(n: usize) -> Self { let segments = match n { /* -----[A, B, C, D, E, F, G] */ 0 => [1, 1, 1, 0, 1, 1, 1], 1 => [0, 0, 1, 0, 0, 1, 0], 2 => [1, 0, 1, 1, 1, 0, 1], 3 => [1, 0, 1, 1, 0, 1, 1], 4 => [0, 1, 1, 1, 0, 1, 0], 5 => [1, 1, 0, 1, 0, 1, 1], 6 => [1, 1, 0, 1, 1, 1, 1], 7 => [1, 0, 1, 0, 0, 1, 0], 8 => [1, 1, 1, 1, 1, 1, 1], 9 => [1, 1, 1, 1, 0, 1, 1], _ => panic!(\"Cannot make digit for n={}\", n), }; let segments = segments.map(|i| i != 0); Self::new(segments) } } impl From for usize { fn from(digit: Digit) -> Self { let segments = digit.segments.map(u8::from); match segments { /* [A, B, C, D, E, F, G] */ [1, 1, 1, 0, 1, 1, 1] => 0, [0, 0, 1, 0, 0, 1, 0] => 1, [1, 0, 1, 1, 1, 0, 1] => 2, [1, 0, 1, 1, 0, 1, 1] => 3, [0, 1, 1, 1, 0, 1, 0] => 4, [1, 1, 0, 1, 0, 1, 1] => 5, [1, 1, 0, 1, 1, 1, 1] => 6, [1, 0, 1, 0, 0, 1, 0] => 7, [1, 1, 1, 1, 1, 1, 1] => 8, [1, 1, 1, 1, 0, 1, 1] => 9, _ => panic!(\"Digit {:?} is not valid\", digit), } } } // end::digit[] // tag::setup[] fn get_mapping_from_garbled_digits>( garbled_digits: impl Iterator, ) -> Result, Map>> { let mut mappings = Map::new(); { let mut grouped_by_n_on = Map::new(); for n in 0..=9 { let digit = Digit::from(n); grouped_by_n_on .entry(digit.n_on) .or_insert_with(Set::new) .insert(digit); } for gd in garbled_digits { let gd = *gd.borrow(); let digits_w_same_n_segments = &grouped_by_n_on[&gd.n_on]; mappings.insert(gd, digits_w_same_n_segments.clone()); } } let identity: &dyn Fn(Digit) -> _ = &(|x| x); let bitwise_not: &dyn Fn(Digit) -> _ = &(|x| !x); loop { let mut new_mappings = Map::new(); for (i, (&garbled1, choices1)) in mappings.iter().enumerate() { for (&garbled2, choices2) in mappings.iter().skip(i + 1) { for (op1, op2) in [ (identity, identity), (identity, bitwise_not), (bitwise_not, identity), ] { let new_garbled = op1(garbled1) & op2(garbled2); if new_garbled.n_on == 0 { continue; } let mut new_good_candidates = Set::new(); for &good_digit1 in choices1 { for &good_digit2 in choices2 { let candidate = op1(good_digit1) & op2(good_digit2); if candidate.n_on == new_garbled.n_on { new_good_candidates.insert(candidate); } } } match new_mappings.entry(new_garbled) { MapEntry::Vacant(v) => { v.insert(new_good_candidates); } MapEntry::Occupied(mut o) => { o.insert(o.get() & &new_good_candidates); } } } } } // Remove all keys that can be written as the disjoint-bitwise-or of two other // keys, as they're redundant. This means if e.g., A and BC are present, then // remove ABC. But if only AB and BC are present, then do *not* remove ABC (as AB // and BC are not disjoint) let mut redundant_keys = Set::new(); let new_garbled_keys = new_mappings.keys().copied().collect::>(); for (i, &garbled1) in new_garbled_keys.iter().enumerate() { for &garbled2 in new_garbled_keys.iter().skip(i + 1) { if (garbled1 & garbled2).n_on != 0 { continue; } let segment_union = garbled1 | garbled2; if new_garbled_keys.contains(&segment_union) { redundant_keys.insert(segment_union); } } } for k in &redundant_keys { new_mappings.remove(k); } if mappings.len() == N_SEGMENTS && mappings.values().all(|m| m.len() == 1) { return Ok(mappings .into_iter() .map(|(k, v)| (k, v.iter().next().copied().unwrap())) .collect()); } else if mappings == new_mappings { return Err(mappings); } mappings = new_mappings; } } fn apply_mapping_to_garbled_digit(mapping: &Map, garbled_digit: Digit) -> usize { let mut result = Digit::new([false; 7]); for (&k, &v) in mapping { if (garbled_digit & k).n_on > 0 { result = result | v; } } result.into() } fn read_input(input: &str) -> Vec, Vec)> { fn whitespace_sepd_strs_to_digits(strs: &str) -> Vec { strs.trim() .split_ascii_whitespace() .map(Digit::from_str) .collect() } input .lines() .filter_map(|line| { let line = line.trim(); if line.is_empty() { return None; } let mut in_out = line.split('|'); let in_digits = whitespace_sepd_strs_to_digits(in_out.next()?); let out_digits = whitespace_sepd_strs_to_digits(in_out.next()?); Some((in_digits, out_digits)) }) .collect() } fn translate_line_to_digits>( idod: (impl Iterator, impl Iterator), ) -> Option> { let (in_digits, out_digits) = idod; let mapping = get_mapping_from_garbled_digits(in_digits).ok()?; Some( out_digits .map(|d| apply_mapping_to_garbled_digit(&mapping, *d.borrow())) .collect(), ) } fn ans_for_input(input: &str) -> Answer { let in_out_lines = read_input(input); let output_digits = in_out_lines .iter() .map(|(in_d, out_d)| translate_line_to_digits((in_d.iter(), out_d.iter()))) .collect::>>() .unwrap(); (8, (pt1(output_digits.iter()), pt2(output_digits.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(out_digits: impl Iterator) -> usize { out_digits .map(|v| { v.as_ref() .iter() .filter(|&n| [1, 4, 7, 8].contains(n)) .count() }) .sum() } // end::pt1[] // tag::pt2[] fn pt2>(out_digits: impl Iterator) -> usize { out_digits .map(|v| { v.as_ref() .iter() .rev() .enumerate() .map(|(pow10, &val)| val * 10_usize.pow(u32::try_from(pow10).unwrap())) .sum::() }) .sum() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 8, ans: (237, 1_009_098)); } }","title":"Day 8: Seven Segment Search","component":"ROOT","version":"","name":"soln","url":"/src/day_08/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"10":{"id":10,"text":"Day #9 problem description │ Problem input Nothing complicated here. We must do the following things with a 2D matrix whose entries are between 1 and 9 (inclusive). In Part 1 we have to find the local minima of the matrix. In Part 2 we have to find the matrix’s maximal connected regions containing no 9s. This is just a DFS through the matrix with a small amount of bookkeeping. // tag::setup[] use crate::Answer; use ndarray::prelude::*; use std::collections::BTreeSet as Set; #[derive(Debug)] struct Heightmap { arr: Array2, } fn get_neighbor_idxs( [row, col]: [usize; 2], n_rows: usize, n_cols: usize, ) -> [[Option; 2]; 4] { [ [(row + 1 Option { let width = s.lines().next()?.chars().count(); let height = s.lines().count(); let mut data = Vec::new(); for line in s.lines() { data.extend( line.trim() .chars() .map(|c| c.to_digit(10).and_then(|d| usize::try_from(d).ok())), ); } let data = data.iter().copied().collect::>>()?; let arr = Array2::from_shape_vec((width, height), data).ok()?; Some(Self { arr }) } } fn ans_for_input(input: &str) -> Answer { let hm = Heightmap::from_str(input).unwrap(); (9, (pt1(&hm), pt2(&hm))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] impl Heightmap { fn is_lower_than_neighbors(&self, idx: [usize; 2]) -> bool { let val = self.arr[idx]; let (n_rows, n_cols) = self.arr.dim(); let neighbors = get_neighbor_idxs(idx, n_rows, n_cols); for idx_pair in neighbors { let idxs = match idx_pair { [Some(r), Some(c)] => [r, c], _ => continue, }; if self.arr[idxs] Vec { let (n_rows, n_cols) = self.arr.dim(); let mut idxs = Vec::new(); for r in 0..n_rows { for c in 0..n_cols { if self.is_lower_than_neighbors([r, c]) { idxs.push([r, c]); } } } idxs } } fn pt1(hm: &Heightmap) -> usize { hm.idxs_where_lower_than_neighbors() .into_iter() .map(|idx| hm.arr[idx] + 1) .sum() } // end::pt1[] // tag::pt2[] impl Heightmap { fn basin_sizes(&self) -> Vec { let (n_rows, n_cols) = self.arr.dim(); let mut basin_sizes = Vec::new(); let mut not_yet_visited_idxs = (0..n_rows) .flat_map(|r| { (0..n_cols).filter_map(move |c| { let idx = [r, c]; (self.arr[idx] != 9).then_some(idx) }) }) .collect::>(); while let Some(first_idx) = not_yet_visited_idxs.pop_first() { let mut visited_idxs = Set::new(); let mut coords_stack = vec![first_idx]; while let Some(idx) = coords_stack.pop() { if !visited_idxs.insert(idx) { continue; } let neighbor_idxs = get_neighbor_idxs(idx, n_rows, n_cols); for nghbr_idx in neighbor_idxs { let nghbr_idx = match nghbr_idx { [Some(r), Some(c)] => [r, c], _ => continue, }; if self.arr[nghbr_idx] != 9 && !visited_idxs.contains(&nghbr_idx) { coords_stack.push(nghbr_idx); } } for idx in &visited_idxs { not_yet_visited_idxs.remove(idx); } } basin_sizes.push(visited_idxs.len()); } basin_sizes } } fn pt2(hm: &Heightmap) -> usize { let mut basin_sizes = hm.basin_sizes(); basin_sizes.sort_unstable_by_key(|&size| std::cmp::Reverse(size)); basin_sizes.into_iter().take(3).product() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 9, ans: (575, 1_019_700)); } } // tag::setup[] use crate::Answer; use ndarray::prelude::*; use std::collections::BTreeSet as Set; #[derive(Debug)] struct Heightmap { arr: Array2, } fn get_neighbor_idxs( [row, col]: [usize; 2], n_rows: usize, n_cols: usize, ) -> [[Option; 2]; 4] { [ [(row + 1 Option { let width = s.lines().next()?.chars().count(); let height = s.lines().count(); let mut data = Vec::new(); for line in s.lines() { data.extend( line.trim() .chars() .map(|c| c.to_digit(10).and_then(|d| usize::try_from(d).ok())), ); } let data = data.iter().copied().collect::>>()?; let arr = Array2::from_shape_vec((width, height), data).ok()?; Some(Self { arr }) } } fn ans_for_input(input: &str) -> Answer { let hm = Heightmap::from_str(input).unwrap(); (9, (pt1(&hm), pt2(&hm))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] impl Heightmap { fn is_lower_than_neighbors(&self, idx: [usize; 2]) -> bool { let val = self.arr[idx]; let (n_rows, n_cols) = self.arr.dim(); let neighbors = get_neighbor_idxs(idx, n_rows, n_cols); for idx_pair in neighbors { let idxs = match idx_pair { [Some(r), Some(c)] => [r, c], _ => continue, }; if self.arr[idxs] Vec { let (n_rows, n_cols) = self.arr.dim(); let mut idxs = Vec::new(); for r in 0..n_rows { for c in 0..n_cols { if self.is_lower_than_neighbors([r, c]) { idxs.push([r, c]); } } } idxs } } fn pt1(hm: &Heightmap) -> usize { hm.idxs_where_lower_than_neighbors() .into_iter() .map(|idx| hm.arr[idx] + 1) .sum() } // end::pt1[] // tag::pt2[] impl Heightmap { fn basin_sizes(&self) -> Vec { let (n_rows, n_cols) = self.arr.dim(); let mut basin_sizes = Vec::new(); let mut not_yet_visited_idxs = (0..n_rows) .flat_map(|r| { (0..n_cols).filter_map(move |c| { let idx = [r, c]; (self.arr[idx] != 9).then_some(idx) }) }) .collect::>(); while let Some(first_idx) = not_yet_visited_idxs.pop_first() { let mut visited_idxs = Set::new(); let mut coords_stack = vec![first_idx]; while let Some(idx) = coords_stack.pop() { if !visited_idxs.insert(idx) { continue; } let neighbor_idxs = get_neighbor_idxs(idx, n_rows, n_cols); for nghbr_idx in neighbor_idxs { let nghbr_idx = match nghbr_idx { [Some(r), Some(c)] => [r, c], _ => continue, }; if self.arr[nghbr_idx] != 9 && !visited_idxs.contains(&nghbr_idx) { coords_stack.push(nghbr_idx); } } for idx in &visited_idxs { not_yet_visited_idxs.remove(idx); } } basin_sizes.push(visited_idxs.len()); } basin_sizes } } fn pt2(hm: &Heightmap) -> usize { let mut basin_sizes = hm.basin_sizes(); basin_sizes.sort_unstable_by_key(|&size| std::cmp::Reverse(size)); basin_sizes.into_iter().take(3).product() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 9, ans: (575, 1_019_700)); } } // tag::setup[] use crate::Answer; use ndarray::prelude::*; use std::collections::BTreeSet as Set; #[derive(Debug)] struct Heightmap { arr: Array2, } fn get_neighbor_idxs( [row, col]: [usize; 2], n_rows: usize, n_cols: usize, ) -> [[Option; 2]; 4] { [ [(row + 1 Option { let width = s.lines().next()?.chars().count(); let height = s.lines().count(); let mut data = Vec::new(); for line in s.lines() { data.extend( line.trim() .chars() .map(|c| c.to_digit(10).and_then(|d| usize::try_from(d).ok())), ); } let data = data.iter().copied().collect::>>()?; let arr = Array2::from_shape_vec((width, height), data).ok()?; Some(Self { arr }) } } fn ans_for_input(input: &str) -> Answer { let hm = Heightmap::from_str(input).unwrap(); (9, (pt1(&hm), pt2(&hm))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] impl Heightmap { fn is_lower_than_neighbors(&self, idx: [usize; 2]) -> bool { let val = self.arr[idx]; let (n_rows, n_cols) = self.arr.dim(); let neighbors = get_neighbor_idxs(idx, n_rows, n_cols); for idx_pair in neighbors { let idxs = match idx_pair { [Some(r), Some(c)] => [r, c], _ => continue, }; if self.arr[idxs] Vec { let (n_rows, n_cols) = self.arr.dim(); let mut idxs = Vec::new(); for r in 0..n_rows { for c in 0..n_cols { if self.is_lower_than_neighbors([r, c]) { idxs.push([r, c]); } } } idxs } } fn pt1(hm: &Heightmap) -> usize { hm.idxs_where_lower_than_neighbors() .into_iter() .map(|idx| hm.arr[idx] + 1) .sum() } // end::pt1[] // tag::pt2[] impl Heightmap { fn basin_sizes(&self) -> Vec { let (n_rows, n_cols) = self.arr.dim(); let mut basin_sizes = Vec::new(); let mut not_yet_visited_idxs = (0..n_rows) .flat_map(|r| { (0..n_cols).filter_map(move |c| { let idx = [r, c]; (self.arr[idx] != 9).then_some(idx) }) }) .collect::>(); while let Some(first_idx) = not_yet_visited_idxs.pop_first() { let mut visited_idxs = Set::new(); let mut coords_stack = vec![first_idx]; while let Some(idx) = coords_stack.pop() { if !visited_idxs.insert(idx) { continue; } let neighbor_idxs = get_neighbor_idxs(idx, n_rows, n_cols); for nghbr_idx in neighbor_idxs { let nghbr_idx = match nghbr_idx { [Some(r), Some(c)] => [r, c], _ => continue, }; if self.arr[nghbr_idx] != 9 && !visited_idxs.contains(&nghbr_idx) { coords_stack.push(nghbr_idx); } } for idx in &visited_idxs { not_yet_visited_idxs.remove(idx); } } basin_sizes.push(visited_idxs.len()); } basin_sizes } } fn pt2(hm: &Heightmap) -> usize { let mut basin_sizes = hm.basin_sizes(); basin_sizes.sort_unstable_by_key(|&size| std::cmp::Reverse(size)); basin_sizes.into_iter().take(3).product() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 9, ans: (575, 1_019_700)); } }","title":"Day 9: Smoke Basin","component":"ROOT","version":"","name":"soln","url":"/src/day_09/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"11":{"id":11,"text":"Day #10 problem description │ Problem input Pretty basic. Parsing is done with a token stack; when we see paired braces at the top of the stack, we pop them both. If we see mismatched braces, we immediately know we have a Corrupted token stream. If we make it to the end of the input without match-and-popping everything — i.e., if the stack isn’t empty at the end — then we have an Incomplete token stream. // tag::setup[] use crate::Answer; #[derive(Clone, Copy, Debug, PartialEq, Eq)] enum Brace { Paren, Square, Curly, Angle, } #[derive(Clone, Copy, Debug, PartialEq, Eq)] enum Orientation { Left, Right, } impl Orientation { fn flip(self) -> Self { use Orientation::*; match self { Left => Right, Right => Left, } } } #[derive(Clone, Copy, Debug, PartialEq, Eq)] struct Token { brace: Brace, orientation: Orientation, } impl Token { fn from_char(c: char) -> Option { use Brace::*; use Orientation::*; let (orientation, brace) = match c { '(' => (Left, Paren), ')' => (Right, Paren), '[' => (Left, Square), ']' => (Right, Square), '{' => (Left, Curly), '}' => (Right, Curly), ' (Left, Angle), '>' => (Right, Angle), _ => return None, }; Some(Self { brace, orientation }) } fn flip(self) -> Self { Self { orientation: self.orientation.flip(), ..self } } } enum TokenizationErr { Corrupted(Token), Incomplete(Vec), } type ParseResult = Result; fn parse_line>(line: impl Iterator) -> ParseResult { use Orientation::*; let mut token_stack = Vec::new(); for curr in line { let curr = *curr.borrow(); match token_stack.last() { None => { token_stack.push(curr); } Some(&prev) => { if prev.orientation == Left && curr.orientation == Right { if prev.brace != curr.brace { return Err(TokenizationErr::Corrupted(curr)); } token_stack.pop(); } else { token_stack.push(curr); } } } } if !token_stack.is_empty() { return Err(TokenizationErr::Incomplete( token_stack.iter().rev().map(|t| t.flip()).collect(), )); } Ok(()) } fn read_input(input: &str) -> Option>> { input .lines() .map(|line| { line.trim() .chars() .map(Token::from_char) .collect::>>() }) .collect::>>() } fn ans_for_input(input: &str) -> Answer { let tokens = read_input(input).unwrap(); let parsed_lines = tokens .iter() .map(|v| parse_line(v.iter())) .collect::>(); (10, (pt1(parsed_lines.iter()), pt2(parsed_lines.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(prs: impl Iterator) -> usize { use Brace::*; prs.filter_map(|r| { let r = r.borrow(); if let Err(TokenizationErr::Corrupted(t)) = r { Some(match t.brace { Paren => 3, Square => 57, Curly => 1197, Angle => 25137, }) } else { None } }) .sum() } // end::pt1[] // tag::pt2[] fn pt2>(prs: impl Iterator) -> usize { use Brace::*; let mut scores = prs .filter_map(|r| { let r = r.borrow(); if let Err(TokenizationErr::Incomplete(tokens)) = r { let mut score = 0_usize; for t in tokens { score *= 5; let token_score = match t.brace { Paren => 1, Square => 2, Curly => 3, Angle => 4, }; score += token_score; } Some(score) } else { None } }) .collect::>(); scores.sort_unstable(); scores[scores.len() / 2] } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 10, ans: (167_379, 2_776_842_859)); } } // tag::setup[] use crate::Answer; #[derive(Clone, Copy, Debug, PartialEq, Eq)] enum Brace { Paren, Square, Curly, Angle, } #[derive(Clone, Copy, Debug, PartialEq, Eq)] enum Orientation { Left, Right, } impl Orientation { fn flip(self) -> Self { use Orientation::*; match self { Left => Right, Right => Left, } } } #[derive(Clone, Copy, Debug, PartialEq, Eq)] struct Token { brace: Brace, orientation: Orientation, } impl Token { fn from_char(c: char) -> Option { use Brace::*; use Orientation::*; let (orientation, brace) = match c { '(' => (Left, Paren), ')' => (Right, Paren), '[' => (Left, Square), ']' => (Right, Square), '{' => (Left, Curly), '}' => (Right, Curly), ' (Left, Angle), '>' => (Right, Angle), _ => return None, }; Some(Self { brace, orientation }) } fn flip(self) -> Self { Self { orientation: self.orientation.flip(), ..self } } } enum TokenizationErr { Corrupted(Token), Incomplete(Vec), } type ParseResult = Result; fn parse_line>(line: impl Iterator) -> ParseResult { use Orientation::*; let mut token_stack = Vec::new(); for curr in line { let curr = *curr.borrow(); match token_stack.last() { None => { token_stack.push(curr); } Some(&prev) => { if prev.orientation == Left && curr.orientation == Right { if prev.brace != curr.brace { return Err(TokenizationErr::Corrupted(curr)); } token_stack.pop(); } else { token_stack.push(curr); } } } } if !token_stack.is_empty() { return Err(TokenizationErr::Incomplete( token_stack.iter().rev().map(|t| t.flip()).collect(), )); } Ok(()) } fn read_input(input: &str) -> Option>> { input .lines() .map(|line| { line.trim() .chars() .map(Token::from_char) .collect::>>() }) .collect::>>() } fn ans_for_input(input: &str) -> Answer { let tokens = read_input(input).unwrap(); let parsed_lines = tokens .iter() .map(|v| parse_line(v.iter())) .collect::>(); (10, (pt1(parsed_lines.iter()), pt2(parsed_lines.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(prs: impl Iterator) -> usize { use Brace::*; prs.filter_map(|r| { let r = r.borrow(); if let Err(TokenizationErr::Corrupted(t)) = r { Some(match t.brace { Paren => 3, Square => 57, Curly => 1197, Angle => 25137, }) } else { None } }) .sum() } // end::pt1[] // tag::pt2[] fn pt2>(prs: impl Iterator) -> usize { use Brace::*; let mut scores = prs .filter_map(|r| { let r = r.borrow(); if let Err(TokenizationErr::Incomplete(tokens)) = r { let mut score = 0_usize; for t in tokens { score *= 5; let token_score = match t.brace { Paren => 1, Square => 2, Curly => 3, Angle => 4, }; score += token_score; } Some(score) } else { None } }) .collect::>(); scores.sort_unstable(); scores[scores.len() / 2] } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 10, ans: (167_379, 2_776_842_859)); } } // tag::setup[] use crate::Answer; #[derive(Clone, Copy, Debug, PartialEq, Eq)] enum Brace { Paren, Square, Curly, Angle, } #[derive(Clone, Copy, Debug, PartialEq, Eq)] enum Orientation { Left, Right, } impl Orientation { fn flip(self) -> Self { use Orientation::*; match self { Left => Right, Right => Left, } } } #[derive(Clone, Copy, Debug, PartialEq, Eq)] struct Token { brace: Brace, orientation: Orientation, } impl Token { fn from_char(c: char) -> Option { use Brace::*; use Orientation::*; let (orientation, brace) = match c { '(' => (Left, Paren), ')' => (Right, Paren), '[' => (Left, Square), ']' => (Right, Square), '{' => (Left, Curly), '}' => (Right, Curly), ' (Left, Angle), '>' => (Right, Angle), _ => return None, }; Some(Self { brace, orientation }) } fn flip(self) -> Self { Self { orientation: self.orientation.flip(), ..self } } } enum TokenizationErr { Corrupted(Token), Incomplete(Vec), } type ParseResult = Result; fn parse_line>(line: impl Iterator) -> ParseResult { use Orientation::*; let mut token_stack = Vec::new(); for curr in line { let curr = *curr.borrow(); match token_stack.last() { None => { token_stack.push(curr); } Some(&prev) => { if prev.orientation == Left && curr.orientation == Right { if prev.brace != curr.brace { return Err(TokenizationErr::Corrupted(curr)); } token_stack.pop(); } else { token_stack.push(curr); } } } } if !token_stack.is_empty() { return Err(TokenizationErr::Incomplete( token_stack.iter().rev().map(|t| t.flip()).collect(), )); } Ok(()) } fn read_input(input: &str) -> Option>> { input .lines() .map(|line| { line.trim() .chars() .map(Token::from_char) .collect::>>() }) .collect::>>() } fn ans_for_input(input: &str) -> Answer { let tokens = read_input(input).unwrap(); let parsed_lines = tokens .iter() .map(|v| parse_line(v.iter())) .collect::>(); (10, (pt1(parsed_lines.iter()), pt2(parsed_lines.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(prs: impl Iterator) -> usize { use Brace::*; prs.filter_map(|r| { let r = r.borrow(); if let Err(TokenizationErr::Corrupted(t)) = r { Some(match t.brace { Paren => 3, Square => 57, Curly => 1197, Angle => 25137, }) } else { None } }) .sum() } // end::pt1[] // tag::pt2[] fn pt2>(prs: impl Iterator) -> usize { use Brace::*; let mut scores = prs .filter_map(|r| { let r = r.borrow(); if let Err(TokenizationErr::Incomplete(tokens)) = r { let mut score = 0_usize; for t in tokens { score *= 5; let token_score = match t.brace { Paren => 1, Square => 2, Curly => 3, Angle => 4, }; score += token_score; } Some(score) } else { None } }) .collect::>(); scores.sort_unstable(); scores[scores.len() / 2] } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 10, ans: (167_379, 2_776_842_859)); } }","title":"Day 10: Syntax Scoring","component":"ROOT","version":"","name":"soln","url":"/src/day_10/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"12":{"id":12,"text":"Day #11 problem description │ Problem input These problems where you just have to manage the state of an array and update it correctly, and potentially query the state of the array, aren’t that interesting to me anymore. There is no algorithmic interestingness to them. // tag::setup[] use crate::Answer; use ndarray::prelude::*; #[derive(Clone, Debug)] struct Octopi { arr: Array2, } impl Octopi { fn from_str(s: &str) -> Option { let mut data = Vec::new(); let width = s.lines().next()?.len(); let height = s.lines().count(); for line in s.lines() { data.extend( line.trim() .chars() .map(|c| c.to_digit(10).and_then(|d| usize::try_from(d).ok())), ); } let data = data.into_iter().collect::>>()?; let arr = Array2::from_shape_vec((width, height), data).ok()?; Some(Self { arr }) } fn tick_in_place_and_count_flashes(&mut self) -> usize { // We use equality with FLASH_THRESH to mean \"will flash right now\", whereas being // greater than FLASH_THRESH means \"has already flashed (and won't flash again)\" let flash_thresh = 10; let (n_rows, n_cols) = self.arr.dim(); self.arr.mapv_inplace(|x| x + 1); let mut n_flashes = 0; loop { let flashing_octopi_idxs = (0..n_rows) .flat_map(|r| { let arr = &self.arr; (0..n_cols).filter_map(move |c| { let idx = [r, c]; let val = &arr[idx]; (*val == flash_thresh).then_some(idx) }) }) .collect::>(); if flashing_octopi_idxs.is_empty() { break; } n_flashes += flashing_octopi_idxs.len(); for [base_row, base_col] in flashing_octopi_idxs { self.arr[[base_row, base_col]] += 1; let rows = [ base_row.checked_sub(1), Some(base_row), (base_row + 1 = flash_thresh { 0 } else { val }); n_flashes } } fn ans_for_input(input: &str) -> Answer { let octopi = Octopi::from_str(input).unwrap(); (11, (pt1(octopi.clone()), pt2(octopi))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn tick(mut octopi: Octopi, n: usize) -> usize { let mut n_flashes = 0; for _ in 0..n { n_flashes += octopi.tick_in_place_and_count_flashes(); } n_flashes } fn pt1(octopi: Octopi) -> usize { tick(octopi, 100) } // end::pt1[] // tag::pt2[] fn pt2(mut octopi: Octopi) -> usize { let mut n = 0; while octopi.arr.iter().any(|&val| val != 0) { octopi.tick_in_place_and_count_flashes(); n += 1; } n } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 11, ans: (1617, 258)); } } // tag::setup[] use crate::Answer; use ndarray::prelude::*; #[derive(Clone, Debug)] struct Octopi { arr: Array2, } impl Octopi { fn from_str(s: &str) -> Option { let mut data = Vec::new(); let width = s.lines().next()?.len(); let height = s.lines().count(); for line in s.lines() { data.extend( line.trim() .chars() .map(|c| c.to_digit(10).and_then(|d| usize::try_from(d).ok())), ); } let data = data.into_iter().collect::>>()?; let arr = Array2::from_shape_vec((width, height), data).ok()?; Some(Self { arr }) } fn tick_in_place_and_count_flashes(&mut self) -> usize { // We use equality with FLASH_THRESH to mean \"will flash right now\", whereas being // greater than FLASH_THRESH means \"has already flashed (and won't flash again)\" let flash_thresh = 10; let (n_rows, n_cols) = self.arr.dim(); self.arr.mapv_inplace(|x| x + 1); let mut n_flashes = 0; loop { let flashing_octopi_idxs = (0..n_rows) .flat_map(|r| { let arr = &self.arr; (0..n_cols).filter_map(move |c| { let idx = [r, c]; let val = &arr[idx]; (*val == flash_thresh).then_some(idx) }) }) .collect::>(); if flashing_octopi_idxs.is_empty() { break; } n_flashes += flashing_octopi_idxs.len(); for [base_row, base_col] in flashing_octopi_idxs { self.arr[[base_row, base_col]] += 1; let rows = [ base_row.checked_sub(1), Some(base_row), (base_row + 1 = flash_thresh { 0 } else { val }); n_flashes } } fn ans_for_input(input: &str) -> Answer { let octopi = Octopi::from_str(input).unwrap(); (11, (pt1(octopi.clone()), pt2(octopi))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn tick(mut octopi: Octopi, n: usize) -> usize { let mut n_flashes = 0; for _ in 0..n { n_flashes += octopi.tick_in_place_and_count_flashes(); } n_flashes } fn pt1(octopi: Octopi) -> usize { tick(octopi, 100) } // end::pt1[] // tag::pt2[] fn pt2(mut octopi: Octopi) -> usize { let mut n = 0; while octopi.arr.iter().any(|&val| val != 0) { octopi.tick_in_place_and_count_flashes(); n += 1; } n } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 11, ans: (1617, 258)); } } // tag::setup[] use crate::Answer; use ndarray::prelude::*; #[derive(Clone, Debug)] struct Octopi { arr: Array2, } impl Octopi { fn from_str(s: &str) -> Option { let mut data = Vec::new(); let width = s.lines().next()?.len(); let height = s.lines().count(); for line in s.lines() { data.extend( line.trim() .chars() .map(|c| c.to_digit(10).and_then(|d| usize::try_from(d).ok())), ); } let data = data.into_iter().collect::>>()?; let arr = Array2::from_shape_vec((width, height), data).ok()?; Some(Self { arr }) } fn tick_in_place_and_count_flashes(&mut self) -> usize { // We use equality with FLASH_THRESH to mean \"will flash right now\", whereas being // greater than FLASH_THRESH means \"has already flashed (and won't flash again)\" let flash_thresh = 10; let (n_rows, n_cols) = self.arr.dim(); self.arr.mapv_inplace(|x| x + 1); let mut n_flashes = 0; loop { let flashing_octopi_idxs = (0..n_rows) .flat_map(|r| { let arr = &self.arr; (0..n_cols).filter_map(move |c| { let idx = [r, c]; let val = &arr[idx]; (*val == flash_thresh).then_some(idx) }) }) .collect::>(); if flashing_octopi_idxs.is_empty() { break; } n_flashes += flashing_octopi_idxs.len(); for [base_row, base_col] in flashing_octopi_idxs { self.arr[[base_row, base_col]] += 1; let rows = [ base_row.checked_sub(1), Some(base_row), (base_row + 1 = flash_thresh { 0 } else { val }); n_flashes } } fn ans_for_input(input: &str) -> Answer { let octopi = Octopi::from_str(input).unwrap(); (11, (pt1(octopi.clone()), pt2(octopi))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn tick(mut octopi: Octopi, n: usize) -> usize { let mut n_flashes = 0; for _ in 0..n { n_flashes += octopi.tick_in_place_and_count_flashes(); } n_flashes } fn pt1(octopi: Octopi) -> usize { tick(octopi, 100) } // end::pt1[] // tag::pt2[] fn pt2(mut octopi: Octopi) -> usize { let mut n = 0; while octopi.arr.iter().any(|&val| val != 0) { octopi.tick_in_place_and_count_flashes(); n += 1; } n } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 11, ans: (1617, 258)); } }","title":"Day 11: Dumbo Octopus","component":"ROOT","version":"","name":"soln","url":"/src/day_11/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"13":{"id":13,"text":"Day #12 problem description | Problem input Finally, a problem that isn’t just about array manipulation. This problem asks us to count the number of paths from the origin node of an undirected graph to the destination node, with constraints on how many times we may visit certain nodes, but no constraints on how many times we may use an edge. (Note that the problem has us exploring an underwater cave system, so the source code below refers to nodes as “caves”.) Nodes are classified as either “big” or “small”, depending on the case of their name in the input. A big node can be visited arbitrarily many times, whereas a small node can only be visited a limited number of times. (If two big nodes were adjacent, then there would be infinitely many paths through the graph since because we could just bounce back and forth between them forever.) First, we must build the graph. We ingest the list of edges into a dictionary mapping each node to the set of nodes reachable from it. After doing this we traverse the graph. We maintain a stack representing the current path; we push onto the stack from the choices in the current node’s entry in the dictionary, and when we’ve exhausted all of the edges available from the current node, we pop the current node. We don’t actually maintain a stack in the code; we merely use the call stack. // tag::setup[] use crate::Answer; use std::collections::BTreeMap as Map; #[derive(Debug, PartialEq, Eq, PartialOrd, Ord)] enum CaveKind { Big, Small, } #[derive(Debug, PartialEq, Eq, PartialOrd, Ord)] struct Cave { name: &'a str, kind: CaveKind, } impl Cave { fn new(name: &'a str) -> Self { let is_small = name.chars().map(|c| c.is_ascii_lowercase()).all(|b| b); let kind = if is_small { CaveKind::Small } else { CaveKind::Big }; Self { name, kind } } } #[derive(Debug)] struct CaveSystem { edges: Map>>, } impl CaveSystem { fn from_str(input: &'a str) -> Option { let mut edges = Map::new(); for line in input.lines() { let mut splat = line.split('-'); let left = splat.next()?; let right = splat.next()?; for (orig, dest) in [(left, right), (right, left)] { if orig != \"end\" && dest != \"start\" { edges .entry(orig) .or_insert_with(Vec::new) .push(Cave::new(dest)); } } } Some(Self { edges }) } } impl CaveSystem { fn traverse_helper( &'a self, curr_cave: &'a str, n_finished: &mut usize, cave_visit_counts: &mut Map, can_visit_one_small_cave_twice: bool, has_visited_a_small_cave_twice: bool, ) { for next_cave in &self.edges[curr_cave] { if next_cave.name == \"end\" { *n_finished += 1; continue; } let this_dest_n_visits = cave_visit_counts.entry(next_cave.name).or_insert(0); let is_small_cave = next_cave.kind == CaveKind::Small; if is_small_cave && (*this_dest_n_visits >= 1 && (!can_visit_one_small_cave_twice || has_visited_a_small_cave_twice)) { continue; } *this_dest_n_visits += 1; let n_visits = *this_dest_n_visits; self.traverse_helper( next_cave.name, n_finished, cave_visit_counts, can_visit_one_small_cave_twice, has_visited_a_small_cave_twice || is_small_cave && n_visits >= 2, ); // \"un-visit\" this cave for the next loop iteration cave_visit_counts .entry(next_cave.name) .and_modify(|v| *v -= 1); } } fn traverse(&'a self, can_visit_one_small_cave_twice: bool) -> usize { let mut n_finished = 0; let mut cave_visit_counts = Map::new(); self.traverse_helper( \"start\", &mut n_finished, &mut cave_visit_counts, can_visit_one_small_cave_twice, false, ); n_finished } } fn ans_for_input(input: &str) -> Answer { let cave_system = CaveSystem::from_str(input).unwrap(); (12, (pt1(&cave_system), pt2(&cave_system))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(cave: &CaveSystem) -> usize { cave.traverse(false) } // end::pt1[] // tag::pt2[] fn pt2(cave: &CaveSystem) -> usize { cave.traverse(true) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input_1.txt\"), day: 12, ans: (10, 36)); test_input!(include_str!(\"sample_input_2.txt\"), day: 12, ans: (19, 103)); test_input!(include_str!(\"sample_input_3.txt\"), day: 12, ans: (226, 3509)); test_input!(include_str!(\"input.txt\"), day: 12, ans: (3738, 120_506)); } } In Part 1, we may only visit each small node at most once. Part 2 is slightly more relaxed; in addition to the paths visiting each small node at most once, valid paths now include those in which a single small node is visited a second time. But this wrinkle was already handled in the Setup section; we switch the behavior with a single boolean argument. // tag::setup[] use crate::Answer; use std::collections::BTreeMap as Map; #[derive(Debug, PartialEq, Eq, PartialOrd, Ord)] enum CaveKind { Big, Small, } #[derive(Debug, PartialEq, Eq, PartialOrd, Ord)] struct Cave { name: &'a str, kind: CaveKind, } impl Cave { fn new(name: &'a str) -> Self { let is_small = name.chars().map(|c| c.is_ascii_lowercase()).all(|b| b); let kind = if is_small { CaveKind::Small } else { CaveKind::Big }; Self { name, kind } } } #[derive(Debug)] struct CaveSystem { edges: Map>>, } impl CaveSystem { fn from_str(input: &'a str) -> Option { let mut edges = Map::new(); for line in input.lines() { let mut splat = line.split('-'); let left = splat.next()?; let right = splat.next()?; for (orig, dest) in [(left, right), (right, left)] { if orig != \"end\" && dest != \"start\" { edges .entry(orig) .or_insert_with(Vec::new) .push(Cave::new(dest)); } } } Some(Self { edges }) } } impl CaveSystem { fn traverse_helper( &'a self, curr_cave: &'a str, n_finished: &mut usize, cave_visit_counts: &mut Map, can_visit_one_small_cave_twice: bool, has_visited_a_small_cave_twice: bool, ) { for next_cave in &self.edges[curr_cave] { if next_cave.name == \"end\" { *n_finished += 1; continue; } let this_dest_n_visits = cave_visit_counts.entry(next_cave.name).or_insert(0); let is_small_cave = next_cave.kind == CaveKind::Small; if is_small_cave && (*this_dest_n_visits >= 1 && (!can_visit_one_small_cave_twice || has_visited_a_small_cave_twice)) { continue; } *this_dest_n_visits += 1; let n_visits = *this_dest_n_visits; self.traverse_helper( next_cave.name, n_finished, cave_visit_counts, can_visit_one_small_cave_twice, has_visited_a_small_cave_twice || is_small_cave && n_visits >= 2, ); // \"un-visit\" this cave for the next loop iteration cave_visit_counts .entry(next_cave.name) .and_modify(|v| *v -= 1); } } fn traverse(&'a self, can_visit_one_small_cave_twice: bool) -> usize { let mut n_finished = 0; let mut cave_visit_counts = Map::new(); self.traverse_helper( \"start\", &mut n_finished, &mut cave_visit_counts, can_visit_one_small_cave_twice, false, ); n_finished } } fn ans_for_input(input: &str) -> Answer { let cave_system = CaveSystem::from_str(input).unwrap(); (12, (pt1(&cave_system), pt2(&cave_system))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(cave: &CaveSystem) -> usize { cave.traverse(false) } // end::pt1[] // tag::pt2[] fn pt2(cave: &CaveSystem) -> usize { cave.traverse(true) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input_1.txt\"), day: 12, ans: (10, 36)); test_input!(include_str!(\"sample_input_2.txt\"), day: 12, ans: (19, 103)); test_input!(include_str!(\"sample_input_3.txt\"), day: 12, ans: (226, 3509)); test_input!(include_str!(\"input.txt\"), day: 12, ans: (3738, 120_506)); } }","title":"Day 12: Passage Pathing","component":"ROOT","version":"","name":"soln","url":"/src/day_12/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Parts 1 and 2","hash":"_parts_1_and_2","id":2}]},"14":{"id":14,"text":"Day #13 problem description │ Problem input This problem asks us track how dots on a transparent piece of paper migrate as that piece of paper is folded across vertical and horizontal lines. Throughout, the upper left corner of the page remains fixed in place; folds move the bottom right corner either up or to the left. It is a precondition that no dot will lie on a fold. When the page is reflected over the vertical line \\(x=a\\), one of two things will happen to the dot \\( (x,y)\\): If \\( (x,y)\\) is left of \\(x=a\\) (i.e., \\(x { X(T), Y(T), } impl Fold { fn from_str(s: &str) -> Option { let mut words = s.split_whitespace(); words.next()?; words.next()?; let fold_eqn = words.next()?; let mut eqn_sides = fold_eqn.split('='); let var = eqn_sides.next()?; let value = eqn_sides.next()?.parse::().ok()?; Some(match var { \"x\" => Self::X(value), \"y\" => Self::Y(value), _ => return None, }) } } #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Point(T, T); impl Point { fn folded(&self, across: &Fold) -> Self { let &Point(x, y) = self; match *across { Fold::X(fold_x) => { let new_x = if x > fold_x { fold_x - (x - fold_x) } else { x }; Point(new_x, y) } Fold::Y(fold_y) => { let new_y = if y > fold_y { fold_y - (y - fold_y) } else { y }; Point(x, new_y) } } } } #[derive(Clone, Debug)] struct Paper { dots: Set>, } impl Paper { fn from_dots(dots: impl IntoIterator>) -> Paper { let dots = dots.into_iter().collect(); Self { dots } } fn folded_across(&self, fold: &Fold) -> Paper { let mut dots = Set::new(); for p in &self.dots { dots.insert(p.folded(fold)); } Paper::from_dots(dots) } fn do_folds>>( &self, folds: impl Iterator, ) -> Paper { let mut paper = self.clone(); for fold in folds { let fold = fold.borrow(); paper = paper.folded_across(fold); } paper } } fn read_input(input: &str) -> Option, Vec>)> { let mut lines = input.lines(); let points = lines .by_ref() .take_while(|line| !line.trim().is_empty()) .map(|line| { let mut comps = line.split(','); let x = comps.next()?.parse::().ok()?; let y = comps.next()?.parse::().ok()?; Some(Point(x, y)) }) .collect::>>()?; let paper = Paper::::from_dots(points); let folds = lines.map(Fold::::from_str).collect::>>()?; Some((paper, folds)) } fn ans_for_input(input: &str) -> Answer { let (paper, folds) = read_input::(input).unwrap(); (13, (pt1(&paper, &folds[0]), pt2(&paper, folds.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(paper: &Paper, fold: &Fold) -> usize { paper.folded_across(fold).dots.len() } // end::pt1[] // tag::pt2[] impl Display for Paper { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let (max_x, max_y) = { let mut max_x = num::zero(); let mut max_y = num::zero(); for &Point(x, y) in &self.dots { if x > max_x { max_x = x; } if y > max_y { max_y = y; } } (max_x, max_y) }; for y in num::range_step_inclusive(num::zero(), max_y, num::one()) { for x in num::range_step_inclusive(num::zero(), max_x, num::one()) { f.write_str(if self.dots.contains(&Point(x, y)) { \"█\" // unicode \"full block\" 0x2588 } else { \" \" })?; } f.write_str(\"\\n\")?; } Ok(()) } } fn pt2>>( paper: &Paper, folds: impl Iterator, ) -> String { let ans = paper.do_folds(folds); println!(\"{}\", ans); ans.to_string() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { let (paper, folds) = read_input::(include_str!(\"sample_input.txt\")).unwrap(); assert_eq!(pt1(&paper, &folds[0]), 17); test_input!( include_str!(\"input.txt\"), day: 13, ans: ( 790, concat!( \"███ ██ █ █ ████ ███ ████ ██ ██ \\n\", \"█ █ █ █ █ █ █ █ █ █ █ █ █\\n\", \"█ █ █ ████ █ ███ ███ █ █ \\n\", \"███ █ ██ █ █ █ █ █ █ █ █ \\n\", \"█ █ █ █ █ █ █ █ █ █ █ █ █\\n\", \"█ ███ █ █ ████ ███ █ ██ ██ \\n\" ).to_owned() ) ); } } Part 1 has us perform a single fold. (Just one? No fun!) // tag::setup[] use crate::Answer; use num::{CheckedAdd, Integer}; use std::{collections::BTreeSet as Set, fmt::Display, str::FromStr}; #[derive(Copy, Clone)] enum Fold { X(T), Y(T), } impl Fold { fn from_str(s: &str) -> Option { let mut words = s.split_whitespace(); words.next()?; words.next()?; let fold_eqn = words.next()?; let mut eqn_sides = fold_eqn.split('='); let var = eqn_sides.next()?; let value = eqn_sides.next()?.parse::().ok()?; Some(match var { \"x\" => Self::X(value), \"y\" => Self::Y(value), _ => return None, }) } } #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Point(T, T); impl Point { fn folded(&self, across: &Fold) -> Self { let &Point(x, y) = self; match *across { Fold::X(fold_x) => { let new_x = if x > fold_x { fold_x - (x - fold_x) } else { x }; Point(new_x, y) } Fold::Y(fold_y) => { let new_y = if y > fold_y { fold_y - (y - fold_y) } else { y }; Point(x, new_y) } } } } #[derive(Clone, Debug)] struct Paper { dots: Set>, } impl Paper { fn from_dots(dots: impl IntoIterator>) -> Paper { let dots = dots.into_iter().collect(); Self { dots } } fn folded_across(&self, fold: &Fold) -> Paper { let mut dots = Set::new(); for p in &self.dots { dots.insert(p.folded(fold)); } Paper::from_dots(dots) } fn do_folds>>( &self, folds: impl Iterator, ) -> Paper { let mut paper = self.clone(); for fold in folds { let fold = fold.borrow(); paper = paper.folded_across(fold); } paper } } fn read_input(input: &str) -> Option, Vec>)> { let mut lines = input.lines(); let points = lines .by_ref() .take_while(|line| !line.trim().is_empty()) .map(|line| { let mut comps = line.split(','); let x = comps.next()?.parse::().ok()?; let y = comps.next()?.parse::().ok()?; Some(Point(x, y)) }) .collect::>>()?; let paper = Paper::::from_dots(points); let folds = lines.map(Fold::::from_str).collect::>>()?; Some((paper, folds)) } fn ans_for_input(input: &str) -> Answer { let (paper, folds) = read_input::(input).unwrap(); (13, (pt1(&paper, &folds[0]), pt2(&paper, folds.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(paper: &Paper, fold: &Fold) -> usize { paper.folded_across(fold).dots.len() } // end::pt1[] // tag::pt2[] impl Display for Paper { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let (max_x, max_y) = { let mut max_x = num::zero(); let mut max_y = num::zero(); for &Point(x, y) in &self.dots { if x > max_x { max_x = x; } if y > max_y { max_y = y; } } (max_x, max_y) }; for y in num::range_step_inclusive(num::zero(), max_y, num::one()) { for x in num::range_step_inclusive(num::zero(), max_x, num::one()) { f.write_str(if self.dots.contains(&Point(x, y)) { \"█\" // unicode \"full block\" 0x2588 } else { \" \" })?; } f.write_str(\"\\n\")?; } Ok(()) } } fn pt2>>( paper: &Paper, folds: impl Iterator, ) -> String { let ans = paper.do_folds(folds); println!(\"{}\", ans); ans.to_string() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { let (paper, folds) = read_input::(include_str!(\"sample_input.txt\")).unwrap(); assert_eq!(pt1(&paper, &folds[0]), 17); test_input!( include_str!(\"input.txt\"), day: 13, ans: ( 790, concat!( \"███ ██ █ █ ████ ███ ████ ██ ██ \\n\", \"█ █ █ █ █ █ █ █ █ █ █ █ █\\n\", \"█ █ █ ████ █ ███ ███ █ █ \\n\", \"███ █ ██ █ █ █ █ █ █ █ █ \\n\", \"█ █ █ █ █ █ █ █ █ █ █ █ █\\n\", \"█ ███ █ █ ████ ███ █ ██ ██ \\n\" ).to_owned() ) ); } } Part 2 has us perform all of the folds, and then read the resulting arrangement of dots as a password containing eight capital capital letters. // tag::setup[] use crate::Answer; use num::{CheckedAdd, Integer}; use std::{collections::BTreeSet as Set, fmt::Display, str::FromStr}; #[derive(Copy, Clone)] enum Fold { X(T), Y(T), } impl Fold { fn from_str(s: &str) -> Option { let mut words = s.split_whitespace(); words.next()?; words.next()?; let fold_eqn = words.next()?; let mut eqn_sides = fold_eqn.split('='); let var = eqn_sides.next()?; let value = eqn_sides.next()?.parse::().ok()?; Some(match var { \"x\" => Self::X(value), \"y\" => Self::Y(value), _ => return None, }) } } #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Point(T, T); impl Point { fn folded(&self, across: &Fold) -> Self { let &Point(x, y) = self; match *across { Fold::X(fold_x) => { let new_x = if x > fold_x { fold_x - (x - fold_x) } else { x }; Point(new_x, y) } Fold::Y(fold_y) => { let new_y = if y > fold_y { fold_y - (y - fold_y) } else { y }; Point(x, new_y) } } } } #[derive(Clone, Debug)] struct Paper { dots: Set>, } impl Paper { fn from_dots(dots: impl IntoIterator>) -> Paper { let dots = dots.into_iter().collect(); Self { dots } } fn folded_across(&self, fold: &Fold) -> Paper { let mut dots = Set::new(); for p in &self.dots { dots.insert(p.folded(fold)); } Paper::from_dots(dots) } fn do_folds>>( &self, folds: impl Iterator, ) -> Paper { let mut paper = self.clone(); for fold in folds { let fold = fold.borrow(); paper = paper.folded_across(fold); } paper } } fn read_input(input: &str) -> Option, Vec>)> { let mut lines = input.lines(); let points = lines .by_ref() .take_while(|line| !line.trim().is_empty()) .map(|line| { let mut comps = line.split(','); let x = comps.next()?.parse::().ok()?; let y = comps.next()?.parse::().ok()?; Some(Point(x, y)) }) .collect::>>()?; let paper = Paper::::from_dots(points); let folds = lines.map(Fold::::from_str).collect::>>()?; Some((paper, folds)) } fn ans_for_input(input: &str) -> Answer { let (paper, folds) = read_input::(input).unwrap(); (13, (pt1(&paper, &folds[0]), pt2(&paper, folds.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(paper: &Paper, fold: &Fold) -> usize { paper.folded_across(fold).dots.len() } // end::pt1[] // tag::pt2[] impl Display for Paper { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let (max_x, max_y) = { let mut max_x = num::zero(); let mut max_y = num::zero(); for &Point(x, y) in &self.dots { if x > max_x { max_x = x; } if y > max_y { max_y = y; } } (max_x, max_y) }; for y in num::range_step_inclusive(num::zero(), max_y, num::one()) { for x in num::range_step_inclusive(num::zero(), max_x, num::one()) { f.write_str(if self.dots.contains(&Point(x, y)) { \"█\" // unicode \"full block\" 0x2588 } else { \" \" })?; } f.write_str(\"\\n\")?; } Ok(()) } } fn pt2>>( paper: &Paper, folds: impl Iterator, ) -> String { let ans = paper.do_folds(folds); println!(\"{}\", ans); ans.to_string() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { let (paper, folds) = read_input::(include_str!(\"sample_input.txt\")).unwrap(); assert_eq!(pt1(&paper, &folds[0]), 17); test_input!( include_str!(\"input.txt\"), day: 13, ans: ( 790, concat!( \"███ ██ █ █ ████ ███ ████ ██ ██ \\n\", \"█ █ █ █ █ █ █ █ █ █ █ █ █\\n\", \"█ █ █ ████ █ ███ ███ █ █ \\n\", \"███ █ ██ █ █ █ █ █ █ █ █ \\n\", \"█ █ █ █ █ █ █ █ █ █ █ █ █\\n\", \"█ ███ █ █ ████ ███ █ ██ ██ \\n\" ).to_owned() ) ); } } For once, the input is actually interesting! It’s not enough to just “get the answer” (say, the positions of the dots at the end of the folding procedure); we have to print them out too so that we can read them. Here was my output: PGHZBFJC. ███ ██ █ █ ████ ███ ████ ██ ██ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ ████ █ ███ ███ █ █ ███ █ ██ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ █ ███ █ █ ████ ███ █ ██ ██","title":"Day 13: Transparent Origami","component":"ROOT","version":"","name":"soln","url":"/src/day_13/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"15":{"id":15,"text":"Day #14 problem description │ Problem input This problem asks us to perform a sequence of transformations to a starting string and then compute the counts of characters in the resulting string. Specifically, we are given a map from pairs of characters to single characters. Each generation, each pair of characters in the original string is to have its entry in this map (if it exists) inserted between the two characters. This runs on a specified starting string for a specified number of generations, producing a final string. My initial attempt involved actually building the string at each stage. Unfortunately, because the string approximately doubles in length in each step, it’s computationally infeasible to generate the string the requested 40 generations out, nor would we be able to store it in memory (240 is around one trillion). The right way to do this problem is to maintain a tally of counts of each pair (c1, c2) of characters in the string. Each generation, we run through the pairs, and if the mapping contains a character c3 to insert, then we remove key (c1, c2) and assign its tally to keys (c1, c3) and (c3, c2). This doesn’t tell us what the resulting string is, but thankfully the problem doesn’t ask us about the string per se; it only asks for character counts within the string. To count the number of times a character c appears in the string, we simply note that it is counted twice, once for each pair it is the first character of and once for each pair it is the second character of. So we just add up the number of times we see it in a pair and then divide by 2, right? Wrong! The first (respectively, last) character of the string is actually only counted once because it is only the first (respectively, second) character of one pair of characters, not two. The way we model this is maintain a tally not just of character counts, but of the positions of those characters. Our tally now assigns counts to triples (c1, c2, pos0) where pos0 is one of “start”, “middle”, and “end”. When we insert c3 between c1 and c2, we obtain (c1, c3, pos1) and (c3, c2, pos2), where: pos1 is either “start” or “middle”; it is “start” if and only if pos0 was “start”, and pos2 is either “end” or “middle”; it is “end” if and only if pos0 was “end”. Now, only the characters occurring in the “middle” are double-counted, so the number of times a character appears in the final string is the number of times it occurred in a character pair in the “start” or “end” positions, plus half the number of times it occurred in a “middle” character pair. To make the counting easier when working with integers and floored division, we double the “start” and “end” character counts, add them to the “middle” character counts, and then halve everything at the end. As you might have guessed, my first attempt at this problem did not keep track of pairs’ positions and so was plagued by an off-by-one error which only arose for specific inputs. (I believe it had to do with whether the final string started and ended with the same character, but I didn’t bother generating test cases to check this.) My first submission was too large, so I subtracted 1 from it and re-submitted and got it correct. This was the first problem of this year’s Advent of Code that I thought it was feasible for someone to arrive at the right answer with buggy code and some guesswork. // tag::setup[] use crate::Answer; use std::collections::BTreeMap as Map; #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)] enum Position { Start, Middle, End, } #[derive(Debug)] struct Polymer { template: String, mapping: Map, } impl Polymer { fn from_str(s: &str) -> Option { let mut lines = s.lines(); let template = lines.next()?.to_owned(); lines.next()?; let mut mapping = Map::new(); for line in lines { let mut splat = line.split(\" -> \"); let mut outer_chars = splat.next()?.chars(); let left = outer_chars.next()?; let right = outer_chars.next()?; let inner = splat.next()?.chars().next()?; mapping.insert((left, right), inner); } Some(Polymer { template, mapping }) } fn get_initial_char_pair_counts(&self) -> Map { use Position::*; let mut ans = Map::new(); // Iterate over adjacent pairs of chars. The last index iterated is `n_pairs - 1` // with `n_pairs == self.template.len() - 1` for (i, (c1, c2)) in self .template .chars() .zip(self.template.chars().skip(1)) .enumerate() { let position = if i == 0 { Start } else if i == self.template.len() - 2 { End } else { Middle }; *ans.entry((c1, c2, position)).or_default() += 1; } ans } fn apply_n_times(&self, n: usize) -> Map { use Position::*; let mut pair_counts = self.get_initial_char_pair_counts(); for _ in 0..n { let pair_counts_vec = pair_counts .iter() .filter_map(|(&k, &v)| if v > 0 { Some((k, v)) } else { None }) .collect::>(); for (key, count) in pair_counts_vec { let (c1, c2, position) = key; if let Some(&c) = self.mapping.get(&(c1, c2)) { let first_pos = match position { Start => Start, _ => Middle, }; let second_pos = match position { End => End, _ => Middle, }; *pair_counts.entry((c1, c, first_pos)).or_default() += count; *pair_counts.entry((c, c2, second_pos)).or_default() += count; *pair_counts.get_mut(&key).unwrap() -= count; } } } pair_counts } } fn get_ans(polymer: &Polymer, n: usize) -> usize { use Position::*; let char_pair_counts = polymer.apply_n_times(n); let char_counts = { let mut char_counts_2x = Map::new(); for ((c1, c2, position), count) in char_pair_counts { let c1_multiplier = match position { Start => 2, _ => 1, }; let c2_multiplier = match position { End => 2, _ => 1, }; for (c, mult) in [(c1, c1_multiplier), (c2, c2_multiplier)] { *char_counts_2x.entry(c).or_insert(0) += mult * count; } } char_counts_2x .into_iter() .map(|(k, v)| (k, v / 2)) .collect::>() }; let mut max_count = 0; let mut min_count = usize::MAX; for &count in char_counts.values() { if count max_count { max_count = count; } } max_count - min_count } fn ans_for_input(input: &str) -> Answer { let polymer = Polymer::from_str(input).unwrap(); (14, (pt1(&polymer), pt2(&polymer))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(polymer: &Polymer) -> usize { get_ans(polymer, 10) } // end::pt1[] // tag::pt2[] fn pt2(polymer: &Polymer) -> usize { get_ans(polymer, 40) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 14, ans: (1588, 2_188_189_693_529)); test_input!(include_str!(\"input.txt\"), day: 14, ans: (2937, 3_390_034_818_249)); } } // tag::setup[] use crate::Answer; use std::collections::BTreeMap as Map; #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)] enum Position { Start, Middle, End, } #[derive(Debug)] struct Polymer { template: String, mapping: Map, } impl Polymer { fn from_str(s: &str) -> Option { let mut lines = s.lines(); let template = lines.next()?.to_owned(); lines.next()?; let mut mapping = Map::new(); for line in lines { let mut splat = line.split(\" -> \"); let mut outer_chars = splat.next()?.chars(); let left = outer_chars.next()?; let right = outer_chars.next()?; let inner = splat.next()?.chars().next()?; mapping.insert((left, right), inner); } Some(Polymer { template, mapping }) } fn get_initial_char_pair_counts(&self) -> Map { use Position::*; let mut ans = Map::new(); // Iterate over adjacent pairs of chars. The last index iterated is `n_pairs - 1` // with `n_pairs == self.template.len() - 1` for (i, (c1, c2)) in self .template .chars() .zip(self.template.chars().skip(1)) .enumerate() { let position = if i == 0 { Start } else if i == self.template.len() - 2 { End } else { Middle }; *ans.entry((c1, c2, position)).or_default() += 1; } ans } fn apply_n_times(&self, n: usize) -> Map { use Position::*; let mut pair_counts = self.get_initial_char_pair_counts(); for _ in 0..n { let pair_counts_vec = pair_counts .iter() .filter_map(|(&k, &v)| if v > 0 { Some((k, v)) } else { None }) .collect::>(); for (key, count) in pair_counts_vec { let (c1, c2, position) = key; if let Some(&c) = self.mapping.get(&(c1, c2)) { let first_pos = match position { Start => Start, _ => Middle, }; let second_pos = match position { End => End, _ => Middle, }; *pair_counts.entry((c1, c, first_pos)).or_default() += count; *pair_counts.entry((c, c2, second_pos)).or_default() += count; *pair_counts.get_mut(&key).unwrap() -= count; } } } pair_counts } } fn get_ans(polymer: &Polymer, n: usize) -> usize { use Position::*; let char_pair_counts = polymer.apply_n_times(n); let char_counts = { let mut char_counts_2x = Map::new(); for ((c1, c2, position), count) in char_pair_counts { let c1_multiplier = match position { Start => 2, _ => 1, }; let c2_multiplier = match position { End => 2, _ => 1, }; for (c, mult) in [(c1, c1_multiplier), (c2, c2_multiplier)] { *char_counts_2x.entry(c).or_insert(0) += mult * count; } } char_counts_2x .into_iter() .map(|(k, v)| (k, v / 2)) .collect::>() }; let mut max_count = 0; let mut min_count = usize::MAX; for &count in char_counts.values() { if count max_count { max_count = count; } } max_count - min_count } fn ans_for_input(input: &str) -> Answer { let polymer = Polymer::from_str(input).unwrap(); (14, (pt1(&polymer), pt2(&polymer))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(polymer: &Polymer) -> usize { get_ans(polymer, 10) } // end::pt1[] // tag::pt2[] fn pt2(polymer: &Polymer) -> usize { get_ans(polymer, 40) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 14, ans: (1588, 2_188_189_693_529)); test_input!(include_str!(\"input.txt\"), day: 14, ans: (2937, 3_390_034_818_249)); } }","title":"Day 14: Extended Polymerization","component":"ROOT","version":"","name":"soln","url":"/src/day_14/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Parts 1 and 2","hash":"_parts_1_and_2","id":2}]},"16":{"id":16,"text":"Day #15 problem description │ Problem input Given a grid of numbers, this problem asks us to find the path from the grid’s top left corner to its bottom right corner that minimizes the sum of all numbers used in the path, which we will call the path’s cost. This is a classic CS problem which can be solved with the A* Algorithm. My initial solution used a (max-) priority queue to choose the next node to examine, with priority equal to the (negative of the) total cost of the path up to that node. While this solution worked, it took an inordinate amount of time on the larger input, which was 500×500. (I suspect that this was due to the fact that the implementation of that priority queue uses a HashMap instead of a (perhaps) more optimal structure such as a BTreeMap. I also didn’t really feel like seeing if I could speed it up with a faster hasher. And I definitely didn’t want to implement my own priority queue with a BTreeMap instead.) Despite being theoretically suboptimal, my second solution performed much faster. This new solution was simply to maintain a grid of tentative costs to reach each number on the grid. This grid of tentative costs was initially set to u32::MAX, except for the top left corner which was set to 0. On each iteration, for each node \\(P\\) in the grid, we examine \\(P\\)’s four neighbors. If the cost to reach a neighbor through \\(P\\) is cheaper than the neighbor’s current tentative cost, we replace the latter cost with the former cost. We repeat this process until no modifications are made to any tentative cost, at which point the answer is simply the cost of reaching the bottom right corner. // tag::setup[] use crate::Answer; use ndarray::prelude::*; type Cost = u32; type Grid = Array2; type Coords = (usize, usize); fn read_input(input: &str) -> Option { let mut lines = input.lines(); let mut grid = vec![]; let first_line = lines.next()?; for c in first_line.chars() { grid.push(c.to_digit(10)? as Cost); } let n_cols = grid.len(); for line in lines { for c in line.chars() { grid.push(c.to_digit(10)? as Cost); } } let n_rows = grid.len() / n_cols; assert_eq!(n_rows * n_cols, grid.len()); Array2::from_shape_vec((n_rows, n_cols), grid).ok() } enum Direction { N, S, E, W, } impl Direction { fn stepping_from(&self, grid: &Grid, (from_row, from_col): Coords) -> Option { use Direction::*; let (min_row, min_col) = (0, 0); let (n_rows, n_cols) = grid.dim(); let max_row = n_rows - 1; let max_col = n_cols - 1; let new_row = match self { N if from_row == min_row => return None, N => from_row - 1, S if from_row == max_row => return None, S => from_row + 1, _ => from_row, }; let new_col = match self { W if from_col == min_col => return None, W => from_col - 1, E if from_col == max_col => return None, E => from_col + 1, _ => from_col, }; Some((new_row, new_col)) } } fn traversal_cost(entry_costs: &Grid) -> Cost { use Direction::*; let (n_rows, n_cols) = entry_costs.dim(); let max_row = n_rows - 1; let max_col = n_cols - 1; let mut net_travel_costs = Grid::from_shape_simple_fn((n_rows, n_cols), || Cost::MAX); net_travel_costs[(0, 0)] = 0; let max_dist = max_row + max_col; loop { let mut did_modify = false; for dist in 0..=max_dist { let r_min = if dist nghbr_coords, None => continue, }; let net_cost_to_travel_to_nghbr_thru_here = net_cost_to_travel_here + entry_costs[nghbr_coords]; if net_cost_to_travel_to_nghbr_thru_here Answer { let grid = read_input(input).unwrap(); (15, (pt1(&grid), pt2(&grid))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(grid: &Grid) -> Cost { traversal_cost(grid) } // end::pt1[] // tag::pt2[] fn expand_grid(grid: &Grid, k: usize) -> Grid { let (n_rows, n_cols) = grid.dim(); let mut new_grid = Array2::from_shape_simple_fn((k * n_rows, k * n_cols), || 0); // Arrays are in row major order, so that's the order we iterate in (for cache-friendliness) for outer_r in 0..k { for inner_r in 0..n_rows { for outer_c in 0..k { for inner_c in 0..n_cols { let old_cost = grid[(inner_r, inner_c)]; let d_cost = Cost::try_from(outer_r + outer_c).unwrap(); let new_cost = (old_cost + d_cost - 1) % 9 + 1; let new_grid_r = outer_r * n_rows + inner_r; let new_grid_c = outer_c * n_cols + inner_c; new_grid[(new_grid_r, new_grid_c)] = new_cost; } } } } new_grid } fn pt2(grid: &Grid) -> Cost { let grid = expand_grid(grid, 5); traversal_cost(&grid) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 15, ans: (40, 315)); test_input!(include_str!(\"input.txt\"), day: 15, ans: (739, 3040)); } } // tag::setup[] use crate::Answer; use ndarray::prelude::*; type Cost = u32; type Grid = Array2; type Coords = (usize, usize); fn read_input(input: &str) -> Option { let mut lines = input.lines(); let mut grid = vec![]; let first_line = lines.next()?; for c in first_line.chars() { grid.push(c.to_digit(10)? as Cost); } let n_cols = grid.len(); for line in lines { for c in line.chars() { grid.push(c.to_digit(10)? as Cost); } } let n_rows = grid.len() / n_cols; assert_eq!(n_rows * n_cols, grid.len()); Array2::from_shape_vec((n_rows, n_cols), grid).ok() } enum Direction { N, S, E, W, } impl Direction { fn stepping_from(&self, grid: &Grid, (from_row, from_col): Coords) -> Option { use Direction::*; let (min_row, min_col) = (0, 0); let (n_rows, n_cols) = grid.dim(); let max_row = n_rows - 1; let max_col = n_cols - 1; let new_row = match self { N if from_row == min_row => return None, N => from_row - 1, S if from_row == max_row => return None, S => from_row + 1, _ => from_row, }; let new_col = match self { W if from_col == min_col => return None, W => from_col - 1, E if from_col == max_col => return None, E => from_col + 1, _ => from_col, }; Some((new_row, new_col)) } } fn traversal_cost(entry_costs: &Grid) -> Cost { use Direction::*; let (n_rows, n_cols) = entry_costs.dim(); let max_row = n_rows - 1; let max_col = n_cols - 1; let mut net_travel_costs = Grid::from_shape_simple_fn((n_rows, n_cols), || Cost::MAX); net_travel_costs[(0, 0)] = 0; let max_dist = max_row + max_col; loop { let mut did_modify = false; for dist in 0..=max_dist { let r_min = if dist nghbr_coords, None => continue, }; let net_cost_to_travel_to_nghbr_thru_here = net_cost_to_travel_here + entry_costs[nghbr_coords]; if net_cost_to_travel_to_nghbr_thru_here Answer { let grid = read_input(input).unwrap(); (15, (pt1(&grid), pt2(&grid))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(grid: &Grid) -> Cost { traversal_cost(grid) } // end::pt1[] // tag::pt2[] fn expand_grid(grid: &Grid, k: usize) -> Grid { let (n_rows, n_cols) = grid.dim(); let mut new_grid = Array2::from_shape_simple_fn((k * n_rows, k * n_cols), || 0); // Arrays are in row major order, so that's the order we iterate in (for cache-friendliness) for outer_r in 0..k { for inner_r in 0..n_rows { for outer_c in 0..k { for inner_c in 0..n_cols { let old_cost = grid[(inner_r, inner_c)]; let d_cost = Cost::try_from(outer_r + outer_c).unwrap(); let new_cost = (old_cost + d_cost - 1) % 9 + 1; let new_grid_r = outer_r * n_rows + inner_r; let new_grid_c = outer_c * n_cols + inner_c; new_grid[(new_grid_r, new_grid_c)] = new_cost; } } } } new_grid } fn pt2(grid: &Grid) -> Cost { let grid = expand_grid(grid, 5); traversal_cost(&grid) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 15, ans: (40, 315)); test_input!(include_str!(\"input.txt\"), day: 15, ans: (739, 3040)); } } Part 2 asked us not just to traverse the grid, but to construct a larger grid to use as our input, which was formed by concatenating modified copies of Part 1’s input. This falls under “boring array manipulation”, so I won’t discuss it further. // tag::setup[] use crate::Answer; use ndarray::prelude::*; type Cost = u32; type Grid = Array2; type Coords = (usize, usize); fn read_input(input: &str) -> Option { let mut lines = input.lines(); let mut grid = vec![]; let first_line = lines.next()?; for c in first_line.chars() { grid.push(c.to_digit(10)? as Cost); } let n_cols = grid.len(); for line in lines { for c in line.chars() { grid.push(c.to_digit(10)? as Cost); } } let n_rows = grid.len() / n_cols; assert_eq!(n_rows * n_cols, grid.len()); Array2::from_shape_vec((n_rows, n_cols), grid).ok() } enum Direction { N, S, E, W, } impl Direction { fn stepping_from(&self, grid: &Grid, (from_row, from_col): Coords) -> Option { use Direction::*; let (min_row, min_col) = (0, 0); let (n_rows, n_cols) = grid.dim(); let max_row = n_rows - 1; let max_col = n_cols - 1; let new_row = match self { N if from_row == min_row => return None, N => from_row - 1, S if from_row == max_row => return None, S => from_row + 1, _ => from_row, }; let new_col = match self { W if from_col == min_col => return None, W => from_col - 1, E if from_col == max_col => return None, E => from_col + 1, _ => from_col, }; Some((new_row, new_col)) } } fn traversal_cost(entry_costs: &Grid) -> Cost { use Direction::*; let (n_rows, n_cols) = entry_costs.dim(); let max_row = n_rows - 1; let max_col = n_cols - 1; let mut net_travel_costs = Grid::from_shape_simple_fn((n_rows, n_cols), || Cost::MAX); net_travel_costs[(0, 0)] = 0; let max_dist = max_row + max_col; loop { let mut did_modify = false; for dist in 0..=max_dist { let r_min = if dist nghbr_coords, None => continue, }; let net_cost_to_travel_to_nghbr_thru_here = net_cost_to_travel_here + entry_costs[nghbr_coords]; if net_cost_to_travel_to_nghbr_thru_here Answer { let grid = read_input(input).unwrap(); (15, (pt1(&grid), pt2(&grid))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(grid: &Grid) -> Cost { traversal_cost(grid) } // end::pt1[] // tag::pt2[] fn expand_grid(grid: &Grid, k: usize) -> Grid { let (n_rows, n_cols) = grid.dim(); let mut new_grid = Array2::from_shape_simple_fn((k * n_rows, k * n_cols), || 0); // Arrays are in row major order, so that's the order we iterate in (for cache-friendliness) for outer_r in 0..k { for inner_r in 0..n_rows { for outer_c in 0..k { for inner_c in 0..n_cols { let old_cost = grid[(inner_r, inner_c)]; let d_cost = Cost::try_from(outer_r + outer_c).unwrap(); let new_cost = (old_cost + d_cost - 1) % 9 + 1; let new_grid_r = outer_r * n_rows + inner_r; let new_grid_c = outer_c * n_cols + inner_c; new_grid[(new_grid_r, new_grid_c)] = new_cost; } } } } new_grid } fn pt2(grid: &Grid) -> Cost { let grid = expand_grid(grid, 5); traversal_cost(&grid) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"sample_input.txt\"), day: 15, ans: (40, 315)); test_input!(include_str!(\"input.txt\"), day: 15, ans: (739, 3040)); } }","title":"Day 15: Chiton","component":"ROOT","version":"","name":"soln","url":"/src/day_15/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"17":{"id":17,"text":"Day #16 problem description │ Problem input Dear lord, this problem was brutal. It consisted of roughly three parts: Parse a hex string into a binary string by parsing each hex character into a quartet — trivial (Part 1) Parse this binary string into a tree of packets according to rules set out in the problem statement — “easy” in the sense that I wrote up an almost correct solution in no time at all. Very very hard in the sense that it required precise bookkeeping and it took forever for me to get it all exactly correct. But from a theoretical standpoint it wasn’t really that hard. (Part 2) Evaluate the packet tree as an expression tree (more or less like parsing S-expressions) — easy. The main function here is Binary::as_packets. There’s a lot to unpack here, but roughly the algorithm is as follows: Maintain a cursor into the original data Maintain a stack of parse states, which consist of: The depth in the parse tree The length of remaining data for this packet. Packets tell us how much data they expect; when there isn’t any left, we head back up a level in the tree. So we have to track how much of their data we’ve consumed so far. This “amount of data” quantity comes in two flavors: Number of bits that the children comprise Number of direct children, i.e., number of child packets One tricky bit is that packets share bits-remaining with their children. In other words, if a child consumes some bits from the input, so have all of its ancestors that count their data in bits. (Packets that are expecting a fixed number of child packets are unaffected when their descendants consume data.) In either case, if the current packet has no more data remaining — 0 bits or 0 child packets — continue on to the next parse state on the stack. Looking at the data beginning at the cursor, parse the stream into a single packet. Advance the cursor the number of bits this packet consumed. If this packet was an operator, increment the depth, as its children will follow. Otherwise the depth remains unchanged. Push a new parse state onto the stack, containing the incremented depth and the length of remaining data for this packet. If this packet was the last of its parent’s children, decrement the depth. // tag::setup[] use crate::{utils::to_big_decimal, Answer}; use std::fmt::{Display, Write}; type Number = i64; struct Binary(Vec); impl Binary { fn from_hex(s: &str) -> Option { let mut binary = Vec::with_capacity(s.len() * 4); for c in s.trim().chars() { let n = c.to_digit(16)?; let digits = [3, 2, 1, 0usize].map(|place| ((1 ) -> std::fmt::Result { for &digit in &self.0 { let c = if digit { '1' } else { '0' }; f.write_char(c)?; } Ok(()) } } impl Binary { fn as_packets(&self) -> Vec { #[derive(Debug)] enum RemainingData { NBits(usize), NPackets(usize), } impl RemainingData { fn is_empty(&self) -> bool { matches!(self, RemainingData::NBits(0) | RemainingData::NPackets(0)) } } #[derive(Debug)] struct ParseState { depth: usize, remaining: RemainingData, } let mut packets = vec![]; let orig_data = &self.0; let header_length = 6; let mut cursor = 0; let mut stack = vec![ParseState { depth: 0, remaining: RemainingData::NPackets(1), }]; while let Some(parse_state) = stack.pop() { let ParseState { depth, remaining } = parse_state; if remaining.is_empty() { continue; } let packet_bits = &orig_data[cursor..]; let version_number = to_big_decimal(&packet_bits[0..3]); let kind_number = to_big_decimal(&packet_bits[3..6]); let data_bits = &packet_bits[header_length..]; let parent_packet_length = match remaining { RemainingData::NBits(n) => RemainingData::NBits(n), RemainingData::NPackets(n) => RemainingData::NPackets(n - 1), }; stack.push(ParseState { depth, remaining: parent_packet_length, }); let packet; let n_bits_consumed; match kind_number { 4 => { let chunk_size = 5; let mut bin_bits = vec![]; let mut n_chunks = 0; for chunk in data_bits.chunks_exact(5) { n_chunks += 1; bin_bits.extend_from_slice(&chunk[1..]); if !chunk[0] { break; } } let value = i64::try_from(to_big_decimal(bin_bits)).unwrap(); n_bits_consumed = header_length + n_chunks * chunk_size; packet = Packet { version_number, kind: PacketKind::Literal { value }, depth, }; } op => { let op_data_length; let n_bits_for_length; let length_type = data_bits[0]; if length_type { // length in packets n_bits_for_length = 12; let n_packets = usize::try_from(to_big_decimal(&data_bits[1..n_bits_for_length])) .unwrap(); op_data_length = RemainingData::NPackets(n_packets); } else { // length in bits n_bits_for_length = 16; let n_bits = usize::try_from(to_big_decimal(&data_bits[1..n_bits_for_length])) .unwrap(); op_data_length = RemainingData::NBits(n_bits); }; n_bits_consumed = header_length + n_bits_for_length; // A hack; we're going to subtract n_bits_consumed from this later // despite the fact that in theory we shouldn't (because the newly added // packet hasn't consumed any data yet), so we we pre-add n_bits_consumed // here so that when we subtract it later we end up with the right number // of bits let op_data_length = match op_data_length { RemainingData::NBits(n) => RemainingData::NBits(n + n_bits_consumed), rd @ RemainingData::NPackets(_) => rd, }; packet = Packet { version_number, kind: PacketKind::Operator { op: op.into() }, depth, }; stack.push(ParseState { depth: depth + 1, remaining: op_data_length, }); } }; cursor += n_bits_consumed; for ps in &mut stack { if let RemainingData::NBits(n) = &mut ps.remaining { if *n > 0 { // The hack above is to counteract this subtraction; if we just pushed // a RemainingData::NumBits, we won't actually have consumed any of // its input yet // // If our code has no bugs, and the input is trustworthy, this will // never underflow. *n -= n_bits_consumed; } } } packets.push(packet); } packets } } #[derive(Debug)] enum PacketKind { Literal { value: Number }, Operator { op: Operation }, // Defined in pt2 } #[derive(Debug)] struct Packet { version_number: u64, kind: PacketKind, depth: usize, } fn read_input(input: &str) -> Vec { let b = Binary::from_hex(input).unwrap(); b.as_packets() } fn ans_for_input(input: &str) -> Answer { let p = read_input(input); (16, (pt1(&p), pt2(&p).unwrap())).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(packets: &[Packet]) -> u64 { packets.iter().map(|packet| packet.version_number).sum() } // end::pt1[] // tag::pt2[] #[derive(Debug)] enum Reducer { Sum, Product, Min, Max, } impl Reducer { fn identity(&self) -> Number { use Reducer::*; match self { Sum => 0, Product => 1, Min => Number::MAX, Max => Number::MIN, } } fn combine(&self, x: Number, y: Number) -> Number { use Reducer::*; match self { Sum => x + y, Product => x * y, Min => x.min(y), Max => x.max(y), } } } #[derive(Debug)] enum Comparitor { Gt, Lt, Eq, } impl Comparitor { fn apply(&self, x: Number, y: Number) -> Number { use Comparitor::*; i64::from(match self { Gt => x > y, Lt => x x == y, }) } } #[derive(Debug)] enum Operation { Reduce(Reducer), Compare(Comparitor), } impl From for Operation { fn from(n: u64) -> Self { use Comparitor::*; use Operation::*; use Reducer::*; match n { 0 => Reduce(Sum), 1 => Reduce(Product), 2 => Reduce(Min), 3 => Reduce(Max), 5 => Compare(Gt), 6 => Compare(Lt), 7 => Compare(Eq), _ => unreachable!(), } } } fn pt2(packets: &[Packet]) -> Option { struct Arg { depth: usize, value: Number, } let mut arg_stack = vec![]; for Packet { kind: packet_kind, depth: packet_depth, .. } in packets.iter().rev() { let packet_depth = *packet_depth; match packet_kind { &PacketKind::Literal { value } => arg_stack.push(Arg { depth: packet_depth, value, }), PacketKind::Operator { op } => { use Operation::*; let value = match op { Reduce(reducer) => { let mut result = reducer.identity(); while let Some(arg @ Arg { depth, value }) = arg_stack.pop() { if depth { let Arg { value: first, .. } = arg_stack.pop()?; let Arg { value: second, .. } = arg_stack.pop()?; comparitor.apply(first, second) } }; arg_stack.push(Arg { depth: packet_depth, value, }); } } } Some(arg_stack.first()?.value) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { #[track_caller] fn test_pt1(in_str: &str, pt1_val: u64) { test_input!(&read_input(in_str), pt1: pt1_val); } #[track_caller] fn test_pt2(in_str: &str, pt2_val: Number) { test_input!(&read_input(in_str), pt2: Some(pt2_val)); } // pt1 only test_pt1(\"D2FE28\", 6); test_pt1(\"8A004A801A8002F478\", 16); test_pt1(\"620080001611562C8802118E34\", 12); test_pt1(\"C0015000016115A2E0802F182340\", 23); test_pt1(\"A0016C880162017C3686B18A3D4780\", 31); test_pt1(include_str!(\"input.txt\"), 927); // pt2 only test_pt2(\"D2FE28\", 2021); test_pt2(\"C200B40A82\", 3); test_pt2(\"04005AC33890\", 54); test_pt2(\"880086C3E88112\", 7); test_pt2(\"CE00C43D881120\", 9); test_pt2(\"D8005AC2A8F0\", 1); test_pt2(\"F600BC2D8F\", 0); test_pt2(\"9C005AC2F8F0\", 0); test_pt2(\"9C0141080250320F1802104A08\", 1); } } Part 1 just asks us to compute some summary data of all the packets in the parse tree. As long as we have the right packets (regardless of their depths) we’ll get the right answer. // tag::setup[] use crate::{utils::to_big_decimal, Answer}; use std::fmt::{Display, Write}; type Number = i64; struct Binary(Vec); impl Binary { fn from_hex(s: &str) -> Option { let mut binary = Vec::with_capacity(s.len() * 4); for c in s.trim().chars() { let n = c.to_digit(16)?; let digits = [3, 2, 1, 0usize].map(|place| ((1 ) -> std::fmt::Result { for &digit in &self.0 { let c = if digit { '1' } else { '0' }; f.write_char(c)?; } Ok(()) } } impl Binary { fn as_packets(&self) -> Vec { #[derive(Debug)] enum RemainingData { NBits(usize), NPackets(usize), } impl RemainingData { fn is_empty(&self) -> bool { matches!(self, RemainingData::NBits(0) | RemainingData::NPackets(0)) } } #[derive(Debug)] struct ParseState { depth: usize, remaining: RemainingData, } let mut packets = vec![]; let orig_data = &self.0; let header_length = 6; let mut cursor = 0; let mut stack = vec![ParseState { depth: 0, remaining: RemainingData::NPackets(1), }]; while let Some(parse_state) = stack.pop() { let ParseState { depth, remaining } = parse_state; if remaining.is_empty() { continue; } let packet_bits = &orig_data[cursor..]; let version_number = to_big_decimal(&packet_bits[0..3]); let kind_number = to_big_decimal(&packet_bits[3..6]); let data_bits = &packet_bits[header_length..]; let parent_packet_length = match remaining { RemainingData::NBits(n) => RemainingData::NBits(n), RemainingData::NPackets(n) => RemainingData::NPackets(n - 1), }; stack.push(ParseState { depth, remaining: parent_packet_length, }); let packet; let n_bits_consumed; match kind_number { 4 => { let chunk_size = 5; let mut bin_bits = vec![]; let mut n_chunks = 0; for chunk in data_bits.chunks_exact(5) { n_chunks += 1; bin_bits.extend_from_slice(&chunk[1..]); if !chunk[0] { break; } } let value = i64::try_from(to_big_decimal(bin_bits)).unwrap(); n_bits_consumed = header_length + n_chunks * chunk_size; packet = Packet { version_number, kind: PacketKind::Literal { value }, depth, }; } op => { let op_data_length; let n_bits_for_length; let length_type = data_bits[0]; if length_type { // length in packets n_bits_for_length = 12; let n_packets = usize::try_from(to_big_decimal(&data_bits[1..n_bits_for_length])) .unwrap(); op_data_length = RemainingData::NPackets(n_packets); } else { // length in bits n_bits_for_length = 16; let n_bits = usize::try_from(to_big_decimal(&data_bits[1..n_bits_for_length])) .unwrap(); op_data_length = RemainingData::NBits(n_bits); }; n_bits_consumed = header_length + n_bits_for_length; // A hack; we're going to subtract n_bits_consumed from this later // despite the fact that in theory we shouldn't (because the newly added // packet hasn't consumed any data yet), so we we pre-add n_bits_consumed // here so that when we subtract it later we end up with the right number // of bits let op_data_length = match op_data_length { RemainingData::NBits(n) => RemainingData::NBits(n + n_bits_consumed), rd @ RemainingData::NPackets(_) => rd, }; packet = Packet { version_number, kind: PacketKind::Operator { op: op.into() }, depth, }; stack.push(ParseState { depth: depth + 1, remaining: op_data_length, }); } }; cursor += n_bits_consumed; for ps in &mut stack { if let RemainingData::NBits(n) = &mut ps.remaining { if *n > 0 { // The hack above is to counteract this subtraction; if we just pushed // a RemainingData::NumBits, we won't actually have consumed any of // its input yet // // If our code has no bugs, and the input is trustworthy, this will // never underflow. *n -= n_bits_consumed; } } } packets.push(packet); } packets } } #[derive(Debug)] enum PacketKind { Literal { value: Number }, Operator { op: Operation }, // Defined in pt2 } #[derive(Debug)] struct Packet { version_number: u64, kind: PacketKind, depth: usize, } fn read_input(input: &str) -> Vec { let b = Binary::from_hex(input).unwrap(); b.as_packets() } fn ans_for_input(input: &str) -> Answer { let p = read_input(input); (16, (pt1(&p), pt2(&p).unwrap())).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(packets: &[Packet]) -> u64 { packets.iter().map(|packet| packet.version_number).sum() } // end::pt1[] // tag::pt2[] #[derive(Debug)] enum Reducer { Sum, Product, Min, Max, } impl Reducer { fn identity(&self) -> Number { use Reducer::*; match self { Sum => 0, Product => 1, Min => Number::MAX, Max => Number::MIN, } } fn combine(&self, x: Number, y: Number) -> Number { use Reducer::*; match self { Sum => x + y, Product => x * y, Min => x.min(y), Max => x.max(y), } } } #[derive(Debug)] enum Comparitor { Gt, Lt, Eq, } impl Comparitor { fn apply(&self, x: Number, y: Number) -> Number { use Comparitor::*; i64::from(match self { Gt => x > y, Lt => x x == y, }) } } #[derive(Debug)] enum Operation { Reduce(Reducer), Compare(Comparitor), } impl From for Operation { fn from(n: u64) -> Self { use Comparitor::*; use Operation::*; use Reducer::*; match n { 0 => Reduce(Sum), 1 => Reduce(Product), 2 => Reduce(Min), 3 => Reduce(Max), 5 => Compare(Gt), 6 => Compare(Lt), 7 => Compare(Eq), _ => unreachable!(), } } } fn pt2(packets: &[Packet]) -> Option { struct Arg { depth: usize, value: Number, } let mut arg_stack = vec![]; for Packet { kind: packet_kind, depth: packet_depth, .. } in packets.iter().rev() { let packet_depth = *packet_depth; match packet_kind { &PacketKind::Literal { value } => arg_stack.push(Arg { depth: packet_depth, value, }), PacketKind::Operator { op } => { use Operation::*; let value = match op { Reduce(reducer) => { let mut result = reducer.identity(); while let Some(arg @ Arg { depth, value }) = arg_stack.pop() { if depth { let Arg { value: first, .. } = arg_stack.pop()?; let Arg { value: second, .. } = arg_stack.pop()?; comparitor.apply(first, second) } }; arg_stack.push(Arg { depth: packet_depth, value, }); } } } Some(arg_stack.first()?.value) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { #[track_caller] fn test_pt1(in_str: &str, pt1_val: u64) { test_input!(&read_input(in_str), pt1: pt1_val); } #[track_caller] fn test_pt2(in_str: &str, pt2_val: Number) { test_input!(&read_input(in_str), pt2: Some(pt2_val)); } // pt1 only test_pt1(\"D2FE28\", 6); test_pt1(\"8A004A801A8002F478\", 16); test_pt1(\"620080001611562C8802118E34\", 12); test_pt1(\"C0015000016115A2E0802F182340\", 23); test_pt1(\"A0016C880162017C3686B18A3D4780\", 31); test_pt1(include_str!(\"input.txt\"), 927); // pt2 only test_pt2(\"D2FE28\", 2021); test_pt2(\"C200B40A82\", 3); test_pt2(\"04005AC33890\", 54); test_pt2(\"880086C3E88112\", 7); test_pt2(\"CE00C43D881120\", 9); test_pt2(\"D8005AC2A8F0\", 1); test_pt2(\"F600BC2D8F\", 0); test_pt2(\"9C005AC2F8F0\", 0); test_pt2(\"9C0141080250320F1802104A08\", 1); } } Part 2 asks us to actually evaluate the packet tree as a tree of an expressions, akin to S-expressions. While this wasn’t hard, one challenge was to implement it without code duplication. The way I achieved this was to split the operators into two families, Reducers (+, *, min, and max) and Operatorss (≤, ==, ≥) which essentially comprise their own interfaces that specify how they should be applied to values in the stack. // tag::setup[] use crate::{utils::to_big_decimal, Answer}; use std::fmt::{Display, Write}; type Number = i64; struct Binary(Vec); impl Binary { fn from_hex(s: &str) -> Option { let mut binary = Vec::with_capacity(s.len() * 4); for c in s.trim().chars() { let n = c.to_digit(16)?; let digits = [3, 2, 1, 0usize].map(|place| ((1 ) -> std::fmt::Result { for &digit in &self.0 { let c = if digit { '1' } else { '0' }; f.write_char(c)?; } Ok(()) } } impl Binary { fn as_packets(&self) -> Vec { #[derive(Debug)] enum RemainingData { NBits(usize), NPackets(usize), } impl RemainingData { fn is_empty(&self) -> bool { matches!(self, RemainingData::NBits(0) | RemainingData::NPackets(0)) } } #[derive(Debug)] struct ParseState { depth: usize, remaining: RemainingData, } let mut packets = vec![]; let orig_data = &self.0; let header_length = 6; let mut cursor = 0; let mut stack = vec![ParseState { depth: 0, remaining: RemainingData::NPackets(1), }]; while let Some(parse_state) = stack.pop() { let ParseState { depth, remaining } = parse_state; if remaining.is_empty() { continue; } let packet_bits = &orig_data[cursor..]; let version_number = to_big_decimal(&packet_bits[0..3]); let kind_number = to_big_decimal(&packet_bits[3..6]); let data_bits = &packet_bits[header_length..]; let parent_packet_length = match remaining { RemainingData::NBits(n) => RemainingData::NBits(n), RemainingData::NPackets(n) => RemainingData::NPackets(n - 1), }; stack.push(ParseState { depth, remaining: parent_packet_length, }); let packet; let n_bits_consumed; match kind_number { 4 => { let chunk_size = 5; let mut bin_bits = vec![]; let mut n_chunks = 0; for chunk in data_bits.chunks_exact(5) { n_chunks += 1; bin_bits.extend_from_slice(&chunk[1..]); if !chunk[0] { break; } } let value = i64::try_from(to_big_decimal(bin_bits)).unwrap(); n_bits_consumed = header_length + n_chunks * chunk_size; packet = Packet { version_number, kind: PacketKind::Literal { value }, depth, }; } op => { let op_data_length; let n_bits_for_length; let length_type = data_bits[0]; if length_type { // length in packets n_bits_for_length = 12; let n_packets = usize::try_from(to_big_decimal(&data_bits[1..n_bits_for_length])) .unwrap(); op_data_length = RemainingData::NPackets(n_packets); } else { // length in bits n_bits_for_length = 16; let n_bits = usize::try_from(to_big_decimal(&data_bits[1..n_bits_for_length])) .unwrap(); op_data_length = RemainingData::NBits(n_bits); }; n_bits_consumed = header_length + n_bits_for_length; // A hack; we're going to subtract n_bits_consumed from this later // despite the fact that in theory we shouldn't (because the newly added // packet hasn't consumed any data yet), so we we pre-add n_bits_consumed // here so that when we subtract it later we end up with the right number // of bits let op_data_length = match op_data_length { RemainingData::NBits(n) => RemainingData::NBits(n + n_bits_consumed), rd @ RemainingData::NPackets(_) => rd, }; packet = Packet { version_number, kind: PacketKind::Operator { op: op.into() }, depth, }; stack.push(ParseState { depth: depth + 1, remaining: op_data_length, }); } }; cursor += n_bits_consumed; for ps in &mut stack { if let RemainingData::NBits(n) = &mut ps.remaining { if *n > 0 { // The hack above is to counteract this subtraction; if we just pushed // a RemainingData::NumBits, we won't actually have consumed any of // its input yet // // If our code has no bugs, and the input is trustworthy, this will // never underflow. *n -= n_bits_consumed; } } } packets.push(packet); } packets } } #[derive(Debug)] enum PacketKind { Literal { value: Number }, Operator { op: Operation }, // Defined in pt2 } #[derive(Debug)] struct Packet { version_number: u64, kind: PacketKind, depth: usize, } fn read_input(input: &str) -> Vec { let b = Binary::from_hex(input).unwrap(); b.as_packets() } fn ans_for_input(input: &str) -> Answer { let p = read_input(input); (16, (pt1(&p), pt2(&p).unwrap())).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(packets: &[Packet]) -> u64 { packets.iter().map(|packet| packet.version_number).sum() } // end::pt1[] // tag::pt2[] #[derive(Debug)] enum Reducer { Sum, Product, Min, Max, } impl Reducer { fn identity(&self) -> Number { use Reducer::*; match self { Sum => 0, Product => 1, Min => Number::MAX, Max => Number::MIN, } } fn combine(&self, x: Number, y: Number) -> Number { use Reducer::*; match self { Sum => x + y, Product => x * y, Min => x.min(y), Max => x.max(y), } } } #[derive(Debug)] enum Comparitor { Gt, Lt, Eq, } impl Comparitor { fn apply(&self, x: Number, y: Number) -> Number { use Comparitor::*; i64::from(match self { Gt => x > y, Lt => x x == y, }) } } #[derive(Debug)] enum Operation { Reduce(Reducer), Compare(Comparitor), } impl From for Operation { fn from(n: u64) -> Self { use Comparitor::*; use Operation::*; use Reducer::*; match n { 0 => Reduce(Sum), 1 => Reduce(Product), 2 => Reduce(Min), 3 => Reduce(Max), 5 => Compare(Gt), 6 => Compare(Lt), 7 => Compare(Eq), _ => unreachable!(), } } } fn pt2(packets: &[Packet]) -> Option { struct Arg { depth: usize, value: Number, } let mut arg_stack = vec![]; for Packet { kind: packet_kind, depth: packet_depth, .. } in packets.iter().rev() { let packet_depth = *packet_depth; match packet_kind { &PacketKind::Literal { value } => arg_stack.push(Arg { depth: packet_depth, value, }), PacketKind::Operator { op } => { use Operation::*; let value = match op { Reduce(reducer) => { let mut result = reducer.identity(); while let Some(arg @ Arg { depth, value }) = arg_stack.pop() { if depth { let Arg { value: first, .. } = arg_stack.pop()?; let Arg { value: second, .. } = arg_stack.pop()?; comparitor.apply(first, second) } }; arg_stack.push(Arg { depth: packet_depth, value, }); } } } Some(arg_stack.first()?.value) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { #[track_caller] fn test_pt1(in_str: &str, pt1_val: u64) { test_input!(&read_input(in_str), pt1: pt1_val); } #[track_caller] fn test_pt2(in_str: &str, pt2_val: Number) { test_input!(&read_input(in_str), pt2: Some(pt2_val)); } // pt1 only test_pt1(\"D2FE28\", 6); test_pt1(\"8A004A801A8002F478\", 16); test_pt1(\"620080001611562C8802118E34\", 12); test_pt1(\"C0015000016115A2E0802F182340\", 23); test_pt1(\"A0016C880162017C3686B18A3D4780\", 31); test_pt1(include_str!(\"input.txt\"), 927); // pt2 only test_pt2(\"D2FE28\", 2021); test_pt2(\"C200B40A82\", 3); test_pt2(\"04005AC33890\", 54); test_pt2(\"880086C3E88112\", 7); test_pt2(\"CE00C43D881120\", 9); test_pt2(\"D8005AC2A8F0\", 1); test_pt2(\"F600BC2D8F\", 0); test_pt2(\"9C005AC2F8F0\", 0); test_pt2(\"9C0141080250320F1802104A08\", 1); } }","title":"Day 16: Packet Decoder","component":"ROOT","version":"","name":"soln","url":"/src/day_16/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"18":{"id":18,"text":"Day #17 problem description │ Problem input Holy crap. This problem was hard. After looking at the subreddit it looks like most people just brute forced it. That’s easy, but where’s the fun in that? Where possible, we want to solve these problems in the most computationally efficient manner possible. We are asked to find the initial \\(x\\)- and \\(y\\)-velocities that will land a projectile, fired from the origin, in a given rectangular region \\(R=[x_\\mathrm{min}, x_\\mathrm{max}]\\times[y_\\mathrm{min}, y_\\mathrm{max}]\\). In the \\(x\\)-direction, the projectile suffers from drag, so its \\(x\\)-velocity decreases by 1 each tick until it hits 0 (at which point it can’t slow down anymore). In the \\(y\\)-direction, the projectile is affected by gravity (but no drag (?)), so its \\(y\\)-velocity decreases by each tick, forever. All numbers — time, positions, and velocities — must be (not-necessarily-positive) integers. (And, naturally, time must be positive.) This is an important and helpful constraint on the values we can use. The solution below does not use brute force; it does not, for instance, try all \\(v_x\\)s between 0 and \\(R\\)'s right edge, or all \\(v_y\\)s between \\(-\\mathrm{abs}(v_\\mathrm{max})\\) and \\(\\mathrm{abs}(v_\\mathrm{max})\\). All potential times, positions, and speeds are derived mathematically. It has no problem running on a target area of x=1000000..1001000, y=-1000000..-1001000 (although this particular target area requires being able to take the integer square root of large numbers, which I did not implement myself). // tag::setup[] use crate::Answer; use num::integer::Roots; use std::collections::BTreeSet as Set; // tag::setup_main[] type Time = i64; type Num = i64; #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Pos { x: T, y: T, } #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Velo { vx: T, vy: T, } #[derive(Debug, Clone, Copy)] struct Rect { x_min: T, x_max: T, y_min: T, y_max: T, } #[derive(Debug, Clone, Copy)] struct Trajectory { _t: Time, _pos: Pos, velo: Velo, } fn read_input(input: &str) -> Option> { let re = { regex::Regex::new(r\"target area:\\s*x=([\\d-]+)\\.\\.([\\d-]+),\\s*y=([\\d-]+)\\.\\.([\\d-]+)\") .ok()? }; let caps = re.captures(input.trim())?; let [x1, x2, y1, y2] = // force line break :/ [1, 2, 3, 4].map(|i| caps.get(i).and_then(|m| m.as_str().parse().ok())); let [x1, x2, y1, y2] = [x1?, x2?, y1?, y2?]; let [x_min, x_max] = if x1 Option { let sqrt = Roots::sqrt(&n); if sqrt * sqrt == n { Some(sqrt) } else { None } } // end::setup_main[] // tag::velo_finder[] fn find_velocities(t: Time, position: Pos) -> [Option>; 2] { if t == 0 { return [Some(Velo { vx: 0, vy: 0 }), None]; } let Pos { x, y } = position; let vy_numer = 2 * y + t * (t - 1); let vy_denom = 2 * t; let vy = if vy_numer % vy_denom == 0 { vy_numer / vy_denom } else { return [None, None]; }; let vx1 = { let vx_numer = 2 * x + t * (t - 1); let vx_denom = 2 * t; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx >= t { Some(vx) } else { None } }; let vx2 = { let discriminant = 1 + 8 * x; sqrt(discriminant).and_then(|sqrt_disc| { let vx_numer = sqrt_disc - 1; let vx_denom = 2; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx Vec { assert_ne!(y, 0); let mut ans = vec![]; // Need to find all integer (t, vy) that satisfy y = vy * t - t*(t-1)/2 with t > 0 // // Step one: (2*vy + 1)^2 - 8*y = must be square // // In other words there must exist integral m and n such that m^2 - n^2 = 8y (with // 2*vy + 1 = m). m^2 - n^2 = (m-n)*(m+n), and so... let eight_y = 8 * y; let abs_eight_y = eight_y.abs(); for k1 in 1..=Roots::sqrt(&abs_eight_y) { if abs_eight_y % k1 != 0 { continue; } for sign in [-1, 1] { let k1 = sign * k1; let k2 = eight_y / k1; // k1 and k2 are now two signed integers that multiply to 8y let two_m = k1 + k2; if two_m % 2 != 0 { continue; } let m = two_m / 2; // Now, m was 2*vy + 1, and so... if (m - 1) % 2 != 0 { continue; } let vy = (m - 1) / 2; let discriminant = m * m - eight_y; if discriminant Answer, usize> { let rect = read_input(input).unwrap(); let trajectories = get_trajectories(rect); (17, (pt1(trajectories.iter()), pt2(trajectories.iter()))).into() } pub fn ans() -> Answer, usize> { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::get_traj[] fn get_x(t: Time, vx: Num) -> Num { if t ) -> Vec { let Rect { x_min, x_max, y_min, y_max, } = rect; let mut trajectories = vec![]; for y in y_min..=y_max { if y == 0 { // If any vx works, then there will be infinitely many choices for vy because it // retraces its ascent on its descent. And if no vx works, then it's moot continue; } let ts_and_vys = find_ts_and_vys_for_y(y); for (t, vy) in ts_and_vys { for x in x_min..=x_max { let velocities = find_velocities(t, Pos { x, y }); for velo in velocities { let velo = match velo { Some(v) => v, None => continue, }; if velo.vy == vy && get_x(t, velo.vx) == x { trajectories.push(Trajectory { _t: t, _pos: Pos { x, y }, velo, }); } } } } } trajectories } // end::get_traj[] // tag::pt1[] fn pt1>(trajectories: impl Iterator) -> Option { trajectories .map(|traj| { let traj = *traj.borrow(); let vy = traj.velo.vy; if vy >(trajectories: impl Iterator) -> usize { trajectories .map(|traj| { let Trajectory { velo, .. } = *traj.borrow(); (velo.vx, velo.vy) }) .collect::>() .len() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test_velocity_finder() { for (t, x, y) in [ (1, 7, 2), (2, 13, 3), (3, 18, 3), (4, 22, 2), (5, 25, 0), (6, 27, -3), (7, 28, -7), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 7, vy: 2 } ); } for (t, x, y) in [ (1, 6, 3), (2, 11, 5), (3, 15, 6), (4, 18, 6), (5, 20, 5), (6, 21, 3), (7, 21, 0), (8, 21, -4), (9, 21, -9), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 6, vy: 3 } ); } test_input!(\"target area: x=20..30, y=-10..-5\", day: 17, ans: (Some(45), 112)); test_input!(\"target area: x=34..35, y=-8..-6\", day: 17, ans: (Some(3), 9)); } } The Math Because \\(x\\) decreases by 1 each tick until it hits 0, and \\(y\\) decreases by 1 each tick forever, we have the following equations for the \\(x\\)- and \\(y\\)-coordinates at time \\(t\\) of a projectile fired with an initial velocity of \\( (v_x, v_y)\\). (Derivations are left to the reader, but a helpful fact is that \\(1+2+\\ldots+n=\\frac{1}{2}n(n+1)\\).) \\[\\begin{align*} x(t, v_x) &= \\begin{cases} v_x t - \\frac{1}{2}t(t-1)&t \\le v_x\\\\ \\frac{1}{2}v_x(v_x+1)&t \\ge v_x \\end{cases}\\\\ y(t, v_y)&=v_y t - \\frac{1}{2}t(t-1) \\end{align*}\\] Note that even though the two definitions of \\(x\\) overlap at \\(t=v_x\\), they also coincide there, so it’s not a problem. Now, we must find the values of \\( (v_x,v_y)\\) that land the projectile in \\(R\\). To do this, we simply find the values of \\( (v_x,v_y)\\) that will land the projectile precisely at a point \\( (x,y)\\) in \\(R\\), for each \\( (x,y)\\in R\\). And to do this, we find the \\( (v_x,v_y)\\) that will land the projectile at \\( (x,y)\\) precisely at time \\(t\\), for each positive \\(t\\). To find the velocities that will land the projectile precisely at \\( (t,x,y)\\), we solve the above equations for \\(v_x\\) and \\(v_y\\). Finding \\(v_y\\) is simple: \\(v_y=\\frac{2y+t(t-1)}{2t}\\). For \\(v_x\\), it’s a bit more complicated, as we have two options: \\[v_x=\\begin{cases} \\frac{2x+t(t-1)}{2t}&t\\le v_x\\\\ \\frac{-1\\pm\\sqrt{1+8x}}{2}&t\\ge v_x \\end{cases}\\] And as we said above, we need everything to be an integer, so we can either have no pairs of velocities that work, one pair, or two pairs. // tag::setup[] use crate::Answer; use num::integer::Roots; use std::collections::BTreeSet as Set; // tag::setup_main[] type Time = i64; type Num = i64; #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Pos { x: T, y: T, } #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Velo { vx: T, vy: T, } #[derive(Debug, Clone, Copy)] struct Rect { x_min: T, x_max: T, y_min: T, y_max: T, } #[derive(Debug, Clone, Copy)] struct Trajectory { _t: Time, _pos: Pos, velo: Velo, } fn read_input(input: &str) -> Option> { let re = { regex::Regex::new(r\"target area:\\s*x=([\\d-]+)\\.\\.([\\d-]+),\\s*y=([\\d-]+)\\.\\.([\\d-]+)\") .ok()? }; let caps = re.captures(input.trim())?; let [x1, x2, y1, y2] = // force line break :/ [1, 2, 3, 4].map(|i| caps.get(i).and_then(|m| m.as_str().parse().ok())); let [x1, x2, y1, y2] = [x1?, x2?, y1?, y2?]; let [x_min, x_max] = if x1 Option { let sqrt = Roots::sqrt(&n); if sqrt * sqrt == n { Some(sqrt) } else { None } } // end::setup_main[] // tag::velo_finder[] fn find_velocities(t: Time, position: Pos) -> [Option>; 2] { if t == 0 { return [Some(Velo { vx: 0, vy: 0 }), None]; } let Pos { x, y } = position; let vy_numer = 2 * y + t * (t - 1); let vy_denom = 2 * t; let vy = if vy_numer % vy_denom == 0 { vy_numer / vy_denom } else { return [None, None]; }; let vx1 = { let vx_numer = 2 * x + t * (t - 1); let vx_denom = 2 * t; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx >= t { Some(vx) } else { None } }; let vx2 = { let discriminant = 1 + 8 * x; sqrt(discriminant).and_then(|sqrt_disc| { let vx_numer = sqrt_disc - 1; let vx_denom = 2; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx Vec { assert_ne!(y, 0); let mut ans = vec![]; // Need to find all integer (t, vy) that satisfy y = vy * t - t*(t-1)/2 with t > 0 // // Step one: (2*vy + 1)^2 - 8*y = must be square // // In other words there must exist integral m and n such that m^2 - n^2 = 8y (with // 2*vy + 1 = m). m^2 - n^2 = (m-n)*(m+n), and so... let eight_y = 8 * y; let abs_eight_y = eight_y.abs(); for k1 in 1..=Roots::sqrt(&abs_eight_y) { if abs_eight_y % k1 != 0 { continue; } for sign in [-1, 1] { let k1 = sign * k1; let k2 = eight_y / k1; // k1 and k2 are now two signed integers that multiply to 8y let two_m = k1 + k2; if two_m % 2 != 0 { continue; } let m = two_m / 2; // Now, m was 2*vy + 1, and so... if (m - 1) % 2 != 0 { continue; } let vy = (m - 1) / 2; let discriminant = m * m - eight_y; if discriminant Answer, usize> { let rect = read_input(input).unwrap(); let trajectories = get_trajectories(rect); (17, (pt1(trajectories.iter()), pt2(trajectories.iter()))).into() } pub fn ans() -> Answer, usize> { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::get_traj[] fn get_x(t: Time, vx: Num) -> Num { if t ) -> Vec { let Rect { x_min, x_max, y_min, y_max, } = rect; let mut trajectories = vec![]; for y in y_min..=y_max { if y == 0 { // If any vx works, then there will be infinitely many choices for vy because it // retraces its ascent on its descent. And if no vx works, then it's moot continue; } let ts_and_vys = find_ts_and_vys_for_y(y); for (t, vy) in ts_and_vys { for x in x_min..=x_max { let velocities = find_velocities(t, Pos { x, y }); for velo in velocities { let velo = match velo { Some(v) => v, None => continue, }; if velo.vy == vy && get_x(t, velo.vx) == x { trajectories.push(Trajectory { _t: t, _pos: Pos { x, y }, velo, }); } } } } } trajectories } // end::get_traj[] // tag::pt1[] fn pt1>(trajectories: impl Iterator) -> Option { trajectories .map(|traj| { let traj = *traj.borrow(); let vy = traj.velo.vy; if vy >(trajectories: impl Iterator) -> usize { trajectories .map(|traj| { let Trajectory { velo, .. } = *traj.borrow(); (velo.vx, velo.vy) }) .collect::>() .len() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test_velocity_finder() { for (t, x, y) in [ (1, 7, 2), (2, 13, 3), (3, 18, 3), (4, 22, 2), (5, 25, 0), (6, 27, -3), (7, 28, -7), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 7, vy: 2 } ); } for (t, x, y) in [ (1, 6, 3), (2, 11, 5), (3, 15, 6), (4, 18, 6), (5, 20, 5), (6, 21, 3), (7, 21, 0), (8, 21, -4), (9, 21, -9), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 6, vy: 3 } ); } test_input!(\"target area: x=20..30, y=-10..-5\", day: 17, ans: (Some(45), 112)); test_input!(\"target area: x=34..35, y=-8..-6\", day: 17, ans: (Some(3), 9)); } } Awesome. We have the 0, 1, or 2 velocities that will land the projectile at \\( (x, y)\\) at time \\(t\\). But how to find the \\(t\\)s for which the projectile can even land at \\( (x,y)\\)? We cannot enumerate all \\(t\\)s, as there are infinitely many positive integers. Could we perhaps keep firing it with a larger and larger \\(v_y\\) and hope that it would continue to land in \\(R\\) at some point in its trajectory? The answer is no: there are only finitely many values of \\(v_y\\) for which there exists a time \\(t\\) such that the projectile has a vertical position of \\(y\\) at \\(t\\). Let’s prove it, and let’s find them. Solving the equation \\(y=v_y t- \\frac{1}{2}t(t-1)\\) for \\(t\\), we find that: \\[t=\\frac{1}{2}\\left((2v_y+1)\\pm\\sqrt{(2v_y+1)^2-8y}\\right)\\] First and foremost, for this to be an integer, \\((2v_y+1)^2-8y\\) must be a perfect square. Letting \\( m^2 =(2v_y+1) ^ 2\\) and \\(n^2 = m^2 - 8y\\), we have \\(m^2 - n^2 = 8y\\), which factors into \\((m-n)(m+n)=8y\\). Since everything must be an integer, we can use the factor pairs of \\(8y\\) to find \\(m\\) and \\(n\\). If \\(8y=(m-n)(m+n)=k_1k_2\\), then \\(m=\\frac{1}{2}(k_1+k_2)\\). Hence, if \\(2v_y+1=\\frac{1}{2}(k_1+k_2)\\), then \\((2v_y+1)^2 - 8y\\) will indeed be a perfect square. Of course, we also need \\(\\frac{1}{2}(k_1+k_2)\\) to be an odd integer so that \\(v_y\\) will be an integer. Finally, we plug \\(v_y\\) into our equation for \\(t\\) and if we get an integer, we’ve got a match: if the projectile is fired with a \\(y\\)-velocity of \\(v_y\\), then it will hit the vertical position \\(y\\) precisely at \\(t\\). The astute reader will note that there every projectile with \\(v_y>0\\) hits \\(y=0\\) on the way down. Therefore we exclude \\(y=0\\) from consideration altogether; a problem that included \\(y=0\\) in \\(R\\) would have infinitely many answers or be impossible to solve. // tag::setup[] use crate::Answer; use num::integer::Roots; use std::collections::BTreeSet as Set; // tag::setup_main[] type Time = i64; type Num = i64; #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Pos { x: T, y: T, } #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Velo { vx: T, vy: T, } #[derive(Debug, Clone, Copy)] struct Rect { x_min: T, x_max: T, y_min: T, y_max: T, } #[derive(Debug, Clone, Copy)] struct Trajectory { _t: Time, _pos: Pos, velo: Velo, } fn read_input(input: &str) -> Option> { let re = { regex::Regex::new(r\"target area:\\s*x=([\\d-]+)\\.\\.([\\d-]+),\\s*y=([\\d-]+)\\.\\.([\\d-]+)\") .ok()? }; let caps = re.captures(input.trim())?; let [x1, x2, y1, y2] = // force line break :/ [1, 2, 3, 4].map(|i| caps.get(i).and_then(|m| m.as_str().parse().ok())); let [x1, x2, y1, y2] = [x1?, x2?, y1?, y2?]; let [x_min, x_max] = if x1 Option { let sqrt = Roots::sqrt(&n); if sqrt * sqrt == n { Some(sqrt) } else { None } } // end::setup_main[] // tag::velo_finder[] fn find_velocities(t: Time, position: Pos) -> [Option>; 2] { if t == 0 { return [Some(Velo { vx: 0, vy: 0 }), None]; } let Pos { x, y } = position; let vy_numer = 2 * y + t * (t - 1); let vy_denom = 2 * t; let vy = if vy_numer % vy_denom == 0 { vy_numer / vy_denom } else { return [None, None]; }; let vx1 = { let vx_numer = 2 * x + t * (t - 1); let vx_denom = 2 * t; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx >= t { Some(vx) } else { None } }; let vx2 = { let discriminant = 1 + 8 * x; sqrt(discriminant).and_then(|sqrt_disc| { let vx_numer = sqrt_disc - 1; let vx_denom = 2; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx Vec { assert_ne!(y, 0); let mut ans = vec![]; // Need to find all integer (t, vy) that satisfy y = vy * t - t*(t-1)/2 with t > 0 // // Step one: (2*vy + 1)^2 - 8*y = must be square // // In other words there must exist integral m and n such that m^2 - n^2 = 8y (with // 2*vy + 1 = m). m^2 - n^2 = (m-n)*(m+n), and so... let eight_y = 8 * y; let abs_eight_y = eight_y.abs(); for k1 in 1..=Roots::sqrt(&abs_eight_y) { if abs_eight_y % k1 != 0 { continue; } for sign in [-1, 1] { let k1 = sign * k1; let k2 = eight_y / k1; // k1 and k2 are now two signed integers that multiply to 8y let two_m = k1 + k2; if two_m % 2 != 0 { continue; } let m = two_m / 2; // Now, m was 2*vy + 1, and so... if (m - 1) % 2 != 0 { continue; } let vy = (m - 1) / 2; let discriminant = m * m - eight_y; if discriminant Answer, usize> { let rect = read_input(input).unwrap(); let trajectories = get_trajectories(rect); (17, (pt1(trajectories.iter()), pt2(trajectories.iter()))).into() } pub fn ans() -> Answer, usize> { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::get_traj[] fn get_x(t: Time, vx: Num) -> Num { if t ) -> Vec { let Rect { x_min, x_max, y_min, y_max, } = rect; let mut trajectories = vec![]; for y in y_min..=y_max { if y == 0 { // If any vx works, then there will be infinitely many choices for vy because it // retraces its ascent on its descent. And if no vx works, then it's moot continue; } let ts_and_vys = find_ts_and_vys_for_y(y); for (t, vy) in ts_and_vys { for x in x_min..=x_max { let velocities = find_velocities(t, Pos { x, y }); for velo in velocities { let velo = match velo { Some(v) => v, None => continue, }; if velo.vy == vy && get_x(t, velo.vx) == x { trajectories.push(Trajectory { _t: t, _pos: Pos { x, y }, velo, }); } } } } } trajectories } // end::get_traj[] // tag::pt1[] fn pt1>(trajectories: impl Iterator) -> Option { trajectories .map(|traj| { let traj = *traj.borrow(); let vy = traj.velo.vy; if vy >(trajectories: impl Iterator) -> usize { trajectories .map(|traj| { let Trajectory { velo, .. } = *traj.borrow(); (velo.vx, velo.vy) }) .collect::>() .len() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test_velocity_finder() { for (t, x, y) in [ (1, 7, 2), (2, 13, 3), (3, 18, 3), (4, 22, 2), (5, 25, 0), (6, 27, -3), (7, 28, -7), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 7, vy: 2 } ); } for (t, x, y) in [ (1, 6, 3), (2, 11, 5), (3, 15, 6), (4, 18, 6), (5, 20, 5), (6, 21, 3), (7, 21, 0), (8, 21, -4), (9, 21, -9), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 6, vy: 3 } ); } test_input!(\"target area: x=20..30, y=-10..-5\", day: 17, ans: (Some(45), 112)); test_input!(\"target area: x=34..35, y=-8..-6\", day: 17, ans: (Some(3), 9)); } } We are nearly there! To find whether, and how, the projectile can reach the point \\( (x,y)\\), we find: the set of pairs \\((t, v_y)\\) that give the projectile a vertical position of \\(y\\) at time \\(t\\), and for each of these pairs, we check that the projectile can indeed reach \\( (x,y)\\) at time \\(t\\) (we know it can reach \\(y\\), but can it reach \\(x\\)?) and find the velocities \\( (v_x,v_y)\\) that will achieve that, if possible. And we simply do this for every \\( (x,y)\\in R\\). // tag::setup[] use crate::Answer; use num::integer::Roots; use std::collections::BTreeSet as Set; // tag::setup_main[] type Time = i64; type Num = i64; #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Pos { x: T, y: T, } #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Velo { vx: T, vy: T, } #[derive(Debug, Clone, Copy)] struct Rect { x_min: T, x_max: T, y_min: T, y_max: T, } #[derive(Debug, Clone, Copy)] struct Trajectory { _t: Time, _pos: Pos, velo: Velo, } fn read_input(input: &str) -> Option> { let re = { regex::Regex::new(r\"target area:\\s*x=([\\d-]+)\\.\\.([\\d-]+),\\s*y=([\\d-]+)\\.\\.([\\d-]+)\") .ok()? }; let caps = re.captures(input.trim())?; let [x1, x2, y1, y2] = // force line break :/ [1, 2, 3, 4].map(|i| caps.get(i).and_then(|m| m.as_str().parse().ok())); let [x1, x2, y1, y2] = [x1?, x2?, y1?, y2?]; let [x_min, x_max] = if x1 Option { let sqrt = Roots::sqrt(&n); if sqrt * sqrt == n { Some(sqrt) } else { None } } // end::setup_main[] // tag::velo_finder[] fn find_velocities(t: Time, position: Pos) -> [Option>; 2] { if t == 0 { return [Some(Velo { vx: 0, vy: 0 }), None]; } let Pos { x, y } = position; let vy_numer = 2 * y + t * (t - 1); let vy_denom = 2 * t; let vy = if vy_numer % vy_denom == 0 { vy_numer / vy_denom } else { return [None, None]; }; let vx1 = { let vx_numer = 2 * x + t * (t - 1); let vx_denom = 2 * t; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx >= t { Some(vx) } else { None } }; let vx2 = { let discriminant = 1 + 8 * x; sqrt(discriminant).and_then(|sqrt_disc| { let vx_numer = sqrt_disc - 1; let vx_denom = 2; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx Vec { assert_ne!(y, 0); let mut ans = vec![]; // Need to find all integer (t, vy) that satisfy y = vy * t - t*(t-1)/2 with t > 0 // // Step one: (2*vy + 1)^2 - 8*y = must be square // // In other words there must exist integral m and n such that m^2 - n^2 = 8y (with // 2*vy + 1 = m). m^2 - n^2 = (m-n)*(m+n), and so... let eight_y = 8 * y; let abs_eight_y = eight_y.abs(); for k1 in 1..=Roots::sqrt(&abs_eight_y) { if abs_eight_y % k1 != 0 { continue; } for sign in [-1, 1] { let k1 = sign * k1; let k2 = eight_y / k1; // k1 and k2 are now two signed integers that multiply to 8y let two_m = k1 + k2; if two_m % 2 != 0 { continue; } let m = two_m / 2; // Now, m was 2*vy + 1, and so... if (m - 1) % 2 != 0 { continue; } let vy = (m - 1) / 2; let discriminant = m * m - eight_y; if discriminant Answer, usize> { let rect = read_input(input).unwrap(); let trajectories = get_trajectories(rect); (17, (pt1(trajectories.iter()), pt2(trajectories.iter()))).into() } pub fn ans() -> Answer, usize> { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::get_traj[] fn get_x(t: Time, vx: Num) -> Num { if t ) -> Vec { let Rect { x_min, x_max, y_min, y_max, } = rect; let mut trajectories = vec![]; for y in y_min..=y_max { if y == 0 { // If any vx works, then there will be infinitely many choices for vy because it // retraces its ascent on its descent. And if no vx works, then it's moot continue; } let ts_and_vys = find_ts_and_vys_for_y(y); for (t, vy) in ts_and_vys { for x in x_min..=x_max { let velocities = find_velocities(t, Pos { x, y }); for velo in velocities { let velo = match velo { Some(v) => v, None => continue, }; if velo.vy == vy && get_x(t, velo.vx) == x { trajectories.push(Trajectory { _t: t, _pos: Pos { x, y }, velo, }); } } } } } trajectories } // end::get_traj[] // tag::pt1[] fn pt1>(trajectories: impl Iterator) -> Option { trajectories .map(|traj| { let traj = *traj.borrow(); let vy = traj.velo.vy; if vy >(trajectories: impl Iterator) -> usize { trajectories .map(|traj| { let Trajectory { velo, .. } = *traj.borrow(); (velo.vx, velo.vy) }) .collect::>() .len() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test_velocity_finder() { for (t, x, y) in [ (1, 7, 2), (2, 13, 3), (3, 18, 3), (4, 22, 2), (5, 25, 0), (6, 27, -3), (7, 28, -7), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 7, vy: 2 } ); } for (t, x, y) in [ (1, 6, 3), (2, 11, 5), (3, 15, 6), (4, 18, 6), (5, 20, 5), (6, 21, 3), (7, 21, 0), (8, 21, -4), (9, 21, -9), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 6, vy: 3 } ); } test_input!(\"target area: x=20..30, y=-10..-5\", day: 17, ans: (Some(45), 112)); test_input!(\"target area: x=34..35, y=-8..-6\", day: 17, ans: (Some(3), 9)); } } Once we get all the trajectories, the actual answers we’re asked for are pretty simple. Part 1 asks us to find the maximum possible height that can be achieved by a projectile that reaches \\(R\\). As we said above, a projectile with initial \\(y\\)-velocity \\(v_y\\) reaches an apex of \\(\\frac{1}{2}v_y(v_y+1)\\). // tag::setup[] use crate::Answer; use num::integer::Roots; use std::collections::BTreeSet as Set; // tag::setup_main[] type Time = i64; type Num = i64; #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Pos { x: T, y: T, } #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Velo { vx: T, vy: T, } #[derive(Debug, Clone, Copy)] struct Rect { x_min: T, x_max: T, y_min: T, y_max: T, } #[derive(Debug, Clone, Copy)] struct Trajectory { _t: Time, _pos: Pos, velo: Velo, } fn read_input(input: &str) -> Option> { let re = { regex::Regex::new(r\"target area:\\s*x=([\\d-]+)\\.\\.([\\d-]+),\\s*y=([\\d-]+)\\.\\.([\\d-]+)\") .ok()? }; let caps = re.captures(input.trim())?; let [x1, x2, y1, y2] = // force line break :/ [1, 2, 3, 4].map(|i| caps.get(i).and_then(|m| m.as_str().parse().ok())); let [x1, x2, y1, y2] = [x1?, x2?, y1?, y2?]; let [x_min, x_max] = if x1 Option { let sqrt = Roots::sqrt(&n); if sqrt * sqrt == n { Some(sqrt) } else { None } } // end::setup_main[] // tag::velo_finder[] fn find_velocities(t: Time, position: Pos) -> [Option>; 2] { if t == 0 { return [Some(Velo { vx: 0, vy: 0 }), None]; } let Pos { x, y } = position; let vy_numer = 2 * y + t * (t - 1); let vy_denom = 2 * t; let vy = if vy_numer % vy_denom == 0 { vy_numer / vy_denom } else { return [None, None]; }; let vx1 = { let vx_numer = 2 * x + t * (t - 1); let vx_denom = 2 * t; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx >= t { Some(vx) } else { None } }; let vx2 = { let discriminant = 1 + 8 * x; sqrt(discriminant).and_then(|sqrt_disc| { let vx_numer = sqrt_disc - 1; let vx_denom = 2; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx Vec { assert_ne!(y, 0); let mut ans = vec![]; // Need to find all integer (t, vy) that satisfy y = vy * t - t*(t-1)/2 with t > 0 // // Step one: (2*vy + 1)^2 - 8*y = must be square // // In other words there must exist integral m and n such that m^2 - n^2 = 8y (with // 2*vy + 1 = m). m^2 - n^2 = (m-n)*(m+n), and so... let eight_y = 8 * y; let abs_eight_y = eight_y.abs(); for k1 in 1..=Roots::sqrt(&abs_eight_y) { if abs_eight_y % k1 != 0 { continue; } for sign in [-1, 1] { let k1 = sign * k1; let k2 = eight_y / k1; // k1 and k2 are now two signed integers that multiply to 8y let two_m = k1 + k2; if two_m % 2 != 0 { continue; } let m = two_m / 2; // Now, m was 2*vy + 1, and so... if (m - 1) % 2 != 0 { continue; } let vy = (m - 1) / 2; let discriminant = m * m - eight_y; if discriminant Answer, usize> { let rect = read_input(input).unwrap(); let trajectories = get_trajectories(rect); (17, (pt1(trajectories.iter()), pt2(trajectories.iter()))).into() } pub fn ans() -> Answer, usize> { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::get_traj[] fn get_x(t: Time, vx: Num) -> Num { if t ) -> Vec { let Rect { x_min, x_max, y_min, y_max, } = rect; let mut trajectories = vec![]; for y in y_min..=y_max { if y == 0 { // If any vx works, then there will be infinitely many choices for vy because it // retraces its ascent on its descent. And if no vx works, then it's moot continue; } let ts_and_vys = find_ts_and_vys_for_y(y); for (t, vy) in ts_and_vys { for x in x_min..=x_max { let velocities = find_velocities(t, Pos { x, y }); for velo in velocities { let velo = match velo { Some(v) => v, None => continue, }; if velo.vy == vy && get_x(t, velo.vx) == x { trajectories.push(Trajectory { _t: t, _pos: Pos { x, y }, velo, }); } } } } } trajectories } // end::get_traj[] // tag::pt1[] fn pt1>(trajectories: impl Iterator) -> Option { trajectories .map(|traj| { let traj = *traj.borrow(); let vy = traj.velo.vy; if vy >(trajectories: impl Iterator) -> usize { trajectories .map(|traj| { let Trajectory { velo, .. } = *traj.borrow(); (velo.vx, velo.vy) }) .collect::>() .len() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test_velocity_finder() { for (t, x, y) in [ (1, 7, 2), (2, 13, 3), (3, 18, 3), (4, 22, 2), (5, 25, 0), (6, 27, -3), (7, 28, -7), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 7, vy: 2 } ); } for (t, x, y) in [ (1, 6, 3), (2, 11, 5), (3, 15, 6), (4, 18, 6), (5, 20, 5), (6, 21, 3), (7, 21, 0), (8, 21, -4), (9, 21, -9), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 6, vy: 3 } ); } test_input!(\"target area: x=20..30, y=-10..-5\", day: 17, ans: (Some(45), 112)); test_input!(\"target area: x=34..35, y=-8..-6\", day: 17, ans: (Some(3), 9)); } } Part 2 asks us to simply count distinct initial velocities that land the projectile in \\(R\\). // tag::setup[] use crate::Answer; use num::integer::Roots; use std::collections::BTreeSet as Set; // tag::setup_main[] type Time = i64; type Num = i64; #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Pos { x: T, y: T, } #[derive(Debug, Clone, Copy, PartialEq, Eq)] struct Velo { vx: T, vy: T, } #[derive(Debug, Clone, Copy)] struct Rect { x_min: T, x_max: T, y_min: T, y_max: T, } #[derive(Debug, Clone, Copy)] struct Trajectory { _t: Time, _pos: Pos, velo: Velo, } fn read_input(input: &str) -> Option> { let re = { regex::Regex::new(r\"target area:\\s*x=([\\d-]+)\\.\\.([\\d-]+),\\s*y=([\\d-]+)\\.\\.([\\d-]+)\") .ok()? }; let caps = re.captures(input.trim())?; let [x1, x2, y1, y2] = // force line break :/ [1, 2, 3, 4].map(|i| caps.get(i).and_then(|m| m.as_str().parse().ok())); let [x1, x2, y1, y2] = [x1?, x2?, y1?, y2?]; let [x_min, x_max] = if x1 Option { let sqrt = Roots::sqrt(&n); if sqrt * sqrt == n { Some(sqrt) } else { None } } // end::setup_main[] // tag::velo_finder[] fn find_velocities(t: Time, position: Pos) -> [Option>; 2] { if t == 0 { return [Some(Velo { vx: 0, vy: 0 }), None]; } let Pos { x, y } = position; let vy_numer = 2 * y + t * (t - 1); let vy_denom = 2 * t; let vy = if vy_numer % vy_denom == 0 { vy_numer / vy_denom } else { return [None, None]; }; let vx1 = { let vx_numer = 2 * x + t * (t - 1); let vx_denom = 2 * t; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx >= t { Some(vx) } else { None } }; let vx2 = { let discriminant = 1 + 8 * x; sqrt(discriminant).and_then(|sqrt_disc| { let vx_numer = sqrt_disc - 1; let vx_denom = 2; let vx = vx_numer / vx_denom; if vx_numer % vx_denom == 0 && vx Vec { assert_ne!(y, 0); let mut ans = vec![]; // Need to find all integer (t, vy) that satisfy y = vy * t - t*(t-1)/2 with t > 0 // // Step one: (2*vy + 1)^2 - 8*y = must be square // // In other words there must exist integral m and n such that m^2 - n^2 = 8y (with // 2*vy + 1 = m). m^2 - n^2 = (m-n)*(m+n), and so... let eight_y = 8 * y; let abs_eight_y = eight_y.abs(); for k1 in 1..=Roots::sqrt(&abs_eight_y) { if abs_eight_y % k1 != 0 { continue; } for sign in [-1, 1] { let k1 = sign * k1; let k2 = eight_y / k1; // k1 and k2 are now two signed integers that multiply to 8y let two_m = k1 + k2; if two_m % 2 != 0 { continue; } let m = two_m / 2; // Now, m was 2*vy + 1, and so... if (m - 1) % 2 != 0 { continue; } let vy = (m - 1) / 2; let discriminant = m * m - eight_y; if discriminant Answer, usize> { let rect = read_input(input).unwrap(); let trajectories = get_trajectories(rect); (17, (pt1(trajectories.iter()), pt2(trajectories.iter()))).into() } pub fn ans() -> Answer, usize> { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::get_traj[] fn get_x(t: Time, vx: Num) -> Num { if t ) -> Vec { let Rect { x_min, x_max, y_min, y_max, } = rect; let mut trajectories = vec![]; for y in y_min..=y_max { if y == 0 { // If any vx works, then there will be infinitely many choices for vy because it // retraces its ascent on its descent. And if no vx works, then it's moot continue; } let ts_and_vys = find_ts_and_vys_for_y(y); for (t, vy) in ts_and_vys { for x in x_min..=x_max { let velocities = find_velocities(t, Pos { x, y }); for velo in velocities { let velo = match velo { Some(v) => v, None => continue, }; if velo.vy == vy && get_x(t, velo.vx) == x { trajectories.push(Trajectory { _t: t, _pos: Pos { x, y }, velo, }); } } } } } trajectories } // end::get_traj[] // tag::pt1[] fn pt1>(trajectories: impl Iterator) -> Option { trajectories .map(|traj| { let traj = *traj.borrow(); let vy = traj.velo.vy; if vy >(trajectories: impl Iterator) -> usize { trajectories .map(|traj| { let Trajectory { velo, .. } = *traj.borrow(); (velo.vx, velo.vy) }) .collect::>() .len() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test_velocity_finder() { for (t, x, y) in [ (1, 7, 2), (2, 13, 3), (3, 18, 3), (4, 22, 2), (5, 25, 0), (6, 27, -3), (7, 28, -7), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 7, vy: 2 } ); } for (t, x, y) in [ (1, 6, 3), (2, 11, 5), (3, 15, 6), (4, 18, 6), (5, 20, 5), (6, 21, 3), (7, 21, 0), (8, 21, -4), (9, 21, -9), ] { assert_eq!( find_velocities(t, Pos { x, y }) .iter() .flatten() .next() .unwrap(), &Velo { vx: 6, vy: 3 } ); } test_input!(\"target area: x=20..30, y=-10..-5\", day: 17, ans: (Some(45), 112)); test_input!(\"target area: x=34..35, y=-8..-6\", day: 17, ans: (Some(3), 9)); } }","title":"Day 17: Trick Shot","component":"ROOT","version":"","name":"soln","url":"/src/day_17/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"19":{"id":19,"text":"Day #18 problem description │ Problem input This problem asks us to parse a nested structure of pairs into a binary tree and then split or combine nodes according to a set of rules. Rather than store the tree as an actual tree, which would be easy (maybe) but would suffer from poor cache locality, we store the nodes in a Vec and record the depth of each node. This makes traversing and manipulating the tree much easier than if they were stored in a “real” tree; the nodes to the left and right of index i are simply those at i-1 and i+1, respectively (if they exist). // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } } The operations are performed as follows: Exploding A pair is exploded by finding the first flat pair of depth at least four and storing the two values; the first is added to the node to the left and the second is added to the node to the right. The second element of the pair is then deleted. // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } } Splitting An element is split by simply dividing it by 2 twice, rounding down the first time and up the second time, and replacing the element with those two values. // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } } Adding Two pairs are added by placing them in a containing pair. This is manifested as simply concatenating the two vectors and then incrementing all the depths. Notably, addition is not associative. // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } } Finding Pairs in the Vector The only somewhat tricky part is determining the tree structure from the vector of depths. A singleton is returned as an Err containing its value. A “flat” pair (a pair whose elements are both atomic) appears as two consecutive elements of the same depth. Non-flat pairs can be found by traversing the nodes from left to right, maintaining a stack of node depths, and, whenever the top two elements of the stack have the same depth \\(d\\), collapsing them into a single element with a depth of \\(d-1\\). When a pair with elements of depth 1 is found, we have split the tree into its two top-level pairs. If desired, we can then recurse on these to split the descendants into deeper pairs. // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } } Magnitude of a Pair Self explanatory: // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } } Functions listed above are omitted here. // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } } Part 1 simply asks to perform addition on the input numbers. // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } } Part 2 asks to find the maximum pairwise sum of the input numbers. // tag::setup[] use crate::Answer; use std::fmt::{Debug, Display}; // tag::snail_num[] #[derive(Debug, Clone, Copy, Eq, PartialEq)] struct Elem { value: u32, depth: usize, } #[derive(Debug, PartialEq, Eq)] struct SnailNum> { elems: Elems, depth: usize, } // end::snail_num[] type SnailNumOwned = SnailNum>; type SnailNumBorrowed = SnailNum; impl SnailNumOwned { fn from_line(line: &str) -> Self { let mut addends = Vec::::new(); let mut depth = 0; let mut prev_was_digit = false; for c in line.trim().chars() { let mut c_is_digit = false; match c { '[' => depth += 1, ']' => depth -= 1, '0'..='9' => { let digit = c.to_digit(10).unwrap(); if prev_was_digit { let val = addends.last_mut().unwrap(); val.value = 10 * val.value + digit; } else { addends.push(Elem { value: digit, depth, }); } c_is_digit = true; } ',' => {} _ => { panic!(\"Unexpected character {:?}\", c); } } prev_was_digit = c_is_digit; } SnailNum::owning(addends) } fn by_adding_lines_in, I: IntoIterator>(lines: I) -> Self { let mut lines = lines.into_iter(); let mut ans = SnailNumOwned::from_line(lines.next().unwrap().as_ref()); for line in lines { ans = ans.add(&SnailNumOwned::from_line(line.as_ref())); } ans } fn from_str(input: &str) -> Self { Self::by_adding_lines_in(input.lines()) } fn owning(elems: Vec) -> Self { Self { elems, depth: 0 } } fn reduce_once(&mut self) -> bool { self.explode_first().is_some() || self.split_first().is_some() } fn reduce(&mut self) { while self.reduce_once() {} } // Contains explode_first and split_first, which only operate on owned snail nums // tag::explode[] /// Explodes the first explode-able pair in the list. \\ /// Returns the `Option` pair of `Option` indices of the elements to the left and right /// (the ones being modified), in that order. `None` means there was no pair to explode; /// `(None, Some(2))` means the exploded pair had no elements to the left of it (it /// was at index 0), and the element to its right was added to fn explode_first(&mut self) -> Option, Option)> { let elems = &mut self.elems; let ((l_idx, l_elem), (r_idx, r_elem)) = elems .iter() .enumerate() .zip(elems.iter().enumerate().skip(1)) .find_map(|((i1, &e1), (i2, &e2))| { if e1.depth > 4 && e1.depth == e2.depth { Some(((i1, e1), (i2, e2))) } else { None } })?; elems[l_idx] = Elem { value: 0, depth: l_elem.depth - 1, }; let changed_l_idx = if l_idx > 0 { let idx = l_idx - 1; elems[idx].value += l_elem.value; Some(idx) } else { None }; elems.remove(r_idx); let changed_r_idx = if r_idx Option { let elems = &mut self.elems; let (split_idx, Elem { value, depth }) = elems.iter().enumerate().find_map(|(i, &elem)| { if elem.value >= 10 { Some((i, elem)) } else { None } })?; let new_l_value = value / 2; let new_r_value = (value + 1) / 2; let new_elem = Elem { value: new_l_value, depth: depth + 1, }; elems[split_idx] = new_elem; elems.insert( split_idx + 1, Elem { value: new_r_value, depth: new_elem.depth, }, ); Some(split_idx) } // end::split[] } impl SnailNumBorrowed { fn borrowing(elems: &'a [Elem], base_depth: usize) -> Self { Self { elems, depth: base_depth, } } } impl> SnailNum { // Contains add, as_pair, and magnitude // tag::debugging[] #[cfg(test)] fn reduced(&self) -> SnailNumOwned { let mut sn = SnailNumOwned::owning(self.elems.as_ref().to_owned()); sn.reduce(); sn } // end::debugging[] // tag::add[] fn add(&self, other: &Self) -> SnailNumOwned { let elems = self .elems .as_ref() .iter() .chain(other.elems.as_ref()) .map(|&Elem { value, depth }| Elem { value, depth: depth + 1, }) .collect(); let mut ans = SnailNumOwned::owning(elems); ans.reduce(); ans } // end::add[] // tag::pair[] fn as_pair(&self) -> Result { let elems = self.elems.as_ref(); assert_ne!(elems.len(), 0, \"{}\", self.depth); if elems.len() == 1 { return Err(self.elems.as_ref()[0].value); } let mut depth_stack = vec![]; for (i, &Elem { depth, .. }) in elems.iter().enumerate() { depth_stack.push(depth); loop { match depth_stack.pop() { None => break, Some(curr_depth) => { if curr_depth == self.depth + 1 { let (left, right) = elems.split_at(i + 1); return Ok(( SnailNum::borrowing(left, curr_depth), SnailNum::borrowing(right, curr_depth), )); } match depth_stack.pop() { None => { depth_stack.push(curr_depth); break; } Some(prev_depth) => { if prev_depth == curr_depth { depth_stack.push(curr_depth - 1); } else { depth_stack.extend([prev_depth, curr_depth]); break; } } } } } } } unreachable!() } // end::pair[] // tag::magnitude[] fn magnitude(&self) -> u32 { match self.as_pair() { Ok((left, right)) => 3 * left.magnitude() + 2 * right.magnitude(), Err(val) => val, } } // end::magnitude[] } // tag::debugging[] impl> Display for SnailNum { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { if self.elems.as_ref().is_empty() { return Ok(()); } match self.as_pair() { Ok((left, right)) => { write!(f, \"[{},{}]\", left, right) } Err(value) => { write!(f, \"{}\", value) } } } } // end::debugging[] fn ans_for_input(input: &str) -> Answer { let snail_num = SnailNumOwned::from_str(input); (18, (pt1(&snail_num), pt2(input))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(snail_num: &SnailNum) -> u32 { snail_num.magnitude() } // end::pt1[] // tag::pt2[] fn pt2(input: &str) -> u32 { let mut max_mag = u32::MIN; let snail_nums = input .lines() .map(SnailNumOwned::from_line) .collect::>(); for (i, sn1) in snail_nums.iter().enumerate() { for sn2 in snail_nums.iter().skip(i + 1) { let mag1 = sn1.add(sn2).magnitude(); let mag2 = sn2.add(sn1).magnitude(); max_mag = max_mag.max(mag1).max(mag2); } } max_mag } // end::pt2[] #[cfg(test)] mod test { use super::*; #[track_caller] fn test_action, T: Eq + std::fmt::Debug, F: Fn(&mut SnailNumOwned) -> T, >( input: &str, before: V, action: F, after: &str, result: &T, ) { let mut snail_num = SnailNumOwned::from_line(input); assert_eq!( snail_num, SnailNumOwned::owning( before .as_ref() .iter() .map(|&(value, depth)| Elem { value, depth }) .collect::>() ) ); assert_eq!(result, &action(&mut snail_num)); assert_eq!(snail_num, SnailNumOwned::from_line(after)); } #[track_caller] fn test_explode>( input: &str, before: V, indices: Option, Option)>, after: &str, ) { test_action(input, before, SnailNumOwned::explode_first, after, &indices); } #[track_caller] fn test_split>( input: &str, before: V, index: Option, after: &str, ) { test_action(input, before, SnailNumOwned::split_first, after, &index); } #[test] fn test_explodes() { test_explode( \"[[[[[9,8],1],2],3],4]\", vec![(9, 5), (8, 5), (1, 4), (2, 3), (3, 2), (4, 1)], Some((None, Some(1))), \"[[[[0,9],2],3],4]\", ); test_explode( \"[7,[6,[5,[4,[3,2]]]]]\", vec![(7, 1), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5)], Some((Some(3), None)), \"[7,[6,[5,[7,0]]]]\", ); test_explode( \"[[6,[5,[4,[3,2]]]],1]\", vec![(6, 2), (5, 3), (4, 4), (3, 5), (2, 5), (1, 1)], Some((Some(2), Some(4))), \"[[6,[5,[7,0]]],3]\", ); test_explode( \"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\", vec![ (3, 2), (2, 3), (1, 4), (7, 5), (3, 5), (6, 2), (5, 3), (4, 4), (3, 5), (2, 5), ], Some((Some(2), Some(4))), \"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\", ); } #[test] fn test_splits() { test_split( \"[[[[0,7],4],[15,[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (15, 3), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(3), \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", ); test_split( \"[[[[0,7],4],[[7,8],[0,13]]],[1,1]]\", vec![ (0, 4), (7, 4), (4, 3), (7, 4), (8, 4), (0, 4), (13, 4), (1, 2), (1, 2), ], Some(6), \"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]\", ); } #[test] fn test_reduction() { assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"]).reduced(), SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"]) .reduced(), SnailNumOwned::from_line(\"[[[[3,0],[5,3]],[4,4]],[5,5]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\" ]) .reduced(), SnailNumOwned::from_line(\"[[[[5,0],[7,4]],[5,5]],[6,6]]\") ); assert_eq!( SnailNumOwned::from_line(\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduced(), SnailNumOwned::from_line(\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\") ); assert_eq!( SnailNumOwned::by_adding_lines_in(vec![ \"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\", \"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\", \"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\", \"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\", \"[7,[5,[[3,8],[1,4]]]]\", \"[[2,[2,2]],[8,[8,1]]]\", \"[2,9]\", \"[1,[[[9,3],9],[[9,0],[0,7]]]]\", \"[[[5,[7,4]],7],1]\", \"[[[[4,2],2],6],[8,7]]\" ],) .reduced(), SnailNumOwned::from_line(\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\") ); } #[test] fn test() { assert_eq!(pt1(&SnailNumOwned::from_line(\"[[1,2],[[3,4],5]]\")), 143); assert_eq!( pt1(&SnailNumOwned::from_line( \"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\" )), 1384 ); assert_eq!( pt1(&SnailNumOwned::from_line(\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")), 445 ); } }","title":"Day 18: Snailfish","component":"ROOT","version":"","name":"soln","url":"/src/day_18/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"20":{"id":20,"text":"Day #19 problem description │ Problem input This problem asks us to essentially solve a 3D jigsaw puzzle; we are given “pieces” (scanners) and need to find how they fit together by looking at their “edges” (beacons). As in an ordinary puzzle, we might need to rotate pieces to get them to mesh. To solve this, we simply try every solution: we start with Scanner #1 and try to adjoin each other scanner to it. Once we find a scanner that works, we go back to step 1 and try to adjoin a new scanner to the two-scanner union, and when we’ve done that we try to adjoin a new scanner to the three-scanner union, etc. If at any point we can’t fit a new scanner onto the existing scanners, we backtrack, removing scanners so that we can add them in a different way. We’re done when all scanners have been adjoined. Technically there is a wrinkle that this solution ignores: it is not sufficient for scanners to merely fit together, i.e., to have overlapping beacons; additionally, each of the scanners in an adjoined pair must not have any beacons in the shared region that the other scanner in the pair does not have. In other words, they must agree on all, not just some, of the beacons in the region where they intersect. We ignore this wrinkle altogether; thankfully the authors were kind enough to give us input where this doesn’t matter. Because this “puzzle” is three-dimensional, there are 24 ways to orient a piece with respect to another (six faces can be “up”, and then there are four ways to rotate about the up-axis). In the code, one of these 24 orientations is referred to as a Swivel. For each orientation, we find all translations that cause the pieces to fit together; these are Translations. (A Swivel and a Translation together form a Transform.) Then we rinse and repeat with the next piece. To actually do the math, we simply use matrix multiplication. As always, the matrix \\(T\\) that performs a given transformation is the matrix whose columns are \\(T(e_1), \\ldots, T(e_n) \\) where \\(e_1,\\ldots,e_n\\) are the basis vectors. The function that does the heavy lifting here is Scanner::merge_all, which simply starts with the first provided scanner and then repeatedly tries to form larger and larger unions by merging the other scanners with the existing union. It stops when it first successfully merges all scanners together. // tag::setup[] use crate::Answer; use std::{borrow::Borrow, collections::BTreeSet}; use strum::IntoEnumIterator; use strum_macros::EnumIter; type Triple = [i32; 3]; #[derive(Debug, Clone, Copy)] struct Matrix3([i32; 9]); impl Matrix3 { fn from_cols(x: impl Into, y: impl Into, z: impl Into) -> Self { let x = x.into(); let y = y.into(); let z = z.into(); Self([x[0], y[0], z[0], x[1], y[1], z[1], x[2], y[2], z[2]]) } fn row(&self, i: usize) -> Triple { [0, 1, 2].map(|j| self.0[3 * i + j]) } fn col(&self, i: usize) -> Triple { [0, 1, 2].map(|j| self.0[i + 3 * j]) } fn mat_mul(&self, other: Self) -> Self { let mut entries = [0; 9]; let mut i = 0; for r in 0..3 { let self_row = self.row(r); for c in 0..3 { let other_col = other.col(c); entries[i] = (0..3).map(|i| self_row[i] * other_col[i]).sum(); i += 1; } } Self(entries) } fn mul_vec(&self, col: Triple) -> Triple { let mut entries = [0; 3]; for (r, elem) in entries.iter_mut().enumerate() { let self_row = self.row(r); *elem = (0..3).map(|i| self_row[i] * col[i]).sum(); } entries } } impl std::ops::Index for Matrix3 { type Output = i32; fn index(&self, index: [usize; 2]) -> &Self::Output { let [row, col] = index; &self.0[3 * row + col] } } #[derive(Clone, Copy, Debug, EnumIter, PartialEq, Eq, PartialOrd, Ord)] enum Axis { PosX, NegX, PosY, NegY, PosZ, NegZ, } impl From for Triple { fn from(axis: Axis) -> Self { use Axis::*; match axis { PosX => [1, 0, 0], NegX => [-1, 0, 0], PosY => [0, 1, 0], NegY => [0, -1, 0], PosZ => [0, 0, 1], NegZ => [0, 0, -1], } } } #[derive(Clone, Copy, Debug, EnumIter, PartialEq, Eq, PartialOrd, Ord)] enum RotationCcw { Zero, Quarter, Half, ThreeQuarters, } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Swivel { up_face: Axis, rotation_about_up: RotationCcw, } impl Swivel { fn new(up_face: Axis, rotation_about_up: RotationCcw) -> Self { Self { up_face, rotation_about_up, } } fn identity() -> Self { Self::new(Axis::PosZ, RotationCcw::Zero) } fn apply(self, point: Triple) -> Triple { use Axis::*; use RotationCcw::*; let mat_to_bring_face_to_up = match self.up_face { PosX => Matrix3::from_cols(PosZ, PosY, NegX), NegX => Matrix3::from_cols(NegZ, PosY, PosX), PosY => Matrix3::from_cols(PosX, PosZ, NegY), NegY => Matrix3::from_cols(PosX, NegZ, PosY), PosZ => Matrix3::from_cols(PosX, PosY, PosZ), NegZ => { // We have a couple options; we pick the one that rotates about the y axis // because it's easier to actually rotate my hand that way Matrix3::from_cols(NegX, PosY, NegZ) } }; let mat_to_rotate_about_up = match self.rotation_about_up { Zero => Matrix3::from_cols(PosX, PosY, PosZ), Quarter => Matrix3::from_cols(PosY, NegX, PosZ), Half => Matrix3::from_cols(NegX, NegY, PosZ), ThreeQuarters => Matrix3::from_cols(NegY, PosX, PosZ), }; mat_to_bring_face_to_up .mat_mul(mat_to_rotate_about_up) .mul_vec(point) } } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Translation(Triple); impl Translation { fn identity() -> Self { Self([0, 0, 0]) } fn apply(&self, point: Triple) -> Triple { let [x, y, z] = point; let [tx, ty, tz] = self.0; [x + tx, y + ty, z + tz] } fn manhattan_dist(&self) -> u32 { let [x, y, z] = self.0; u32::try_from(x.abs() + y.abs() + z.abs()).unwrap() } } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Transform { swivel: Swivel, translation: Translation, } impl From for Transform { fn from(swivel: Swivel) -> Self { Self { swivel, translation: Translation([0, 0, 0]), } } } impl From for Transform { fn from(translation: Translation) -> Self { Self { swivel: Swivel::new(Axis::PosZ, RotationCcw::Zero), translation, } } } impl Transform { fn identity() -> Self { Self { swivel: Swivel::identity(), translation: Translation::identity(), } } fn apply(&self, point: Triple) -> Triple { self.translation.apply(self.swivel.apply(point)) } } #[derive(Debug, Clone)] struct Scanner { beacons: BTreeSet, } impl Scanner { fn new(beacons: BTreeSet) -> Self { Self { beacons } } fn merged_with(&self, other: &Self) -> Self { Self { beacons: self.beacons.union(&other.beacons).copied().collect(), } } fn applying + Copy>(&self, transform: T) -> Self { let transform = transform.into(); Scanner::new(self.beacons.iter().map(|&p| transform.apply(p)).collect()) } fn candidates_for_merge(&self, other: &Scanner) -> Vec { let mut transforms = BTreeSet::new(); let mut candidates = vec![]; for up_face in Axis::iter() { for rotation in RotationCcw::iter() { let swivel = Swivel::new(up_face, rotation); let swiveled_other = other.applying(swivel); for swiveled_other_beacon in &swiveled_other.beacons { for this_beacon in &self.beacons { let translation = Translation( [0, 1, 2].map(|i| this_beacon[i] - swiveled_other_beacon[i]), ); let transformed_other = swiveled_other.applying(translation); if self .beacons .intersection(&transformed_other.beacons) .count() >= 12 { let transform = Transform { swivel, translation, }; let wasnt_present = transforms.insert(transform); if wasnt_present { candidates.push((transform, transformed_other)); } } } } } } candidates } fn merge_all>( scanners: impl AsRef, ) -> Option, Scanner)> { let scanners = scanners.as_ref(); let (first, rest) = scanners.split_first().unwrap(); let first = first.borrow(); if rest.is_empty() { return Some((vec![Transform::identity()], first.clone())); } for (i, s) in rest.iter().enumerate() { let s = s.borrow(); for (transform, transformed_scanner) in first.candidates_for_merge(s) { let merged_scanner = first.merged_with(&transformed_scanner); let new_scanners = std::iter::once(&merged_scanner) .chain(rest.iter().enumerate().filter_map(|(j, s)| { if i == j { None } else { Some(s.borrow()) } })) .collect::>(); let merge_result = Scanner::merge_all(new_scanners); if let Some((transforms, ans)) = merge_result { return Some((std::iter::once(transform).chain(transforms).collect(), ans)); } } } None } } fn read_input(s: &str) -> Option> { let mut scanners = vec![]; let mut this_scanner_beacons = BTreeSet::new(); for line in s.lines().chain(std::iter::once(\"\")) { if line.starts_with(\"---\") { continue; } if line.is_empty() { scanners.push(Scanner::new(this_scanner_beacons.clone())); this_scanner_beacons.clear(); } else { let mut comps = line.split(','); let [x, y, z] = [0; 3].map(|_| comps.next()?.parse().ok()); let [x, y, z] = [x?, y?, z?]; this_scanner_beacons.insert([x, y, z]); } } Some(scanners) } fn ans_for_input(input: &str) -> Answer { let scanners = read_input(input).unwrap(); let (transforms, scanner) = Scanner::merge_all(scanners).unwrap(); let translations = transforms.iter().map(|t| t.translation).collect::>(); (19, (pt1(&scanner), pt2(&translations))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(scanner: &Scanner) -> usize { scanner.beacons.len() } // end::pt1[] // tag::pt2[] fn pt2>(translations: V) -> u32 { let translations = translations.as_ref(); let mut max_manh_dist = u32::MIN; for (i, translation1) in translations.iter().enumerate() { let [x1, y1, z1] = translation1.0; for translation2 in translations.iter().skip(i + 1) { let [x2, y2, z2] = translation2.0; let diff = Translation([x2 - x1, y2 - y1, z2 - z1]); max_manh_dist = max_manh_dist.max(diff.manhattan_dist()); } } max_manh_dist } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { assert!( cfg!(not(debug_assertions)), \"Day 19 may not be tested in debug mode; it requires --release\" ); test_input!(include_str!(\"input.txt\"), day: 19, ans: (385, 10707)); } } Part 1 asks us to simply count the distinct beacons after the scanners have all been merged. Below, scanner is obtained from let (transforms, scanner) = Scanner::merge_all(scanners).unwrap();. // tag::setup[] use crate::Answer; use std::{borrow::Borrow, collections::BTreeSet}; use strum::IntoEnumIterator; use strum_macros::EnumIter; type Triple = [i32; 3]; #[derive(Debug, Clone, Copy)] struct Matrix3([i32; 9]); impl Matrix3 { fn from_cols(x: impl Into, y: impl Into, z: impl Into) -> Self { let x = x.into(); let y = y.into(); let z = z.into(); Self([x[0], y[0], z[0], x[1], y[1], z[1], x[2], y[2], z[2]]) } fn row(&self, i: usize) -> Triple { [0, 1, 2].map(|j| self.0[3 * i + j]) } fn col(&self, i: usize) -> Triple { [0, 1, 2].map(|j| self.0[i + 3 * j]) } fn mat_mul(&self, other: Self) -> Self { let mut entries = [0; 9]; let mut i = 0; for r in 0..3 { let self_row = self.row(r); for c in 0..3 { let other_col = other.col(c); entries[i] = (0..3).map(|i| self_row[i] * other_col[i]).sum(); i += 1; } } Self(entries) } fn mul_vec(&self, col: Triple) -> Triple { let mut entries = [0; 3]; for (r, elem) in entries.iter_mut().enumerate() { let self_row = self.row(r); *elem = (0..3).map(|i| self_row[i] * col[i]).sum(); } entries } } impl std::ops::Index for Matrix3 { type Output = i32; fn index(&self, index: [usize; 2]) -> &Self::Output { let [row, col] = index; &self.0[3 * row + col] } } #[derive(Clone, Copy, Debug, EnumIter, PartialEq, Eq, PartialOrd, Ord)] enum Axis { PosX, NegX, PosY, NegY, PosZ, NegZ, } impl From for Triple { fn from(axis: Axis) -> Self { use Axis::*; match axis { PosX => [1, 0, 0], NegX => [-1, 0, 0], PosY => [0, 1, 0], NegY => [0, -1, 0], PosZ => [0, 0, 1], NegZ => [0, 0, -1], } } } #[derive(Clone, Copy, Debug, EnumIter, PartialEq, Eq, PartialOrd, Ord)] enum RotationCcw { Zero, Quarter, Half, ThreeQuarters, } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Swivel { up_face: Axis, rotation_about_up: RotationCcw, } impl Swivel { fn new(up_face: Axis, rotation_about_up: RotationCcw) -> Self { Self { up_face, rotation_about_up, } } fn identity() -> Self { Self::new(Axis::PosZ, RotationCcw::Zero) } fn apply(self, point: Triple) -> Triple { use Axis::*; use RotationCcw::*; let mat_to_bring_face_to_up = match self.up_face { PosX => Matrix3::from_cols(PosZ, PosY, NegX), NegX => Matrix3::from_cols(NegZ, PosY, PosX), PosY => Matrix3::from_cols(PosX, PosZ, NegY), NegY => Matrix3::from_cols(PosX, NegZ, PosY), PosZ => Matrix3::from_cols(PosX, PosY, PosZ), NegZ => { // We have a couple options; we pick the one that rotates about the y axis // because it's easier to actually rotate my hand that way Matrix3::from_cols(NegX, PosY, NegZ) } }; let mat_to_rotate_about_up = match self.rotation_about_up { Zero => Matrix3::from_cols(PosX, PosY, PosZ), Quarter => Matrix3::from_cols(PosY, NegX, PosZ), Half => Matrix3::from_cols(NegX, NegY, PosZ), ThreeQuarters => Matrix3::from_cols(NegY, PosX, PosZ), }; mat_to_bring_face_to_up .mat_mul(mat_to_rotate_about_up) .mul_vec(point) } } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Translation(Triple); impl Translation { fn identity() -> Self { Self([0, 0, 0]) } fn apply(&self, point: Triple) -> Triple { let [x, y, z] = point; let [tx, ty, tz] = self.0; [x + tx, y + ty, z + tz] } fn manhattan_dist(&self) -> u32 { let [x, y, z] = self.0; u32::try_from(x.abs() + y.abs() + z.abs()).unwrap() } } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Transform { swivel: Swivel, translation: Translation, } impl From for Transform { fn from(swivel: Swivel) -> Self { Self { swivel, translation: Translation([0, 0, 0]), } } } impl From for Transform { fn from(translation: Translation) -> Self { Self { swivel: Swivel::new(Axis::PosZ, RotationCcw::Zero), translation, } } } impl Transform { fn identity() -> Self { Self { swivel: Swivel::identity(), translation: Translation::identity(), } } fn apply(&self, point: Triple) -> Triple { self.translation.apply(self.swivel.apply(point)) } } #[derive(Debug, Clone)] struct Scanner { beacons: BTreeSet, } impl Scanner { fn new(beacons: BTreeSet) -> Self { Self { beacons } } fn merged_with(&self, other: &Self) -> Self { Self { beacons: self.beacons.union(&other.beacons).copied().collect(), } } fn applying + Copy>(&self, transform: T) -> Self { let transform = transform.into(); Scanner::new(self.beacons.iter().map(|&p| transform.apply(p)).collect()) } fn candidates_for_merge(&self, other: &Scanner) -> Vec { let mut transforms = BTreeSet::new(); let mut candidates = vec![]; for up_face in Axis::iter() { for rotation in RotationCcw::iter() { let swivel = Swivel::new(up_face, rotation); let swiveled_other = other.applying(swivel); for swiveled_other_beacon in &swiveled_other.beacons { for this_beacon in &self.beacons { let translation = Translation( [0, 1, 2].map(|i| this_beacon[i] - swiveled_other_beacon[i]), ); let transformed_other = swiveled_other.applying(translation); if self .beacons .intersection(&transformed_other.beacons) .count() >= 12 { let transform = Transform { swivel, translation, }; let wasnt_present = transforms.insert(transform); if wasnt_present { candidates.push((transform, transformed_other)); } } } } } } candidates } fn merge_all>( scanners: impl AsRef, ) -> Option, Scanner)> { let scanners = scanners.as_ref(); let (first, rest) = scanners.split_first().unwrap(); let first = first.borrow(); if rest.is_empty() { return Some((vec![Transform::identity()], first.clone())); } for (i, s) in rest.iter().enumerate() { let s = s.borrow(); for (transform, transformed_scanner) in first.candidates_for_merge(s) { let merged_scanner = first.merged_with(&transformed_scanner); let new_scanners = std::iter::once(&merged_scanner) .chain(rest.iter().enumerate().filter_map(|(j, s)| { if i == j { None } else { Some(s.borrow()) } })) .collect::>(); let merge_result = Scanner::merge_all(new_scanners); if let Some((transforms, ans)) = merge_result { return Some((std::iter::once(transform).chain(transforms).collect(), ans)); } } } None } } fn read_input(s: &str) -> Option> { let mut scanners = vec![]; let mut this_scanner_beacons = BTreeSet::new(); for line in s.lines().chain(std::iter::once(\"\")) { if line.starts_with(\"---\") { continue; } if line.is_empty() { scanners.push(Scanner::new(this_scanner_beacons.clone())); this_scanner_beacons.clear(); } else { let mut comps = line.split(','); let [x, y, z] = [0; 3].map(|_| comps.next()?.parse().ok()); let [x, y, z] = [x?, y?, z?]; this_scanner_beacons.insert([x, y, z]); } } Some(scanners) } fn ans_for_input(input: &str) -> Answer { let scanners = read_input(input).unwrap(); let (transforms, scanner) = Scanner::merge_all(scanners).unwrap(); let translations = transforms.iter().map(|t| t.translation).collect::>(); (19, (pt1(&scanner), pt2(&translations))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(scanner: &Scanner) -> usize { scanner.beacons.len() } // end::pt1[] // tag::pt2[] fn pt2>(translations: V) -> u32 { let translations = translations.as_ref(); let mut max_manh_dist = u32::MIN; for (i, translation1) in translations.iter().enumerate() { let [x1, y1, z1] = translation1.0; for translation2 in translations.iter().skip(i + 1) { let [x2, y2, z2] = translation2.0; let diff = Translation([x2 - x1, y2 - y1, z2 - z1]); max_manh_dist = max_manh_dist.max(diff.manhattan_dist()); } } max_manh_dist } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { assert!( cfg!(not(debug_assertions)), \"Day 19 may not be tested in debug mode; it requires --release\" ); test_input!(include_str!(\"input.txt\"), day: 19, ans: (385, 10707)); } } Part 2 asks us to find the maximum Manhattan distance between scanners. To do this, we have to track the transformation of each scanner in the successful merge; we then read the pairwise Manhattan distances from each scanner’s transformation’s translation. // tag::setup[] use crate::Answer; use std::{borrow::Borrow, collections::BTreeSet}; use strum::IntoEnumIterator; use strum_macros::EnumIter; type Triple = [i32; 3]; #[derive(Debug, Clone, Copy)] struct Matrix3([i32; 9]); impl Matrix3 { fn from_cols(x: impl Into, y: impl Into, z: impl Into) -> Self { let x = x.into(); let y = y.into(); let z = z.into(); Self([x[0], y[0], z[0], x[1], y[1], z[1], x[2], y[2], z[2]]) } fn row(&self, i: usize) -> Triple { [0, 1, 2].map(|j| self.0[3 * i + j]) } fn col(&self, i: usize) -> Triple { [0, 1, 2].map(|j| self.0[i + 3 * j]) } fn mat_mul(&self, other: Self) -> Self { let mut entries = [0; 9]; let mut i = 0; for r in 0..3 { let self_row = self.row(r); for c in 0..3 { let other_col = other.col(c); entries[i] = (0..3).map(|i| self_row[i] * other_col[i]).sum(); i += 1; } } Self(entries) } fn mul_vec(&self, col: Triple) -> Triple { let mut entries = [0; 3]; for (r, elem) in entries.iter_mut().enumerate() { let self_row = self.row(r); *elem = (0..3).map(|i| self_row[i] * col[i]).sum(); } entries } } impl std::ops::Index for Matrix3 { type Output = i32; fn index(&self, index: [usize; 2]) -> &Self::Output { let [row, col] = index; &self.0[3 * row + col] } } #[derive(Clone, Copy, Debug, EnumIter, PartialEq, Eq, PartialOrd, Ord)] enum Axis { PosX, NegX, PosY, NegY, PosZ, NegZ, } impl From for Triple { fn from(axis: Axis) -> Self { use Axis::*; match axis { PosX => [1, 0, 0], NegX => [-1, 0, 0], PosY => [0, 1, 0], NegY => [0, -1, 0], PosZ => [0, 0, 1], NegZ => [0, 0, -1], } } } #[derive(Clone, Copy, Debug, EnumIter, PartialEq, Eq, PartialOrd, Ord)] enum RotationCcw { Zero, Quarter, Half, ThreeQuarters, } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Swivel { up_face: Axis, rotation_about_up: RotationCcw, } impl Swivel { fn new(up_face: Axis, rotation_about_up: RotationCcw) -> Self { Self { up_face, rotation_about_up, } } fn identity() -> Self { Self::new(Axis::PosZ, RotationCcw::Zero) } fn apply(self, point: Triple) -> Triple { use Axis::*; use RotationCcw::*; let mat_to_bring_face_to_up = match self.up_face { PosX => Matrix3::from_cols(PosZ, PosY, NegX), NegX => Matrix3::from_cols(NegZ, PosY, PosX), PosY => Matrix3::from_cols(PosX, PosZ, NegY), NegY => Matrix3::from_cols(PosX, NegZ, PosY), PosZ => Matrix3::from_cols(PosX, PosY, PosZ), NegZ => { // We have a couple options; we pick the one that rotates about the y axis // because it's easier to actually rotate my hand that way Matrix3::from_cols(NegX, PosY, NegZ) } }; let mat_to_rotate_about_up = match self.rotation_about_up { Zero => Matrix3::from_cols(PosX, PosY, PosZ), Quarter => Matrix3::from_cols(PosY, NegX, PosZ), Half => Matrix3::from_cols(NegX, NegY, PosZ), ThreeQuarters => Matrix3::from_cols(NegY, PosX, PosZ), }; mat_to_bring_face_to_up .mat_mul(mat_to_rotate_about_up) .mul_vec(point) } } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Translation(Triple); impl Translation { fn identity() -> Self { Self([0, 0, 0]) } fn apply(&self, point: Triple) -> Triple { let [x, y, z] = point; let [tx, ty, tz] = self.0; [x + tx, y + ty, z + tz] } fn manhattan_dist(&self) -> u32 { let [x, y, z] = self.0; u32::try_from(x.abs() + y.abs() + z.abs()).unwrap() } } #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Transform { swivel: Swivel, translation: Translation, } impl From for Transform { fn from(swivel: Swivel) -> Self { Self { swivel, translation: Translation([0, 0, 0]), } } } impl From for Transform { fn from(translation: Translation) -> Self { Self { swivel: Swivel::new(Axis::PosZ, RotationCcw::Zero), translation, } } } impl Transform { fn identity() -> Self { Self { swivel: Swivel::identity(), translation: Translation::identity(), } } fn apply(&self, point: Triple) -> Triple { self.translation.apply(self.swivel.apply(point)) } } #[derive(Debug, Clone)] struct Scanner { beacons: BTreeSet, } impl Scanner { fn new(beacons: BTreeSet) -> Self { Self { beacons } } fn merged_with(&self, other: &Self) -> Self { Self { beacons: self.beacons.union(&other.beacons).copied().collect(), } } fn applying + Copy>(&self, transform: T) -> Self { let transform = transform.into(); Scanner::new(self.beacons.iter().map(|&p| transform.apply(p)).collect()) } fn candidates_for_merge(&self, other: &Scanner) -> Vec { let mut transforms = BTreeSet::new(); let mut candidates = vec![]; for up_face in Axis::iter() { for rotation in RotationCcw::iter() { let swivel = Swivel::new(up_face, rotation); let swiveled_other = other.applying(swivel); for swiveled_other_beacon in &swiveled_other.beacons { for this_beacon in &self.beacons { let translation = Translation( [0, 1, 2].map(|i| this_beacon[i] - swiveled_other_beacon[i]), ); let transformed_other = swiveled_other.applying(translation); if self .beacons .intersection(&transformed_other.beacons) .count() >= 12 { let transform = Transform { swivel, translation, }; let wasnt_present = transforms.insert(transform); if wasnt_present { candidates.push((transform, transformed_other)); } } } } } } candidates } fn merge_all>( scanners: impl AsRef, ) -> Option, Scanner)> { let scanners = scanners.as_ref(); let (first, rest) = scanners.split_first().unwrap(); let first = first.borrow(); if rest.is_empty() { return Some((vec![Transform::identity()], first.clone())); } for (i, s) in rest.iter().enumerate() { let s = s.borrow(); for (transform, transformed_scanner) in first.candidates_for_merge(s) { let merged_scanner = first.merged_with(&transformed_scanner); let new_scanners = std::iter::once(&merged_scanner) .chain(rest.iter().enumerate().filter_map(|(j, s)| { if i == j { None } else { Some(s.borrow()) } })) .collect::>(); let merge_result = Scanner::merge_all(new_scanners); if let Some((transforms, ans)) = merge_result { return Some((std::iter::once(transform).chain(transforms).collect(), ans)); } } } None } } fn read_input(s: &str) -> Option> { let mut scanners = vec![]; let mut this_scanner_beacons = BTreeSet::new(); for line in s.lines().chain(std::iter::once(\"\")) { if line.starts_with(\"---\") { continue; } if line.is_empty() { scanners.push(Scanner::new(this_scanner_beacons.clone())); this_scanner_beacons.clear(); } else { let mut comps = line.split(','); let [x, y, z] = [0; 3].map(|_| comps.next()?.parse().ok()); let [x, y, z] = [x?, y?, z?]; this_scanner_beacons.insert([x, y, z]); } } Some(scanners) } fn ans_for_input(input: &str) -> Answer { let scanners = read_input(input).unwrap(); let (transforms, scanner) = Scanner::merge_all(scanners).unwrap(); let translations = transforms.iter().map(|t| t.translation).collect::>(); (19, (pt1(&scanner), pt2(&translations))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(scanner: &Scanner) -> usize { scanner.beacons.len() } // end::pt1[] // tag::pt2[] fn pt2>(translations: V) -> u32 { let translations = translations.as_ref(); let mut max_manh_dist = u32::MIN; for (i, translation1) in translations.iter().enumerate() { let [x1, y1, z1] = translation1.0; for translation2 in translations.iter().skip(i + 1) { let [x2, y2, z2] = translation2.0; let diff = Translation([x2 - x1, y2 - y1, z2 - z1]); max_manh_dist = max_manh_dist.max(diff.manhattan_dist()); } } max_manh_dist } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { assert!( cfg!(not(debug_assertions)), \"Day 19 may not be tested in debug mode; it requires --release\" ); test_input!(include_str!(\"input.txt\"), day: 19, ans: (385, 10707)); } }","title":"Day 19: Beacon Scanner","component":"ROOT","version":"","name":"soln","url":"/src/day_19/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"21":{"id":21,"text":"Day #20 problem description │ Problem input This problem asks us to manipulate an infinitely large binary array, whose elements we’ll refer to as pixels. Only a finite interior portion of the array has “actual” content, which we store in a 2D array. The infinite surrounding (exterior) area is either all-on or all-off, which we store in a single variable separate from the interior portion of the array. Transforming a pixel requires knowing the state of each of the eight pixels it is adjacent to. The rules are the same for each pixel, but how they are applied in practice depends on whether the pixel is interior or exterior. If a given pixel is only adjacent to other interior pixels, we just look at look at those eight surrounding interior pixels. If a pixel is adjacent to both interior and exterior pixels, then we look at both the array of interior pixels and the state of the exterior pixels. The exterior pixels that are adjacent to interior pixels become interior themselves as part of this update, as they no longer necessarily share their state with the rest of the monolithic exterior. Thus the interior portion grows each step. All other pixels are exterior and are surrounded only by other exterior pixels; therefore they are all updated in the same manner. Since the exterior starts out as all-off, it remains either all-on or all-off for the duration of the problem. // tag::setup[] use crate::{utils::to_decimal, Answer}; use ndarray::prelude::*; use std::fmt::{Display, Write}; type Bit = bool; #[derive(Debug, Clone)] struct Image { mat: Array2, surrounding: Bit, algo: Vec, } // tag::debugging[] impl Display for Image { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { writeln!(f, \"outer: {}\", self.surrounding)?; for r in 0..self.mat.nrows() { for c in 0..self.mat.ncols() { let bit = if self.mat[[r, c]] { '#' } else { '.' }; f.write_char(bit)?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] impl Image { fn from_str(s: &str) -> Option { let mut lines = s.lines(); let algo = lines .next()? .chars() .map(|c| match c { '#' => true, '.' => false, _ => unreachable!(), }) .collect(); let data = lines .flat_map(|line| { line.trim().chars().map(|c| match c { '#' => true, '.' => false, _ => unreachable!(), }) }) .collect::>(); let n_cols = s.lines().nth_back(0)?.trim().len(); let n_rows = data.len() / n_cols; assert_eq!(n_rows * n_cols, data.len()); Some(Self { mat: Array2::from_shape_vec((n_rows, n_cols), data).unwrap(), surrounding: false, algo, }) } fn tick(&mut self) { let new_surrounding = { let index = usize::try_from(to_decimal([self.surrounding; 9])).unwrap(); self.algo[index] }; let grown_mat = Array2::from_shape_fn((self.mat.nrows() + 2, self.mat.ncols() + 2), |(r, c)| { if r self.mat.nrows() || c self.mat.ncols() { self.surrounding } else { self.mat[[r - 1, c - 1]] } }); let mut new_mat = Array2::from_shape_simple_fn(grown_mat.dim(), || false); for center_row in 0..grown_mat.nrows() { for center_col in 0..grown_mat.ncols() { let mut surrounding_pixels = vec![]; let surrounding_rows = [ center_row.checked_sub(1), Some(center_row), (center_row + 1 grown_mat[[r, c]], _ => self.surrounding, }; surrounding_pixels.push(bit); } } let replacement = self.algo[usize::try_from(to_decimal(surrounding_pixels)).unwrap()]; new_mat[[center_row, center_col]] = replacement; } } self.mat = new_mat; self.surrounding = new_surrounding; } fn tick_n_times(&mut self, n: usize) { for _ in 0..n { self.tick(); } } } fn ans_for_input(input: &str) -> Answer { let im1 = Image::from_str(input).unwrap(); let im2 = im1.clone(); (20, (pt1(im1), pt2(im2))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(im: Image) -> usize { let mut im = im; im.tick_n_times(2); im.mat.map(|&bit| usize::from(bit)).sum() } // end::pt1[] // tag::pt2[] fn pt2(im: Image) -> usize { let mut im = im; im.tick_n_times(50); im.mat.map(|&bit| usize::from(bit)).sum() } //end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 20, ans: (5432, 16016)); } } Parts 1 and 2 are nearly identical; they both ask to count the number of “on” pixels in the image resulting after \\(k\\) updates, where Part 1 has \\(k=2\\) and Part 2 has \\(k=50\\). (Notably, if the exterior switches state every update, then the number of “on” pixels will be infinite after every odd-numbered update.) // tag::setup[] use crate::{utils::to_decimal, Answer}; use ndarray::prelude::*; use std::fmt::{Display, Write}; type Bit = bool; #[derive(Debug, Clone)] struct Image { mat: Array2, surrounding: Bit, algo: Vec, } // tag::debugging[] impl Display for Image { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { writeln!(f, \"outer: {}\", self.surrounding)?; for r in 0..self.mat.nrows() { for c in 0..self.mat.ncols() { let bit = if self.mat[[r, c]] { '#' } else { '.' }; f.write_char(bit)?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] impl Image { fn from_str(s: &str) -> Option { let mut lines = s.lines(); let algo = lines .next()? .chars() .map(|c| match c { '#' => true, '.' => false, _ => unreachable!(), }) .collect(); let data = lines .flat_map(|line| { line.trim().chars().map(|c| match c { '#' => true, '.' => false, _ => unreachable!(), }) }) .collect::>(); let n_cols = s.lines().nth_back(0)?.trim().len(); let n_rows = data.len() / n_cols; assert_eq!(n_rows * n_cols, data.len()); Some(Self { mat: Array2::from_shape_vec((n_rows, n_cols), data).unwrap(), surrounding: false, algo, }) } fn tick(&mut self) { let new_surrounding = { let index = usize::try_from(to_decimal([self.surrounding; 9])).unwrap(); self.algo[index] }; let grown_mat = Array2::from_shape_fn((self.mat.nrows() + 2, self.mat.ncols() + 2), |(r, c)| { if r self.mat.nrows() || c self.mat.ncols() { self.surrounding } else { self.mat[[r - 1, c - 1]] } }); let mut new_mat = Array2::from_shape_simple_fn(grown_mat.dim(), || false); for center_row in 0..grown_mat.nrows() { for center_col in 0..grown_mat.ncols() { let mut surrounding_pixels = vec![]; let surrounding_rows = [ center_row.checked_sub(1), Some(center_row), (center_row + 1 grown_mat[[r, c]], _ => self.surrounding, }; surrounding_pixels.push(bit); } } let replacement = self.algo[usize::try_from(to_decimal(surrounding_pixels)).unwrap()]; new_mat[[center_row, center_col]] = replacement; } } self.mat = new_mat; self.surrounding = new_surrounding; } fn tick_n_times(&mut self, n: usize) { for _ in 0..n { self.tick(); } } } fn ans_for_input(input: &str) -> Answer { let im1 = Image::from_str(input).unwrap(); let im2 = im1.clone(); (20, (pt1(im1), pt2(im2))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(im: Image) -> usize { let mut im = im; im.tick_n_times(2); im.mat.map(|&bit| usize::from(bit)).sum() } // end::pt1[] // tag::pt2[] fn pt2(im: Image) -> usize { let mut im = im; im.tick_n_times(50); im.mat.map(|&bit| usize::from(bit)).sum() } //end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 20, ans: (5432, 16016)); } }","title":"Day 20: Trench Map","component":"ROOT","version":"","name":"soln","url":"/src/day_20/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Parts 1 and 2","hash":"_parts_1_and_2","id":2}]},"22":{"id":22,"text":"Day #21 problem description │ Problem input This problem asks us to simulate a two-layer dice game. In this game, a move consists of rolling a die three times, adding up the rolled numbers, and then moving around the board based on the sum. In Part 1 we merely need to simulate this game for a deterministic die; this is so simple it’s not worth discussing. In Part 2 we need to count how many times each player wins across every possible sequence of die rolls. (Thankfully, the die in Part 2 only has three sides.) My first attempt at this actually went through every possible sequence. With a three-sided die, and games ranging in length from (say) 50 to 100 rolls, this was clearly computationally infeasible. To improve upon this, we note that while there are \\(3^3=27\\) ways to roll a three-sided die three times, there are only seven possible outcomes: the numbers 3 through 9. By precomputing the number of ways these sums can be rolled each turn, and then weighting each outcome by the number of ways it can be rolled, we cut down the base of the exponent by a factor of \\(\\frac{27}{7}\\), bringing the problem well into the realm of what is computationally feasible. // tag::setup[] use crate::Answer; type Players = [Player; 2]; fn read_input(s: &str) -> Option { s.lines() .map(|line| { line.split(':') .nth_back(0)? .trim() .parse() .ok() .map(Player::new) }) .collect::>>()? .try_into() .ok() } struct Board { size: usize, } #[derive(Debug, Clone, Copy)] struct Player { score: usize, position: usize, } impl Player { fn new(pos: usize) -> Self { Self { score: 0, position: pos, } } fn roll_value(&mut self, board: &Board, value: usize) { let new_pos = ((self.position + value - 1) % board.size) + 1; self.position = new_pos; self.score += new_pos; } fn roll_deterministic_die(&mut self, board: &Board, die: &mut DeterministicDie) { let move_dist = (0..3).map(|_| die.roll()).sum::(); self.roll_value(board, move_dist); } } #[derive(Clone, Copy)] struct DeterministicDie { next: usize, min: usize, max: usize, n_rolls: usize, } impl DeterministicDie { fn new(min: usize, max: usize) -> Self { Self { next: 1, min, max, n_rolls: 0, } } fn roll(&mut self) -> usize { if self.next > self.max { self.next = self.min; } let ret = self.next; self.next += 1; self.n_rolls += 1; ret } } fn ans_for_input(input: &str) -> Answer { let board = Board { size: 10 }; let players = read_input(input).unwrap(); ( 21, ( pt1(players, &board, DeterministicDie::new(1, 10)), pt2(players), ), ) .into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mut players: Players, board: &Board, die: DeterministicDie) -> usize { let mut die = die; let mut loser = players[1]; 'game: loop { for player in &mut players { player.roll_deterministic_die(board, &mut die); if player.score >= 1000 { break 'game; } loser = *player; } } die.n_rolls * loser.score } // end::pt1[] // tag::pt2[] #[derive(Debug)] struct Turn { players: Players, is_p0s_turn: bool, n_ways: usize, } fn play_quantum_dice( players: Players, board: &Board, die_n_faces: usize, n_rolls_per_turn: usize, win_threshold: usize, ) -> [usize; 2] { let mut tally = [0; 2]; let mut turn_stack = vec![Turn { players, is_p0s_turn: true, n_ways: 1, }]; // Pairs of `(dice sum, # ways)` let outcome_counts: [(usize, usize); 7] = { let max_sum = die_n_faces * n_rolls_per_turn; let mut counts = vec![0; max_sum + 1]; for r1 in 1..=die_n_faces { for r2 in 1..=die_n_faces { for r3 in 1..=die_n_faces { counts[r1 + r2 + r3] += 1; } } } counts .iter() .enumerate() .filter_map(|(i, &c)| if c > 0 { Some((i, c)) } else { None }) .collect::>() .try_into() .unwrap() }; while let Some(Turn { players, is_p0s_turn, n_ways: n_ways_to_have_gotten_here, }) = turn_stack.pop() { let player_index = if is_p0s_turn { 0 } else { 1 }; for (roll_value, n_ways_to_roll_this) in outcome_counts { let n_ways_to_get_here = n_ways_to_have_gotten_here * n_ways_to_roll_this; let mut player = players[player_index]; player.roll_value(board, roll_value); if player.score >= win_threshold { tally[player_index] += n_ways_to_get_here; } else { let mut players = players; players[player_index] = player; turn_stack.push(Turn { players, is_p0s_turn: !is_p0s_turn, n_ways: n_ways_to_get_here, }); } } } tally } fn pt2(players: Players) -> usize { let [p1_n_wins, p2_n_wins] = play_quantum_dice(players, &Board { size: 10 }, 3, 3, 21); p1_n_wins.max(p2_n_wins) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 21, ans: (757_770, 712_381_680_443_927)); } } // tag::setup[] use crate::Answer; type Players = [Player; 2]; fn read_input(s: &str) -> Option { s.lines() .map(|line| { line.split(':') .nth_back(0)? .trim() .parse() .ok() .map(Player::new) }) .collect::>>()? .try_into() .ok() } struct Board { size: usize, } #[derive(Debug, Clone, Copy)] struct Player { score: usize, position: usize, } impl Player { fn new(pos: usize) -> Self { Self { score: 0, position: pos, } } fn roll_value(&mut self, board: &Board, value: usize) { let new_pos = ((self.position + value - 1) % board.size) + 1; self.position = new_pos; self.score += new_pos; } fn roll_deterministic_die(&mut self, board: &Board, die: &mut DeterministicDie) { let move_dist = (0..3).map(|_| die.roll()).sum::(); self.roll_value(board, move_dist); } } #[derive(Clone, Copy)] struct DeterministicDie { next: usize, min: usize, max: usize, n_rolls: usize, } impl DeterministicDie { fn new(min: usize, max: usize) -> Self { Self { next: 1, min, max, n_rolls: 0, } } fn roll(&mut self) -> usize { if self.next > self.max { self.next = self.min; } let ret = self.next; self.next += 1; self.n_rolls += 1; ret } } fn ans_for_input(input: &str) -> Answer { let board = Board { size: 10 }; let players = read_input(input).unwrap(); ( 21, ( pt1(players, &board, DeterministicDie::new(1, 10)), pt2(players), ), ) .into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mut players: Players, board: &Board, die: DeterministicDie) -> usize { let mut die = die; let mut loser = players[1]; 'game: loop { for player in &mut players { player.roll_deterministic_die(board, &mut die); if player.score >= 1000 { break 'game; } loser = *player; } } die.n_rolls * loser.score } // end::pt1[] // tag::pt2[] #[derive(Debug)] struct Turn { players: Players, is_p0s_turn: bool, n_ways: usize, } fn play_quantum_dice( players: Players, board: &Board, die_n_faces: usize, n_rolls_per_turn: usize, win_threshold: usize, ) -> [usize; 2] { let mut tally = [0; 2]; let mut turn_stack = vec![Turn { players, is_p0s_turn: true, n_ways: 1, }]; // Pairs of `(dice sum, # ways)` let outcome_counts: [(usize, usize); 7] = { let max_sum = die_n_faces * n_rolls_per_turn; let mut counts = vec![0; max_sum + 1]; for r1 in 1..=die_n_faces { for r2 in 1..=die_n_faces { for r3 in 1..=die_n_faces { counts[r1 + r2 + r3] += 1; } } } counts .iter() .enumerate() .filter_map(|(i, &c)| if c > 0 { Some((i, c)) } else { None }) .collect::>() .try_into() .unwrap() }; while let Some(Turn { players, is_p0s_turn, n_ways: n_ways_to_have_gotten_here, }) = turn_stack.pop() { let player_index = if is_p0s_turn { 0 } else { 1 }; for (roll_value, n_ways_to_roll_this) in outcome_counts { let n_ways_to_get_here = n_ways_to_have_gotten_here * n_ways_to_roll_this; let mut player = players[player_index]; player.roll_value(board, roll_value); if player.score >= win_threshold { tally[player_index] += n_ways_to_get_here; } else { let mut players = players; players[player_index] = player; turn_stack.push(Turn { players, is_p0s_turn: !is_p0s_turn, n_ways: n_ways_to_get_here, }); } } } tally } fn pt2(players: Players) -> usize { let [p1_n_wins, p2_n_wins] = play_quantum_dice(players, &Board { size: 10 }, 3, 3, 21); p1_n_wins.max(p2_n_wins) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 21, ans: (757_770, 712_381_680_443_927)); } } // tag::setup[] use crate::Answer; type Players = [Player; 2]; fn read_input(s: &str) -> Option { s.lines() .map(|line| { line.split(':') .nth_back(0)? .trim() .parse() .ok() .map(Player::new) }) .collect::>>()? .try_into() .ok() } struct Board { size: usize, } #[derive(Debug, Clone, Copy)] struct Player { score: usize, position: usize, } impl Player { fn new(pos: usize) -> Self { Self { score: 0, position: pos, } } fn roll_value(&mut self, board: &Board, value: usize) { let new_pos = ((self.position + value - 1) % board.size) + 1; self.position = new_pos; self.score += new_pos; } fn roll_deterministic_die(&mut self, board: &Board, die: &mut DeterministicDie) { let move_dist = (0..3).map(|_| die.roll()).sum::(); self.roll_value(board, move_dist); } } #[derive(Clone, Copy)] struct DeterministicDie { next: usize, min: usize, max: usize, n_rolls: usize, } impl DeterministicDie { fn new(min: usize, max: usize) -> Self { Self { next: 1, min, max, n_rolls: 0, } } fn roll(&mut self) -> usize { if self.next > self.max { self.next = self.min; } let ret = self.next; self.next += 1; self.n_rolls += 1; ret } } fn ans_for_input(input: &str) -> Answer { let board = Board { size: 10 }; let players = read_input(input).unwrap(); ( 21, ( pt1(players, &board, DeterministicDie::new(1, 10)), pt2(players), ), ) .into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(mut players: Players, board: &Board, die: DeterministicDie) -> usize { let mut die = die; let mut loser = players[1]; 'game: loop { for player in &mut players { player.roll_deterministic_die(board, &mut die); if player.score >= 1000 { break 'game; } loser = *player; } } die.n_rolls * loser.score } // end::pt1[] // tag::pt2[] #[derive(Debug)] struct Turn { players: Players, is_p0s_turn: bool, n_ways: usize, } fn play_quantum_dice( players: Players, board: &Board, die_n_faces: usize, n_rolls_per_turn: usize, win_threshold: usize, ) -> [usize; 2] { let mut tally = [0; 2]; let mut turn_stack = vec![Turn { players, is_p0s_turn: true, n_ways: 1, }]; // Pairs of `(dice sum, # ways)` let outcome_counts: [(usize, usize); 7] = { let max_sum = die_n_faces * n_rolls_per_turn; let mut counts = vec![0; max_sum + 1]; for r1 in 1..=die_n_faces { for r2 in 1..=die_n_faces { for r3 in 1..=die_n_faces { counts[r1 + r2 + r3] += 1; } } } counts .iter() .enumerate() .filter_map(|(i, &c)| if c > 0 { Some((i, c)) } else { None }) .collect::>() .try_into() .unwrap() }; while let Some(Turn { players, is_p0s_turn, n_ways: n_ways_to_have_gotten_here, }) = turn_stack.pop() { let player_index = if is_p0s_turn { 0 } else { 1 }; for (roll_value, n_ways_to_roll_this) in outcome_counts { let n_ways_to_get_here = n_ways_to_have_gotten_here * n_ways_to_roll_this; let mut player = players[player_index]; player.roll_value(board, roll_value); if player.score >= win_threshold { tally[player_index] += n_ways_to_get_here; } else { let mut players = players; players[player_index] = player; turn_stack.push(Turn { players, is_p0s_turn: !is_p0s_turn, n_ways: n_ways_to_get_here, }); } } } tally } fn pt2(players: Players) -> usize { let [p1_n_wins, p2_n_wins] = play_quantum_dice(players, &Board { size: 10 }, 3, 3, 21); p1_n_wins.max(p2_n_wins) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 21, ans: (757_770, 712_381_680_443_927)); } }","title":"Day 21: Dirac Dice","component":"ROOT","version":"","name":"soln","url":"/src/day_21/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Part 1","hash":"_part_1","id":2},{"text":"Part 2","hash":"_part_2","id":3}]},"23":{"id":23,"text":"Day #22 problem description │ Problem input This problem asks us to find the \\(1\\times1\\times1\\) cubes — “small cubes” — in 3D space that remain after sequentially turning on and turning off the small cubes contained in a sequence of upright 3D rectangular prisms with integer coordinates; we’ll refer to these prisms as “boxes”. We record which small cubes remain after each operation as a list of boxes containing those cubes; the question is then how to record the boxes that result after performing the sequence of additions and subtractions between boxes. In other words, if at stage \\(k\\) the “on” cubes are contained in boxes \\(B_1,\\ldots,B_n\\), and we switch off the small cubes in \\(B_{n+1}\\), what set of boxes now contains the remaining “on” cubes? For simplicity, we’ll refer to the process of turning on the small cubes in a box \\(B\\) as “adding” \\(B\\), and turning off the cubes in \\(B\\) as “subtracting” \\(B\\). To subtract a single box \\(B_2\\) from another box \\(B_1\\), we first note that we only need to subtract the intersection \\(B_3\\coloneqq B_1\\cap B_2\\) of the two boxes from \\(B_1\\). Then, to subtract \\(B_3\\) from \\(B_1\\), we note that each maximal set of parallel edges of \\(B_3\\) divides the corresponding axis of \\(B_1\\) into three (potentially empty) regions: the parts before, between, and after their endpoints. For instance, if \\(B_3\\) has edge \\( ( (x_1,y,z) , (x_2,y,z) )\\) with \\(x_1 usize { fn width(span: Span) -> usize { usize::try_from(span[1] - span[0] + 1).unwrap() } let &Cuboid { x_range, y_range, z_range, } = self; width(x_range) * width(y_range) * width(z_range) } } // tag::debugging[] impl std::fmt::Display for Cuboid { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let [x0, x1] = &self.x_range; let [y0, y1] = &self.y_range; let [z0, z1] = &self.z_range; write!(f, \"{:?}-{:?},{:?}-{:?},{:?}-{:?}\", x0, x1, y0, y1, z0, z1) } } // end::debugging[] impl Cuboid { fn intersection(&self, other: &Self) -> Option { fn span_intersection(span1: Span, span2: Span) -> Option { let lower = span1[0].max(span2[0]); let upper = span1[1].min(span2[1]); if upper Vec { fn get_spans(my_span: Span, intersection_span: Span) -> [Option; 3] { let span1 = if my_span[0] == intersection_span[0] { None } else { Some([my_span[0], intersection_span[0] - 1]) }; let span2 = Some(intersection_span); let span3 = if intersection_span[1] == my_span[1] { None } else { Some([intersection_span[1] + 1, my_span[1]]) }; [span1, span2, span3] } let intersection = match self.intersection(other) { Some(c) => c, None => return vec![*self], }; let x_ranges = get_spans(self.x_range, intersection.x_range); let y_ranges = get_spans(self.y_range, intersection.y_range); let z_ranges = get_spans(self.z_range, intersection.z_range); let mut on_cuboids = Vec::::new(); for &x_range in x_ranges.iter().flatten() { for &y_range in y_ranges.iter().flatten() { for &z_range in z_ranges.iter().flatten() { if x_range != intersection.x_range || y_range != intersection.y_range || z_range != intersection.z_range { on_cuboids.push(Cuboid { x_range, y_range, z_range, }); } } } } // Iteratively merge the split-up cuboids together, where possible. For instance, // if the middle of a cuboid was removed, there are 26 small cuboids created, but they // can be merged into six larger cuboids. This is done by looking for abutting // cuboids with the same dimensions along their respective abutting faces and // combining them into one cuboid. 'merge: loop { for ( i, &c1 @ Cuboid { x_range, y_range, z_range, }, ) in on_cuboids.iter().enumerate() { for (j, &c2) in on_cuboids.iter().enumerate().skip(i + 1) { let mut cs = [c1, c2]; let mut merged_cuboid = None; if y_range == c2.y_range && z_range == c2.z_range { cs.sort_by_key(|c| c.x_range); if cs[0].x_range[1] == cs[1].x_range[0] - 1 { merged_cuboid = Some(Cuboid { x_range: [cs[0].x_range[0], cs[1].x_range[1]], y_range, z_range, }); } } else if x_range == c2.x_range && z_range == c2.z_range { cs.sort_by_key(|c| c.y_range); if cs[0].y_range[1] == cs[1].y_range[0] - 1 { merged_cuboid = Some(Cuboid { x_range, y_range: [cs[0].y_range[0], cs[1].y_range[1]], z_range, }); } } else if x_range == c2.x_range && y_range == c2.y_range { cs.sort_by_key(|c| c.z_range); if cs[0].z_range[1] == cs[1].z_range[0] - 1 { merged_cuboid = Some(Cuboid { x_range, y_range, z_range: [cs[0].z_range[0], cs[1].z_range[1]], }); } } if let Some(merged_cuboid) = merged_cuboid { on_cuboids.swap_remove(j); on_cuboids.swap_remove(i); on_cuboids.push(merged_cuboid); continue 'merge; } } } break; } on_cuboids } } impl Cuboid { fn from_coords_str(s: &str) -> Option { let mut coords = s.split(','); let mut comps = (0..3).filter_map(|_| { coords .next()? .split('=') .nth_back(0)? .split('.') .filter_map(|splat| splat.parse().ok()) .collect::>() .try_into() .ok() }); let x_range = comps.next()?; let y_range = comps.next()?; let z_range = comps.next()?; Some(Self { x_range, y_range, z_range, }) } } #[derive(Debug, Clone, Copy)] enum State { On, Off, } impl State { fn from_str(s: &str) -> Option { Some(match s { \"on\" => Self::On, \"off\" => Self::Off, _ => return None, }) } } #[derive(Debug, Clone, Copy)] struct RebootStep { state: State, cuboid: Cuboid, } // tag::debugging[] impl Display for RebootStep { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { f.write_char(match self.state { State::On => '▲', State::Off => '▽', })?; f.write_char(' ')?; let Cuboid { x_range, y_range, z_range, } = &self.cuboid; write!(f, \"{:?} {:?} {:?}\", x_range, y_range, z_range) } } // end::debugging[] impl RebootStep { fn from_line(line: &str) -> Option { let mut str_comps = line.split_ascii_whitespace(); let state = State::from_str(str_comps.next()?)?; let cuboid = Cuboid::from_coords_str(str_comps.next()?)?; Some(Self { state, cuboid }) } } #[derive(Debug)] struct Grid { on_cuboids: Vec, bounds: Option, } impl Grid { fn new_with_size(n: i32) -> Self { Grid { on_cuboids: vec![], bounds: Some(Cuboid { x_range: [-n, n], y_range: [-n, n], z_range: [-n, n], }), } } fn new_unbounded() -> Self { Grid { on_cuboids: vec![], bounds: None, } } fn apply_step(&mut self, RebootStep { state, cuboid }: &RebootStep) -> Option { let cuboid = if let Some(bounds) = self.bounds { cuboid.intersection(&bounds)? } else { *cuboid }; match state { State::On => { self.on_cuboids.push(cuboid); } State::Off => { let mut on_cuboids = vec![]; for my_cuboid in &self.on_cuboids { on_cuboids.extend(my_cuboid.difference(&cuboid)); } self.on_cuboids = on_cuboids; } }; Some(()) } fn n_on(&self) -> usize { let mut nonintersecting_cuboids = vec![]; for (i, &c1) in self.on_cuboids.iter().enumerate() { let mut pieces = vec![c1]; for &c2 in self.on_cuboids.iter().skip(i + 1) { pieces = pieces .into_iter() .flat_map(|piece| piece.difference(&c2)) .collect(); } nonintersecting_cuboids.extend(pieces); } nonintersecting_cuboids .iter() .fold(0, |accum, cuboid| accum + cuboid.size()) } } fn read_input(input: &str) -> Option> { input .lines() .map(RebootStep::from_line) .collect::>>() } fn ans_for_input(input: &str) -> Answer { let steps = read_input(input).unwrap(); (22, (pt1(steps.iter()), pt2(steps.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(steps: impl Iterator) -> usize { let mut grid = Grid::new_with_size(50); for step in steps { grid.apply_step(step.borrow()); } grid.n_on() } // end::pt1[] // tag::pt2[] fn pt2>(steps: impl Iterator) -> usize { let mut grid = Grid::new_unbounded(); for step in steps { grid.apply_step(step.borrow()); } grid.n_on() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 22, ans: (607_657, 1_187_742_789_778_677)); } } Parts 1 and 2 ask us to perform the same sequence of operations. In Part 1 this sequence occurs is in a bounded space (presumably in a space small enough for it to have been feasible to store each small cube individually). In Part 2 this sequence occurs in an unbounded space, which is where the savings that come from doing cube intersections become important. // tag::setup[] use crate::Answer; use std::fmt::{Display, Write}; type Span = [i32; 2]; #[derive(Debug, Clone, Copy)] struct Cuboid { x_range: Span, y_range: Span, z_range: Span, } impl Cuboid { fn size(&self) -> usize { fn width(span: Span) -> usize { usize::try_from(span[1] - span[0] + 1).unwrap() } let &Cuboid { x_range, y_range, z_range, } = self; width(x_range) * width(y_range) * width(z_range) } } // tag::debugging[] impl std::fmt::Display for Cuboid { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let [x0, x1] = &self.x_range; let [y0, y1] = &self.y_range; let [z0, z1] = &self.z_range; write!(f, \"{:?}-{:?},{:?}-{:?},{:?}-{:?}\", x0, x1, y0, y1, z0, z1) } } // end::debugging[] impl Cuboid { fn intersection(&self, other: &Self) -> Option { fn span_intersection(span1: Span, span2: Span) -> Option { let lower = span1[0].max(span2[0]); let upper = span1[1].min(span2[1]); if upper Vec { fn get_spans(my_span: Span, intersection_span: Span) -> [Option; 3] { let span1 = if my_span[0] == intersection_span[0] { None } else { Some([my_span[0], intersection_span[0] - 1]) }; let span2 = Some(intersection_span); let span3 = if intersection_span[1] == my_span[1] { None } else { Some([intersection_span[1] + 1, my_span[1]]) }; [span1, span2, span3] } let intersection = match self.intersection(other) { Some(c) => c, None => return vec![*self], }; let x_ranges = get_spans(self.x_range, intersection.x_range); let y_ranges = get_spans(self.y_range, intersection.y_range); let z_ranges = get_spans(self.z_range, intersection.z_range); let mut on_cuboids = Vec::::new(); for &x_range in x_ranges.iter().flatten() { for &y_range in y_ranges.iter().flatten() { for &z_range in z_ranges.iter().flatten() { if x_range != intersection.x_range || y_range != intersection.y_range || z_range != intersection.z_range { on_cuboids.push(Cuboid { x_range, y_range, z_range, }); } } } } // Iteratively merge the split-up cuboids together, where possible. For instance, // if the middle of a cuboid was removed, there are 26 small cuboids created, but they // can be merged into six larger cuboids. This is done by looking for abutting // cuboids with the same dimensions along their respective abutting faces and // combining them into one cuboid. 'merge: loop { for ( i, &c1 @ Cuboid { x_range, y_range, z_range, }, ) in on_cuboids.iter().enumerate() { for (j, &c2) in on_cuboids.iter().enumerate().skip(i + 1) { let mut cs = [c1, c2]; let mut merged_cuboid = None; if y_range == c2.y_range && z_range == c2.z_range { cs.sort_by_key(|c| c.x_range); if cs[0].x_range[1] == cs[1].x_range[0] - 1 { merged_cuboid = Some(Cuboid { x_range: [cs[0].x_range[0], cs[1].x_range[1]], y_range, z_range, }); } } else if x_range == c2.x_range && z_range == c2.z_range { cs.sort_by_key(|c| c.y_range); if cs[0].y_range[1] == cs[1].y_range[0] - 1 { merged_cuboid = Some(Cuboid { x_range, y_range: [cs[0].y_range[0], cs[1].y_range[1]], z_range, }); } } else if x_range == c2.x_range && y_range == c2.y_range { cs.sort_by_key(|c| c.z_range); if cs[0].z_range[1] == cs[1].z_range[0] - 1 { merged_cuboid = Some(Cuboid { x_range, y_range, z_range: [cs[0].z_range[0], cs[1].z_range[1]], }); } } if let Some(merged_cuboid) = merged_cuboid { on_cuboids.swap_remove(j); on_cuboids.swap_remove(i); on_cuboids.push(merged_cuboid); continue 'merge; } } } break; } on_cuboids } } impl Cuboid { fn from_coords_str(s: &str) -> Option { let mut coords = s.split(','); let mut comps = (0..3).filter_map(|_| { coords .next()? .split('=') .nth_back(0)? .split('.') .filter_map(|splat| splat.parse().ok()) .collect::>() .try_into() .ok() }); let x_range = comps.next()?; let y_range = comps.next()?; let z_range = comps.next()?; Some(Self { x_range, y_range, z_range, }) } } #[derive(Debug, Clone, Copy)] enum State { On, Off, } impl State { fn from_str(s: &str) -> Option { Some(match s { \"on\" => Self::On, \"off\" => Self::Off, _ => return None, }) } } #[derive(Debug, Clone, Copy)] struct RebootStep { state: State, cuboid: Cuboid, } // tag::debugging[] impl Display for RebootStep { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { f.write_char(match self.state { State::On => '▲', State::Off => '▽', })?; f.write_char(' ')?; let Cuboid { x_range, y_range, z_range, } = &self.cuboid; write!(f, \"{:?} {:?} {:?}\", x_range, y_range, z_range) } } // end::debugging[] impl RebootStep { fn from_line(line: &str) -> Option { let mut str_comps = line.split_ascii_whitespace(); let state = State::from_str(str_comps.next()?)?; let cuboid = Cuboid::from_coords_str(str_comps.next()?)?; Some(Self { state, cuboid }) } } #[derive(Debug)] struct Grid { on_cuboids: Vec, bounds: Option, } impl Grid { fn new_with_size(n: i32) -> Self { Grid { on_cuboids: vec![], bounds: Some(Cuboid { x_range: [-n, n], y_range: [-n, n], z_range: [-n, n], }), } } fn new_unbounded() -> Self { Grid { on_cuboids: vec![], bounds: None, } } fn apply_step(&mut self, RebootStep { state, cuboid }: &RebootStep) -> Option { let cuboid = if let Some(bounds) = self.bounds { cuboid.intersection(&bounds)? } else { *cuboid }; match state { State::On => { self.on_cuboids.push(cuboid); } State::Off => { let mut on_cuboids = vec![]; for my_cuboid in &self.on_cuboids { on_cuboids.extend(my_cuboid.difference(&cuboid)); } self.on_cuboids = on_cuboids; } }; Some(()) } fn n_on(&self) -> usize { let mut nonintersecting_cuboids = vec![]; for (i, &c1) in self.on_cuboids.iter().enumerate() { let mut pieces = vec![c1]; for &c2 in self.on_cuboids.iter().skip(i + 1) { pieces = pieces .into_iter() .flat_map(|piece| piece.difference(&c2)) .collect(); } nonintersecting_cuboids.extend(pieces); } nonintersecting_cuboids .iter() .fold(0, |accum, cuboid| accum + cuboid.size()) } } fn read_input(input: &str) -> Option> { input .lines() .map(RebootStep::from_line) .collect::>>() } fn ans_for_input(input: &str) -> Answer { let steps = read_input(input).unwrap(); (22, (pt1(steps.iter()), pt2(steps.iter()))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1>(steps: impl Iterator) -> usize { let mut grid = Grid::new_with_size(50); for step in steps { grid.apply_step(step.borrow()); } grid.n_on() } // end::pt1[] // tag::pt2[] fn pt2>(steps: impl Iterator) -> usize { let mut grid = Grid::new_unbounded(); for step in steps { grid.apply_step(step.borrow()); } grid.n_on() } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 22, ans: (607_657, 1_187_742_789_778_677)); } }","title":"Day 22: Reactor Reboot","component":"ROOT","version":"","name":"soln","url":"/src/day_22/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Parts 1 and 2","hash":"_parts_1_and_2","id":2}]},"24":{"id":24,"text":"Day #23 problem description │ Problem input We have to find the ways that agents (amphipods) can move from some initial on a grid to some final state given a number of movement constraints. Each agent has a different cost associated with movement. This is another classic graph exploration problem solvable with a priority queue; unfortunately a naive solution is computationally infeasible. The crux of solving this problem efficiently is realizing that there are many, many equivalent sequences of moves; rather than consider them all, we only consider those comprised of the fewest atomic moves in which, roughly speaking, a single amphipod moves as far as possible. Some examples of simplifications to the ruleset: It makes no sense to consider an amphipod moving within its initial room unless that move takes it out of the room; a disjoint sequence of moves inside the room can be reordered into a single move from the starting point to the room’s doorway. No amphipod should ever move deeper into its initial room; it should only ever move toward the doorway, and then from the doorway to some spot in the hallway. The rules state that an amphipod can only move into its final side room when it is already possible to move into the last unoccupied square in that room. Therefore, when an amphipod currently in the hallway moves from the hallway into its final side room, it should move as far into that side room as possible. Considering all simplifications and move reorderings, there are in fact only a handful of moves worth considering at each stage: An amphipod at its starting point in some side room can move to somewhere in the hallway as long as that starting point isn’t also its final destination. As long as any amphipod can move to its final spot in its final side room, it should move there on this move. In other words, no amphipod should move while another amphipod can move to its final destination, as this move would be a needless entry in the priority queue. (If two amphipods can both move to their final side rooms, pick one for this turn arbitrarily.) An amphipod that is currently in its final position — as far to the back in its side room as it can go, with no other-kinded amphipods between it and the back of its room — should not move at all. This keeps the number of moves considered tiny, making the search for the cheapest path through the graph run very quickly. Most of the setup is just creating an array wrapper type that is indexable by amphipods. (Thanks to Rust’s const generics, this type is statically sized.) This is achieved by simply assigning an integer from 0 to N_AMPHIPODS-1 to each amphipod and using that as the index. Because the arrays are static, we get an additional performance boost compared to using a heap-allocated Vec. (Due to laziness, I created two separate copies of the input, rather than perform the modification to the input for Part 2 as described in the problem statement.) // tag::amphipods[] use crate::{utils::abs_diff, Answer}; use hashbrown::hash_map::DefaultHashBuilder; use ndarray::prelude::*; use priority_queue::PriorityQueue; use std::{ collections::{BTreeMap as Map, BTreeSet}, fmt::Write, }; type Point = [usize; 2]; const ROW: usize = 0; const COL: usize = 1; #[derive(Eq, PartialEq, Debug)] struct Cost(usize); impl std::cmp::Ord for Cost { fn cmp(&self, other: &Self) -> std::cmp::Ordering { std::cmp::Reverse(self.0).cmp(&std::cmp::Reverse(other.0)) } } impl std::cmp::PartialOrd for Cost { fn partial_cmp(&self, other: &Self) -> Option { Some(self.cmp(other)) } } #[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)] #[repr(usize)] enum AmphipodKind { A = 0, B, C, D, } impl AmphipodKind { const fn n_kinds() -> usize { 4 } const fn from_usize(n: usize) -> Self { use AmphipodKind::*; match n { 0 => A, 1 => B, 2 => C, 3 => D, _ => panic!(\"Cannot construct an AmphipodKind from n >= 4\"), } } const fn from_char(c: char) -> Self { use AmphipodKind::*; match c { 'A' => A, 'B' => B, 'C' => C, 'D' => D, _ => panic!(\"Cannot construct an AmphipodKind from c not in [A, B, C, D]\"), } } const fn for_col(col: usize) -> Option { use AmphipodKind::*; Some(match col { 3 => A, 5 => B, 7 => C, 9 => D, _ => return None, }) } const fn dest_col(self) -> usize { use AmphipodKind::*; match self { A => 3, B => 5, C => 7, D => 9, } } // tag::debugging[] fn to_char(self) -> char { use AmphipodKind::*; match self { A => 'A', B => 'B', C => 'C', D => 'D', } } // end::debugging[] fn energy(self) -> usize { use AmphipodKind::*; match self { A => 1, B => 10, C => 100, D => 1000, } } } #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] struct Amphipod { kind: AmphipodKind, index: usize, } #[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)] struct AmphipodIndexed([T; N]); impl AmphipodIndexed { const fn n_amphipods_per_kind() -> usize { N / AmphipodKind::n_kinds() } const fn index_for(am: Amphipod) -> usize { Self::n_amphipods_per_kind() * (am.kind as usize) + am.index } fn iter_items(&self) -> impl Iterator { self.0.iter().enumerate().map(|(i, x)| { ( Amphipod { kind: AmphipodKind::from_usize(i / Self::n_amphipods_per_kind()), index: i % Self::n_amphipods_per_kind(), }, x, ) }) } } impl std::ops::Index for AmphipodIndexed { type Output = T; fn index(&self, am: Amphipod) -> &Self::Output { &self.0[Self::index_for(am)] } } impl std::ops::IndexMut for AmphipodIndexed { fn index_mut(&mut self, am: Amphipod) -> &mut Self::Output { &mut self.0[Self::index_for(am)] } } #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] enum Tile { Wall, Hallway, Doorway, SideRoom(AmphipodKind), } // tag::debugging[] impl Tile { fn to_char(self) -> char { use Tile::*; match self { Hallway | SideRoom(_) => '•', Doorway => '□', Wall => '#', } } } // end::debugging[] #[derive(Debug)] struct InstantiatedBurrow { burrow: Burrow, amphipod_locs: AmphipodIndexed, } impl InstantiatedBurrow { fn from_str(s: &str) -> Option { use Tile::*; let mut width = 0_usize; let mut height = 0_usize; let mut tiles_map = Map::new(); let mut amphipod_locs_map = Map::new(); let mut amphipod_kind_counts = [0_usize; 4]; for (row, line) in s.lines().enumerate() { height += 1; for (col, c) in line.chars().enumerate() { if row == 0 { width += 1; } let tile = match c { '#' | ' ' => Wall, '.' => Hallway, 'A' | 'B' | 'C' | 'D' => { let amphipod_kind = AmphipodKind::from_char(c); amphipod_locs_map.insert( Amphipod { kind: amphipod_kind, index: amphipod_kind_counts[amphipod_kind as usize], }, [row, col], ); amphipod_kind_counts[amphipod_kind as usize] += 1; SideRoom(AmphipodKind::for_col(col)?) } _ => return None, }; tiles_map.insert((row, col), tile); } } let mut tiles = Array2::from_shape_fn((height, width), |(row, col)| { *tiles_map.get(&(row, col)).unwrap_or(&Wall) }); for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { if matches!(tiles[[row, col]], Hallway) && matches!(tiles[[row + 1, col]], SideRoom(_)) { tiles[[row, col]] = Doorway; } } } let amphipod_locs = { let mut locs = AmphipodIndexed( vec![[usize::MAX; 2]; amphipod_locs_map.len()] .try_into() .unwrap(), ); for (&am, &loc) in &hipod_locs_map { locs[am] = loc; } locs }; Some(Self { burrow: Burrow { tiles }, amphipod_locs, }) } } // tag::debugging[] impl std::fmt::Display for InstantiatedBurrow { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let tiles = &self.burrow.tiles; let locs_amphipods = self .amphipod_locs .iter_items() .map(|(k, &v)| (v, k)) .collect::>(); for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { write!( f, \"{}\", match locs_amphipods.get(&[row, col]) { Some(am) => am.kind.to_char(), None => tiles[[row, col]].to_char(), } )?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] #[derive(Debug)] struct Burrow { tiles: Array2, } // end::amphipods[] // tag::debugging[] impl std::fmt::Display for Burrow { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let tiles = &self.tiles; for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { write!( f, \"{}\", match tiles[[row, col]] { Tile::SideRoom(kind) => kind.to_char(), tile => tile.to_char(), } )?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] // tag::solve[] impl Burrow { fn solve(&self, initial_locs: &AmphipodIndexed) -> Cost { const N_KINDS: usize = AmphipodKind::n_kinds(); #[derive(Debug)] struct Update { amphipod: Amphipod, n_steps: usize, new_state: SingleAmphipodState, } #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)] struct SingleAmphipodState { loc: Point, is_done: bool, } type AllAmphipodStates = AmphipodIndexed; fn enqueue( seen: &mut BTreeSet>, pq: &mut PriorityQueue, Cost, H>, state: AllAmphipodStates, cost: Cost, ) { if seen.contains(&state) { return; } seen.insert(state); pq.push_increase(state, cost); } let hallway_row = 1; let sideroom_max_row = self.tiles.nrows() - 2; let mut pq = PriorityQueue::::with_default_hasher(); let mut seen = BTreeSet::new(); let tiles = &self.tiles; let initial_state = AmphipodIndexed(initial_locs.0.map(|loc| SingleAmphipodState { loc, is_done: false, })); pq.push(initial_state, Cost(0)); let mut updates = Vec::new(); while let Some((total_state, cost)) = pq.pop() { updates.clear(); if total_state .iter_items() .all(|(am, state)| tiles[state.loc] == Tile::SideRoom(am.kind)) { return cost; } let amphipod_locs = total_state .iter_items() .map(|(am, state)| (state.loc, am)) .collect::>(); let n_in_correct_sideroom_by_kind = { let mut arr = [0_usize; N_KINDS]; for (am, state) in total_state.iter_items() { if tiles[state.loc] == Tile::SideRoom(am.kind) { arr[am.kind as usize] += 1; } } arr }; let siderooms_available_for_amphipods = [0, 1, 2, 3].zip([3, 5, 7, 9_usize]).map(|(i, col)| { (hallway_row + 1..=sideroom_max_row).all(|row| { amphipod_locs .get(&[row, col]) .map_or(true, |am| am.kind as usize == i) }) }); let update_that_moves_am_to_final_loc = total_state.iter_items().find_map(|(am, &state)| { if state.is_done || !siderooms_available_for_amphipods[am.kind as usize] { return None; } let curr_loc = state.loc; let dest_col = am.kind.dest_col(); let sideroom_last_empty_row = sideroom_max_row - n_in_correct_sideroom_by_kind[am.kind as usize]; let new_loc = [sideroom_last_empty_row, dest_col]; if curr_loc[COL] == dest_col && curr_loc[ROW] >= sideroom_last_empty_row { return Some(Update { amphipod: am, n_steps: 0, new_state: SingleAmphipodState { loc: curr_loc, is_done: true, }, }); } let [curr_row, curr_col] = curr_loc; for row in hallway_row..curr_row { if amphipod_locs.contains_key(&[row, curr_col]) { return None; } } #[allow(clippy::range_minus_one)] let col_range = if curr_col ; 2] { for col in range { let new_loc = [hallway_row, col]; if amphipod_locs.contains_key(&new_loc) || tiles[new_loc] == Tile::Wall { break; } if tiles[new_loc] == Tile::Doorway { continue; } updates.push(Update { amphipod: am, n_steps: n_steps_to_hallway + abs_diff(col, curr_loc[COL]), new_state: SingleAmphipodState { loc: new_loc, is_done: false, }, }); } } } } for &Update { amphipod: am, n_steps, new_state, } in &updates { let mut new_total_state = total_state; new_total_state[am] = new_state; enqueue( &mut seen, &mut pq, new_total_state, Cost(cost.0 + n_steps * am.kind.energy()), ); } } // tag::debugging[] for amphipod_locs in &seen { println!( \"{}\", InstantiatedBurrow { burrow: Burrow { tiles: tiles.clone() }, amphipod_locs: AmphipodIndexed(amphipod_locs.0.map(|state| state.loc)) } ); } // end::debugging[] panic!(\"Could not find a path to the finish line!\"); } } pub fn ans() -> Answer { (23, (pt1(), pt2())).into() } // end::solve[] // tag::pt1[] fn pt1() -> usize { let b = InstantiatedBurrow::::from_str(include_str!(\"input_1.txt\")).unwrap(); b.burrow.solve(&b.amphipod_locs).0 } // end::pt1[] // tag::pt2[] fn pt2() -> usize { let b = InstantiatedBurrow::::from_str(include_str!(\"input_2.txt\")).unwrap(); b.burrow.solve(&b.amphipod_locs).0 } // end::pt2[] #[cfg(test)] mod test { use super::*; #[test] fn test_pt1() { assert_eq!(pt1(), 16157); } #[test] fn test_pt2() { assert_eq!(pt2(), 43481); } } The Algorithm // tag::amphipods[] use crate::{utils::abs_diff, Answer}; use hashbrown::hash_map::DefaultHashBuilder; use ndarray::prelude::*; use priority_queue::PriorityQueue; use std::{ collections::{BTreeMap as Map, BTreeSet}, fmt::Write, }; type Point = [usize; 2]; const ROW: usize = 0; const COL: usize = 1; #[derive(Eq, PartialEq, Debug)] struct Cost(usize); impl std::cmp::Ord for Cost { fn cmp(&self, other: &Self) -> std::cmp::Ordering { std::cmp::Reverse(self.0).cmp(&std::cmp::Reverse(other.0)) } } impl std::cmp::PartialOrd for Cost { fn partial_cmp(&self, other: &Self) -> Option { Some(self.cmp(other)) } } #[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)] #[repr(usize)] enum AmphipodKind { A = 0, B, C, D, } impl AmphipodKind { const fn n_kinds() -> usize { 4 } const fn from_usize(n: usize) -> Self { use AmphipodKind::*; match n { 0 => A, 1 => B, 2 => C, 3 => D, _ => panic!(\"Cannot construct an AmphipodKind from n >= 4\"), } } const fn from_char(c: char) -> Self { use AmphipodKind::*; match c { 'A' => A, 'B' => B, 'C' => C, 'D' => D, _ => panic!(\"Cannot construct an AmphipodKind from c not in [A, B, C, D]\"), } } const fn for_col(col: usize) -> Option { use AmphipodKind::*; Some(match col { 3 => A, 5 => B, 7 => C, 9 => D, _ => return None, }) } const fn dest_col(self) -> usize { use AmphipodKind::*; match self { A => 3, B => 5, C => 7, D => 9, } } // tag::debugging[] fn to_char(self) -> char { use AmphipodKind::*; match self { A => 'A', B => 'B', C => 'C', D => 'D', } } // end::debugging[] fn energy(self) -> usize { use AmphipodKind::*; match self { A => 1, B => 10, C => 100, D => 1000, } } } #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] struct Amphipod { kind: AmphipodKind, index: usize, } #[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)] struct AmphipodIndexed([T; N]); impl AmphipodIndexed { const fn n_amphipods_per_kind() -> usize { N / AmphipodKind::n_kinds() } const fn index_for(am: Amphipod) -> usize { Self::n_amphipods_per_kind() * (am.kind as usize) + am.index } fn iter_items(&self) -> impl Iterator { self.0.iter().enumerate().map(|(i, x)| { ( Amphipod { kind: AmphipodKind::from_usize(i / Self::n_amphipods_per_kind()), index: i % Self::n_amphipods_per_kind(), }, x, ) }) } } impl std::ops::Index for AmphipodIndexed { type Output = T; fn index(&self, am: Amphipod) -> &Self::Output { &self.0[Self::index_for(am)] } } impl std::ops::IndexMut for AmphipodIndexed { fn index_mut(&mut self, am: Amphipod) -> &mut Self::Output { &mut self.0[Self::index_for(am)] } } #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] enum Tile { Wall, Hallway, Doorway, SideRoom(AmphipodKind), } // tag::debugging[] impl Tile { fn to_char(self) -> char { use Tile::*; match self { Hallway | SideRoom(_) => '•', Doorway => '□', Wall => '#', } } } // end::debugging[] #[derive(Debug)] struct InstantiatedBurrow { burrow: Burrow, amphipod_locs: AmphipodIndexed, } impl InstantiatedBurrow { fn from_str(s: &str) -> Option { use Tile::*; let mut width = 0_usize; let mut height = 0_usize; let mut tiles_map = Map::new(); let mut amphipod_locs_map = Map::new(); let mut amphipod_kind_counts = [0_usize; 4]; for (row, line) in s.lines().enumerate() { height += 1; for (col, c) in line.chars().enumerate() { if row == 0 { width += 1; } let tile = match c { '#' | ' ' => Wall, '.' => Hallway, 'A' | 'B' | 'C' | 'D' => { let amphipod_kind = AmphipodKind::from_char(c); amphipod_locs_map.insert( Amphipod { kind: amphipod_kind, index: amphipod_kind_counts[amphipod_kind as usize], }, [row, col], ); amphipod_kind_counts[amphipod_kind as usize] += 1; SideRoom(AmphipodKind::for_col(col)?) } _ => return None, }; tiles_map.insert((row, col), tile); } } let mut tiles = Array2::from_shape_fn((height, width), |(row, col)| { *tiles_map.get(&(row, col)).unwrap_or(&Wall) }); for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { if matches!(tiles[[row, col]], Hallway) && matches!(tiles[[row + 1, col]], SideRoom(_)) { tiles[[row, col]] = Doorway; } } } let amphipod_locs = { let mut locs = AmphipodIndexed( vec![[usize::MAX; 2]; amphipod_locs_map.len()] .try_into() .unwrap(), ); for (&am, &loc) in &hipod_locs_map { locs[am] = loc; } locs }; Some(Self { burrow: Burrow { tiles }, amphipod_locs, }) } } // tag::debugging[] impl std::fmt::Display for InstantiatedBurrow { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let tiles = &self.burrow.tiles; let locs_amphipods = self .amphipod_locs .iter_items() .map(|(k, &v)| (v, k)) .collect::>(); for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { write!( f, \"{}\", match locs_amphipods.get(&[row, col]) { Some(am) => am.kind.to_char(), None => tiles[[row, col]].to_char(), } )?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] #[derive(Debug)] struct Burrow { tiles: Array2, } // end::amphipods[] // tag::debugging[] impl std::fmt::Display for Burrow { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let tiles = &self.tiles; for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { write!( f, \"{}\", match tiles[[row, col]] { Tile::SideRoom(kind) => kind.to_char(), tile => tile.to_char(), } )?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] // tag::solve[] impl Burrow { fn solve(&self, initial_locs: &AmphipodIndexed) -> Cost { const N_KINDS: usize = AmphipodKind::n_kinds(); #[derive(Debug)] struct Update { amphipod: Amphipod, n_steps: usize, new_state: SingleAmphipodState, } #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)] struct SingleAmphipodState { loc: Point, is_done: bool, } type AllAmphipodStates = AmphipodIndexed; fn enqueue( seen: &mut BTreeSet>, pq: &mut PriorityQueue, Cost, H>, state: AllAmphipodStates, cost: Cost, ) { if seen.contains(&state) { return; } seen.insert(state); pq.push_increase(state, cost); } let hallway_row = 1; let sideroom_max_row = self.tiles.nrows() - 2; let mut pq = PriorityQueue::::with_default_hasher(); let mut seen = BTreeSet::new(); let tiles = &self.tiles; let initial_state = AmphipodIndexed(initial_locs.0.map(|loc| SingleAmphipodState { loc, is_done: false, })); pq.push(initial_state, Cost(0)); let mut updates = Vec::new(); while let Some((total_state, cost)) = pq.pop() { updates.clear(); if total_state .iter_items() .all(|(am, state)| tiles[state.loc] == Tile::SideRoom(am.kind)) { return cost; } let amphipod_locs = total_state .iter_items() .map(|(am, state)| (state.loc, am)) .collect::>(); let n_in_correct_sideroom_by_kind = { let mut arr = [0_usize; N_KINDS]; for (am, state) in total_state.iter_items() { if tiles[state.loc] == Tile::SideRoom(am.kind) { arr[am.kind as usize] += 1; } } arr }; let siderooms_available_for_amphipods = [0, 1, 2, 3].zip([3, 5, 7, 9_usize]).map(|(i, col)| { (hallway_row + 1..=sideroom_max_row).all(|row| { amphipod_locs .get(&[row, col]) .map_or(true, |am| am.kind as usize == i) }) }); let update_that_moves_am_to_final_loc = total_state.iter_items().find_map(|(am, &state)| { if state.is_done || !siderooms_available_for_amphipods[am.kind as usize] { return None; } let curr_loc = state.loc; let dest_col = am.kind.dest_col(); let sideroom_last_empty_row = sideroom_max_row - n_in_correct_sideroom_by_kind[am.kind as usize]; let new_loc = [sideroom_last_empty_row, dest_col]; if curr_loc[COL] == dest_col && curr_loc[ROW] >= sideroom_last_empty_row { return Some(Update { amphipod: am, n_steps: 0, new_state: SingleAmphipodState { loc: curr_loc, is_done: true, }, }); } let [curr_row, curr_col] = curr_loc; for row in hallway_row..curr_row { if amphipod_locs.contains_key(&[row, curr_col]) { return None; } } #[allow(clippy::range_minus_one)] let col_range = if curr_col ; 2] { for col in range { let new_loc = [hallway_row, col]; if amphipod_locs.contains_key(&new_loc) || tiles[new_loc] == Tile::Wall { break; } if tiles[new_loc] == Tile::Doorway { continue; } updates.push(Update { amphipod: am, n_steps: n_steps_to_hallway + abs_diff(col, curr_loc[COL]), new_state: SingleAmphipodState { loc: new_loc, is_done: false, }, }); } } } } for &Update { amphipod: am, n_steps, new_state, } in &updates { let mut new_total_state = total_state; new_total_state[am] = new_state; enqueue( &mut seen, &mut pq, new_total_state, Cost(cost.0 + n_steps * am.kind.energy()), ); } } // tag::debugging[] for amphipod_locs in &seen { println!( \"{}\", InstantiatedBurrow { burrow: Burrow { tiles: tiles.clone() }, amphipod_locs: AmphipodIndexed(amphipod_locs.0.map(|state| state.loc)) } ); } // end::debugging[] panic!(\"Could not find a path to the finish line!\"); } } pub fn ans() -> Answer { (23, (pt1(), pt2())).into() } // end::solve[] // tag::pt1[] fn pt1() -> usize { let b = InstantiatedBurrow::::from_str(include_str!(\"input_1.txt\")).unwrap(); b.burrow.solve(&b.amphipod_locs).0 } // end::pt1[] // tag::pt2[] fn pt2() -> usize { let b = InstantiatedBurrow::::from_str(include_str!(\"input_2.txt\")).unwrap(); b.burrow.solve(&b.amphipod_locs).0 } // end::pt2[] #[cfg(test)] mod test { use super::*; #[test] fn test_pt1() { assert_eq!(pt1(), 16157); } #[test] fn test_pt2() { assert_eq!(pt2(), 43481); } } // tag::amphipods[] use crate::{utils::abs_diff, Answer}; use hashbrown::hash_map::DefaultHashBuilder; use ndarray::prelude::*; use priority_queue::PriorityQueue; use std::{ collections::{BTreeMap as Map, BTreeSet}, fmt::Write, }; type Point = [usize; 2]; const ROW: usize = 0; const COL: usize = 1; #[derive(Eq, PartialEq, Debug)] struct Cost(usize); impl std::cmp::Ord for Cost { fn cmp(&self, other: &Self) -> std::cmp::Ordering { std::cmp::Reverse(self.0).cmp(&std::cmp::Reverse(other.0)) } } impl std::cmp::PartialOrd for Cost { fn partial_cmp(&self, other: &Self) -> Option { Some(self.cmp(other)) } } #[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)] #[repr(usize)] enum AmphipodKind { A = 0, B, C, D, } impl AmphipodKind { const fn n_kinds() -> usize { 4 } const fn from_usize(n: usize) -> Self { use AmphipodKind::*; match n { 0 => A, 1 => B, 2 => C, 3 => D, _ => panic!(\"Cannot construct an AmphipodKind from n >= 4\"), } } const fn from_char(c: char) -> Self { use AmphipodKind::*; match c { 'A' => A, 'B' => B, 'C' => C, 'D' => D, _ => panic!(\"Cannot construct an AmphipodKind from c not in [A, B, C, D]\"), } } const fn for_col(col: usize) -> Option { use AmphipodKind::*; Some(match col { 3 => A, 5 => B, 7 => C, 9 => D, _ => return None, }) } const fn dest_col(self) -> usize { use AmphipodKind::*; match self { A => 3, B => 5, C => 7, D => 9, } } // tag::debugging[] fn to_char(self) -> char { use AmphipodKind::*; match self { A => 'A', B => 'B', C => 'C', D => 'D', } } // end::debugging[] fn energy(self) -> usize { use AmphipodKind::*; match self { A => 1, B => 10, C => 100, D => 1000, } } } #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] struct Amphipod { kind: AmphipodKind, index: usize, } #[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)] struct AmphipodIndexed([T; N]); impl AmphipodIndexed { const fn n_amphipods_per_kind() -> usize { N / AmphipodKind::n_kinds() } const fn index_for(am: Amphipod) -> usize { Self::n_amphipods_per_kind() * (am.kind as usize) + am.index } fn iter_items(&self) -> impl Iterator { self.0.iter().enumerate().map(|(i, x)| { ( Amphipod { kind: AmphipodKind::from_usize(i / Self::n_amphipods_per_kind()), index: i % Self::n_amphipods_per_kind(), }, x, ) }) } } impl std::ops::Index for AmphipodIndexed { type Output = T; fn index(&self, am: Amphipod) -> &Self::Output { &self.0[Self::index_for(am)] } } impl std::ops::IndexMut for AmphipodIndexed { fn index_mut(&mut self, am: Amphipod) -> &mut Self::Output { &mut self.0[Self::index_for(am)] } } #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)] enum Tile { Wall, Hallway, Doorway, SideRoom(AmphipodKind), } // tag::debugging[] impl Tile { fn to_char(self) -> char { use Tile::*; match self { Hallway | SideRoom(_) => '•', Doorway => '□', Wall => '#', } } } // end::debugging[] #[derive(Debug)] struct InstantiatedBurrow { burrow: Burrow, amphipod_locs: AmphipodIndexed, } impl InstantiatedBurrow { fn from_str(s: &str) -> Option { use Tile::*; let mut width = 0_usize; let mut height = 0_usize; let mut tiles_map = Map::new(); let mut amphipod_locs_map = Map::new(); let mut amphipod_kind_counts = [0_usize; 4]; for (row, line) in s.lines().enumerate() { height += 1; for (col, c) in line.chars().enumerate() { if row == 0 { width += 1; } let tile = match c { '#' | ' ' => Wall, '.' => Hallway, 'A' | 'B' | 'C' | 'D' => { let amphipod_kind = AmphipodKind::from_char(c); amphipod_locs_map.insert( Amphipod { kind: amphipod_kind, index: amphipod_kind_counts[amphipod_kind as usize], }, [row, col], ); amphipod_kind_counts[amphipod_kind as usize] += 1; SideRoom(AmphipodKind::for_col(col)?) } _ => return None, }; tiles_map.insert((row, col), tile); } } let mut tiles = Array2::from_shape_fn((height, width), |(row, col)| { *tiles_map.get(&(row, col)).unwrap_or(&Wall) }); for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { if matches!(tiles[[row, col]], Hallway) && matches!(tiles[[row + 1, col]], SideRoom(_)) { tiles[[row, col]] = Doorway; } } } let amphipod_locs = { let mut locs = AmphipodIndexed( vec![[usize::MAX; 2]; amphipod_locs_map.len()] .try_into() .unwrap(), ); for (&am, &loc) in &hipod_locs_map { locs[am] = loc; } locs }; Some(Self { burrow: Burrow { tiles }, amphipod_locs, }) } } // tag::debugging[] impl std::fmt::Display for InstantiatedBurrow { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let tiles = &self.burrow.tiles; let locs_amphipods = self .amphipod_locs .iter_items() .map(|(k, &v)| (v, k)) .collect::>(); for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { write!( f, \"{}\", match locs_amphipods.get(&[row, col]) { Some(am) => am.kind.to_char(), None => tiles[[row, col]].to_char(), } )?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] #[derive(Debug)] struct Burrow { tiles: Array2, } // end::amphipods[] // tag::debugging[] impl std::fmt::Display for Burrow { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { let tiles = &self.tiles; for row in 0..tiles.nrows() { for col in 0..tiles.ncols() { write!( f, \"{}\", match tiles[[row, col]] { Tile::SideRoom(kind) => kind.to_char(), tile => tile.to_char(), } )?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] // tag::solve[] impl Burrow { fn solve(&self, initial_locs: &AmphipodIndexed) -> Cost { const N_KINDS: usize = AmphipodKind::n_kinds(); #[derive(Debug)] struct Update { amphipod: Amphipod, n_steps: usize, new_state: SingleAmphipodState, } #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)] struct SingleAmphipodState { loc: Point, is_done: bool, } type AllAmphipodStates = AmphipodIndexed; fn enqueue( seen: &mut BTreeSet>, pq: &mut PriorityQueue, Cost, H>, state: AllAmphipodStates, cost: Cost, ) { if seen.contains(&state) { return; } seen.insert(state); pq.push_increase(state, cost); } let hallway_row = 1; let sideroom_max_row = self.tiles.nrows() - 2; let mut pq = PriorityQueue::::with_default_hasher(); let mut seen = BTreeSet::new(); let tiles = &self.tiles; let initial_state = AmphipodIndexed(initial_locs.0.map(|loc| SingleAmphipodState { loc, is_done: false, })); pq.push(initial_state, Cost(0)); let mut updates = Vec::new(); while let Some((total_state, cost)) = pq.pop() { updates.clear(); if total_state .iter_items() .all(|(am, state)| tiles[state.loc] == Tile::SideRoom(am.kind)) { return cost; } let amphipod_locs = total_state .iter_items() .map(|(am, state)| (state.loc, am)) .collect::>(); let n_in_correct_sideroom_by_kind = { let mut arr = [0_usize; N_KINDS]; for (am, state) in total_state.iter_items() { if tiles[state.loc] == Tile::SideRoom(am.kind) { arr[am.kind as usize] += 1; } } arr }; let siderooms_available_for_amphipods = [0, 1, 2, 3].zip([3, 5, 7, 9_usize]).map(|(i, col)| { (hallway_row + 1..=sideroom_max_row).all(|row| { amphipod_locs .get(&[row, col]) .map_or(true, |am| am.kind as usize == i) }) }); let update_that_moves_am_to_final_loc = total_state.iter_items().find_map(|(am, &state)| { if state.is_done || !siderooms_available_for_amphipods[am.kind as usize] { return None; } let curr_loc = state.loc; let dest_col = am.kind.dest_col(); let sideroom_last_empty_row = sideroom_max_row - n_in_correct_sideroom_by_kind[am.kind as usize]; let new_loc = [sideroom_last_empty_row, dest_col]; if curr_loc[COL] == dest_col && curr_loc[ROW] >= sideroom_last_empty_row { return Some(Update { amphipod: am, n_steps: 0, new_state: SingleAmphipodState { loc: curr_loc, is_done: true, }, }); } let [curr_row, curr_col] = curr_loc; for row in hallway_row..curr_row { if amphipod_locs.contains_key(&[row, curr_col]) { return None; } } #[allow(clippy::range_minus_one)] let col_range = if curr_col ; 2] { for col in range { let new_loc = [hallway_row, col]; if amphipod_locs.contains_key(&new_loc) || tiles[new_loc] == Tile::Wall { break; } if tiles[new_loc] == Tile::Doorway { continue; } updates.push(Update { amphipod: am, n_steps: n_steps_to_hallway + abs_diff(col, curr_loc[COL]), new_state: SingleAmphipodState { loc: new_loc, is_done: false, }, }); } } } } for &Update { amphipod: am, n_steps, new_state, } in &updates { let mut new_total_state = total_state; new_total_state[am] = new_state; enqueue( &mut seen, &mut pq, new_total_state, Cost(cost.0 + n_steps * am.kind.energy()), ); } } // tag::debugging[] for amphipod_locs in &seen { println!( \"{}\", InstantiatedBurrow { burrow: Burrow { tiles: tiles.clone() }, amphipod_locs: AmphipodIndexed(amphipod_locs.0.map(|state| state.loc)) } ); } // end::debugging[] panic!(\"Could not find a path to the finish line!\"); } } pub fn ans() -> Answer { (23, (pt1(), pt2())).into() } // end::solve[] // tag::pt1[] fn pt1() -> usize { let b = InstantiatedBurrow::::from_str(include_str!(\"input_1.txt\")).unwrap(); b.burrow.solve(&b.amphipod_locs).0 } // end::pt1[] // tag::pt2[] fn pt2() -> usize { let b = InstantiatedBurrow::::from_str(include_str!(\"input_2.txt\")).unwrap(); b.burrow.solve(&b.amphipod_locs).0 } // end::pt2[] #[cfg(test)] mod test { use super::*; #[test] fn test_pt1() { assert_eq!(pt1(), 16157); } #[test] fn test_pt2() { assert_eq!(pt2(), 43481); } }","title":"Day 23: Amphipod","component":"ROOT","version":"","name":"soln","url":"/src/day_23/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Parts 1 and 2","hash":"_parts_1_and_2","id":2}]},"25":{"id":25,"text":"Day #24 problem description │ Problem input This problem asks us to do two things: Implement a simple processor, with four registers W, X, Y, and Z all initialized to 0, that accepts a program to run. Find the inputs to this program that will lead to the processor’s Z register containing 0 when its input has been entirely consumed, which we’ll refer to as “acceptable inputs”. The specific program that this problem gives us reads in 14 digits of input, so it looks something like this: read 1st digit of input into W register read 2nd digit of input into W register read 3rd digit of input into W register …​ read 14th digit of input into W register check if register Z is 0 We will refer to the list of instructions from one read instruction up to, but excluding, the next read instruction — such as the instructions contained in lines 1 and 2 of the above text — as an “instruction block”. Note that while the inputs to the program are digits in the range [1, 9], the registers can contain arbitrary integers. For instance the program could read 8 into W, copy W to X, read 9 into W, multiply W and X, and write the result to Z; then Z would have a value of 72. // tag::setup[] use crate::Answer; use std::{ collections::{BTreeMap as Map, BTreeSet as Set}, ops::{Index, IndexMut}, }; type Num = i32; type Output = String; #[derive(Debug, Clone, Copy)] enum Operand { Number(Num), Reg(Register), } impl Operand { fn from_str(s: &str) -> Option { use Operand::*; Some(match s.parse().ok() { Some(val) => Number(val), None => Reg(Register::from_str(s)?), }) } } #[derive(Debug, Clone, Copy)] enum MathOp { Add, Mul, Div, Mod, Eql, } impl MathOp { fn from_str(s: &str) -> Option { use MathOp::*; Some(match s { \"add\" => Add, \"mul\" => Mul, \"div\" => Div, \"mod\" => Mod, \"eql\" => Eql, _ => return None, }) } } #[derive(Debug, Clone)] struct MathInstr { operation: MathOp, register: Register, operand: Operand, } #[derive(Debug)] struct InstrBlock { in_reg: Register, instrs: Vec, } #[derive(Debug, Clone, Copy)] enum Register { W = 0, X, Y, Z, } impl Register { fn from_str(s: &str) -> Option { use Register::*; Some(match s { \"w\" => W, \"x\" => X, \"y\" => Y, \"z\" => Z, _ => return None, }) } } #[derive(Debug)] struct Alu { registers: [Num; 4], } impl Index for Alu { type Output = Num; fn index(&self, register: Register) -> &Self::Output { &self.registers[register as usize] } } impl IndexMut for Alu { fn index_mut(&mut self, register: Register) -> &mut Self::Output { &mut self.registers[register as usize] } } impl Alu { fn new() -> Self { Self { registers: [0; 4] } } fn run_block(&mut self, block: &InstrBlock, input: Num) { use MathOp::*; use Operand::*; self[block.in_reg] = input; for &MathInstr { operation, register, operand, } in &block.instrs { let value = match operand { Number(n) => n, Reg(register) => self[register], }; let r = &mut self[register]; match operation { Add => *r += value, Mul => *r *= value, Div => *r /= value, Mod => *r %= value, Eql => *r = if r == &value { 1 } else { 0 }, } } } fn from_running_block_on( block: &InstrBlock, input: Num, setup: impl FnOnce(&mut Self), ) -> Self { let mut alu = Alu::new(); setup(&mut alu); alu.run_block(block, input); alu } } fn read_input(s: &str) -> Option> { let mut blocks = vec![]; let mut curr_in_reg = None; let mut curr_instrs = vec![]; // Dummy input line at the end that tells the last block it's done for line in s.lines().chain(std::iter::once(\"inp x\")) { let mut splat = line.split_ascii_whitespace(); let instr_str = splat.next()?; if instr_str == \"inp\" { if let Some(r) = curr_in_reg { blocks.push(InstrBlock { in_reg: r, instrs: curr_instrs.clone(), }); } curr_in_reg = Some(Register::from_str(splat.next()?)?); curr_instrs.clear(); } else { let operation = MathOp::from_str(instr_str)?; let register = Register::from_str(splat.next()?)?; let operand = Operand::from_str(splat.next()?)?; curr_instrs.push(MathInstr { operation, register, operand, }); } } Some(blocks) } fn ans_for_input(input: &str) -> Answer { let blocks = read_input(input).unwrap(); let valid_zs = get_valid_zs(&blocks); (24, (pt1(&blocks, &valid_zs), pt2(&blocks, &valid_zs))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::algo[] fn get_valid_zs(blocks: impl AsRef) -> Vec> { let blocks = blocks.as_ref(); let n_digits = blocks.len(); let mut all_zs_ltr = vec![Map::new(); n_digits + 1]; all_zs_ltr.first_mut().unwrap().insert(0, Set::new()); for (digit_idx, block) in blocks.iter().enumerate() { let (all_prev_zs, all_next_zs) = all_zs_ltr.split_at_mut(digit_idx + 1); let prev_zs = &all_prev_zs[all_prev_zs.len() - 1]; let curr_zs = &mut all_next_zs[0]; for &prev_z in prev_zs.keys() { for digit in 1..=9 { let z = Alu::from_running_block_on(block, digit, |alu| alu[Register::Z] = prev_z) [Register::Z]; curr_zs.entry(z).or_insert_with(Set::new).insert(prev_z); } } // tag::debugging[] #[cfg(debug_assertions)] println!(\"{}: {:?}\", digit_idx, curr_zs.len()); // end::debugging[] } let mut all_valid_zs_rtl = vec![Set::new(); n_digits]; let mut curr_zs = std::iter::once(0).collect::>(); for (digit_idx, valid_zs) in all_valid_zs_rtl.iter_mut().enumerate().rev() { valid_zs.extend(curr_zs.iter().copied()); let mut new_curr_zs = Set::new(); let prev_zs = &all_zs_ltr[digit_idx + 1]; for z in &curr_zs { new_curr_zs.extend(prev_zs.get(z).unwrap().iter().copied()); } curr_zs = new_curr_zs; } all_valid_zs_rtl } fn find_digits>( blocks: impl AsRef, valid_zs: impl AsRef]>, first_digit: Num, attempted_digit_range_ctor: impl Fn(Num) -> DigitRange, get_next_digit: impl Fn(Num) -> Num, can_continue: impl Fn(Num) -> bool, ) -> Output { struct CandidateDigit { z_init: Num, digit: Num, next_digit_attempted: Num, } let blocks = blocks.as_ref(); let valid_zs = valid_zs.as_ref(); let n_digits = blocks.len(); let mut candidates = vec![CandidateDigit { z_init: 0, digit: 0, next_digit_attempted: first_digit, }]; 'find_digits: while candidates.len() >() .join(\"\") } // end::algo[] // tag::pt1[] fn pt1(blocks: impl AsRef, valid_zs: impl AsRef]>) -> Output { find_digits( blocks, valid_zs, 9, |digit| (1..=digit).rev(), |digit| digit - 1, |digit| digit > 1, ) } // end::pt1[] // tag::pt2[] fn pt2(blocks: impl AsRef, valid_zs: impl AsRef]>) -> Output { find_digits( blocks, valid_zs, 1, |digit| digit..=9, |digit| digit + 1, |digit| digit Option { use Operand::*; Some(match s.parse().ok() { Some(val) => Number(val), None => Reg(Register::from_str(s)?), }) } } #[derive(Debug, Clone, Copy)] enum MathOp { Add, Mul, Div, Mod, Eql, } impl MathOp { fn from_str(s: &str) -> Option { use MathOp::*; Some(match s { \"add\" => Add, \"mul\" => Mul, \"div\" => Div, \"mod\" => Mod, \"eql\" => Eql, _ => return None, }) } } #[derive(Debug, Clone)] struct MathInstr { operation: MathOp, register: Register, operand: Operand, } #[derive(Debug)] struct InstrBlock { in_reg: Register, instrs: Vec, } #[derive(Debug, Clone, Copy)] enum Register { W = 0, X, Y, Z, } impl Register { fn from_str(s: &str) -> Option { use Register::*; Some(match s { \"w\" => W, \"x\" => X, \"y\" => Y, \"z\" => Z, _ => return None, }) } } #[derive(Debug)] struct Alu { registers: [Num; 4], } impl Index for Alu { type Output = Num; fn index(&self, register: Register) -> &Self::Output { &self.registers[register as usize] } } impl IndexMut for Alu { fn index_mut(&mut self, register: Register) -> &mut Self::Output { &mut self.registers[register as usize] } } impl Alu { fn new() -> Self { Self { registers: [0; 4] } } fn run_block(&mut self, block: &InstrBlock, input: Num) { use MathOp::*; use Operand::*; self[block.in_reg] = input; for &MathInstr { operation, register, operand, } in &block.instrs { let value = match operand { Number(n) => n, Reg(register) => self[register], }; let r = &mut self[register]; match operation { Add => *r += value, Mul => *r *= value, Div => *r /= value, Mod => *r %= value, Eql => *r = if r == &value { 1 } else { 0 }, } } } fn from_running_block_on( block: &InstrBlock, input: Num, setup: impl FnOnce(&mut Self), ) -> Self { let mut alu = Alu::new(); setup(&mut alu); alu.run_block(block, input); alu } } fn read_input(s: &str) -> Option> { let mut blocks = vec![]; let mut curr_in_reg = None; let mut curr_instrs = vec![]; // Dummy input line at the end that tells the last block it's done for line in s.lines().chain(std::iter::once(\"inp x\")) { let mut splat = line.split_ascii_whitespace(); let instr_str = splat.next()?; if instr_str == \"inp\" { if let Some(r) = curr_in_reg { blocks.push(InstrBlock { in_reg: r, instrs: curr_instrs.clone(), }); } curr_in_reg = Some(Register::from_str(splat.next()?)?); curr_instrs.clear(); } else { let operation = MathOp::from_str(instr_str)?; let register = Register::from_str(splat.next()?)?; let operand = Operand::from_str(splat.next()?)?; curr_instrs.push(MathInstr { operation, register, operand, }); } } Some(blocks) } fn ans_for_input(input: &str) -> Answer { let blocks = read_input(input).unwrap(); let valid_zs = get_valid_zs(&blocks); (24, (pt1(&blocks, &valid_zs), pt2(&blocks, &valid_zs))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::algo[] fn get_valid_zs(blocks: impl AsRef) -> Vec> { let blocks = blocks.as_ref(); let n_digits = blocks.len(); let mut all_zs_ltr = vec![Map::new(); n_digits + 1]; all_zs_ltr.first_mut().unwrap().insert(0, Set::new()); for (digit_idx, block) in blocks.iter().enumerate() { let (all_prev_zs, all_next_zs) = all_zs_ltr.split_at_mut(digit_idx + 1); let prev_zs = &all_prev_zs[all_prev_zs.len() - 1]; let curr_zs = &mut all_next_zs[0]; for &prev_z in prev_zs.keys() { for digit in 1..=9 { let z = Alu::from_running_block_on(block, digit, |alu| alu[Register::Z] = prev_z) [Register::Z]; curr_zs.entry(z).or_insert_with(Set::new).insert(prev_z); } } // tag::debugging[] #[cfg(debug_assertions)] println!(\"{}: {:?}\", digit_idx, curr_zs.len()); // end::debugging[] } let mut all_valid_zs_rtl = vec![Set::new(); n_digits]; let mut curr_zs = std::iter::once(0).collect::>(); for (digit_idx, valid_zs) in all_valid_zs_rtl.iter_mut().enumerate().rev() { valid_zs.extend(curr_zs.iter().copied()); let mut new_curr_zs = Set::new(); let prev_zs = &all_zs_ltr[digit_idx + 1]; for z in &curr_zs { new_curr_zs.extend(prev_zs.get(z).unwrap().iter().copied()); } curr_zs = new_curr_zs; } all_valid_zs_rtl } fn find_digits>( blocks: impl AsRef, valid_zs: impl AsRef]>, first_digit: Num, attempted_digit_range_ctor: impl Fn(Num) -> DigitRange, get_next_digit: impl Fn(Num) -> Num, can_continue: impl Fn(Num) -> bool, ) -> Output { struct CandidateDigit { z_init: Num, digit: Num, next_digit_attempted: Num, } let blocks = blocks.as_ref(); let valid_zs = valid_zs.as_ref(); let n_digits = blocks.len(); let mut candidates = vec![CandidateDigit { z_init: 0, digit: 0, next_digit_attempted: first_digit, }]; 'find_digits: while candidates.len() >() .join(\"\") } // end::algo[] // tag::pt1[] fn pt1(blocks: impl AsRef, valid_zs: impl AsRef]>) -> Output { find_digits( blocks, valid_zs, 9, |digit| (1..=digit).rev(), |digit| digit - 1, |digit| digit > 1, ) } // end::pt1[] // tag::pt2[] fn pt2(blocks: impl AsRef, valid_zs: impl AsRef]>) -> Output { find_digits( blocks, valid_zs, 1, |digit| digit..=9, |digit| digit + 1, |digit| digit Option { use Operand::*; Some(match s.parse().ok() { Some(val) => Number(val), None => Reg(Register::from_str(s)?), }) } } #[derive(Debug, Clone, Copy)] enum MathOp { Add, Mul, Div, Mod, Eql, } impl MathOp { fn from_str(s: &str) -> Option { use MathOp::*; Some(match s { \"add\" => Add, \"mul\" => Mul, \"div\" => Div, \"mod\" => Mod, \"eql\" => Eql, _ => return None, }) } } #[derive(Debug, Clone)] struct MathInstr { operation: MathOp, register: Register, operand: Operand, } #[derive(Debug)] struct InstrBlock { in_reg: Register, instrs: Vec, } #[derive(Debug, Clone, Copy)] enum Register { W = 0, X, Y, Z, } impl Register { fn from_str(s: &str) -> Option { use Register::*; Some(match s { \"w\" => W, \"x\" => X, \"y\" => Y, \"z\" => Z, _ => return None, }) } } #[derive(Debug)] struct Alu { registers: [Num; 4], } impl Index for Alu { type Output = Num; fn index(&self, register: Register) -> &Self::Output { &self.registers[register as usize] } } impl IndexMut for Alu { fn index_mut(&mut self, register: Register) -> &mut Self::Output { &mut self.registers[register as usize] } } impl Alu { fn new() -> Self { Self { registers: [0; 4] } } fn run_block(&mut self, block: &InstrBlock, input: Num) { use MathOp::*; use Operand::*; self[block.in_reg] = input; for &MathInstr { operation, register, operand, } in &block.instrs { let value = match operand { Number(n) => n, Reg(register) => self[register], }; let r = &mut self[register]; match operation { Add => *r += value, Mul => *r *= value, Div => *r /= value, Mod => *r %= value, Eql => *r = if r == &value { 1 } else { 0 }, } } } fn from_running_block_on( block: &InstrBlock, input: Num, setup: impl FnOnce(&mut Self), ) -> Self { let mut alu = Alu::new(); setup(&mut alu); alu.run_block(block, input); alu } } fn read_input(s: &str) -> Option> { let mut blocks = vec![]; let mut curr_in_reg = None; let mut curr_instrs = vec![]; // Dummy input line at the end that tells the last block it's done for line in s.lines().chain(std::iter::once(\"inp x\")) { let mut splat = line.split_ascii_whitespace(); let instr_str = splat.next()?; if instr_str == \"inp\" { if let Some(r) = curr_in_reg { blocks.push(InstrBlock { in_reg: r, instrs: curr_instrs.clone(), }); } curr_in_reg = Some(Register::from_str(splat.next()?)?); curr_instrs.clear(); } else { let operation = MathOp::from_str(instr_str)?; let register = Register::from_str(splat.next()?)?; let operand = Operand::from_str(splat.next()?)?; curr_instrs.push(MathInstr { operation, register, operand, }); } } Some(blocks) } fn ans_for_input(input: &str) -> Answer { let blocks = read_input(input).unwrap(); let valid_zs = get_valid_zs(&blocks); (24, (pt1(&blocks, &valid_zs), pt2(&blocks, &valid_zs))).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::algo[] fn get_valid_zs(blocks: impl AsRef) -> Vec> { let blocks = blocks.as_ref(); let n_digits = blocks.len(); let mut all_zs_ltr = vec![Map::new(); n_digits + 1]; all_zs_ltr.first_mut().unwrap().insert(0, Set::new()); for (digit_idx, block) in blocks.iter().enumerate() { let (all_prev_zs, all_next_zs) = all_zs_ltr.split_at_mut(digit_idx + 1); let prev_zs = &all_prev_zs[all_prev_zs.len() - 1]; let curr_zs = &mut all_next_zs[0]; for &prev_z in prev_zs.keys() { for digit in 1..=9 { let z = Alu::from_running_block_on(block, digit, |alu| alu[Register::Z] = prev_z) [Register::Z]; curr_zs.entry(z).or_insert_with(Set::new).insert(prev_z); } } // tag::debugging[] #[cfg(debug_assertions)] println!(\"{}: {:?}\", digit_idx, curr_zs.len()); // end::debugging[] } let mut all_valid_zs_rtl = vec![Set::new(); n_digits]; let mut curr_zs = std::iter::once(0).collect::>(); for (digit_idx, valid_zs) in all_valid_zs_rtl.iter_mut().enumerate().rev() { valid_zs.extend(curr_zs.iter().copied()); let mut new_curr_zs = Set::new(); let prev_zs = &all_zs_ltr[digit_idx + 1]; for z in &curr_zs { new_curr_zs.extend(prev_zs.get(z).unwrap().iter().copied()); } curr_zs = new_curr_zs; } all_valid_zs_rtl } fn find_digits>( blocks: impl AsRef, valid_zs: impl AsRef]>, first_digit: Num, attempted_digit_range_ctor: impl Fn(Num) -> DigitRange, get_next_digit: impl Fn(Num) -> Num, can_continue: impl Fn(Num) -> bool, ) -> Output { struct CandidateDigit { z_init: Num, digit: Num, next_digit_attempted: Num, } let blocks = blocks.as_ref(); let valid_zs = valid_zs.as_ref(); let n_digits = blocks.len(); let mut candidates = vec![CandidateDigit { z_init: 0, digit: 0, next_digit_attempted: first_digit, }]; 'find_digits: while candidates.len() >() .join(\"\") } // end::algo[] // tag::pt1[] fn pt1(blocks: impl AsRef, valid_zs: impl AsRef]>) -> Output { find_digits( blocks, valid_zs, 9, |digit| (1..=digit).rev(), |digit| digit - 1, |digit| digit > 1, ) } // end::pt1[] // tag::pt2[] fn pt2(blocks: impl AsRef, valid_zs: impl AsRef]>) -> Output { find_digits( blocks, valid_zs, 1, |digit| digit..=9, |digit| digit + 1, |digit| digit < 9, ) } // end::pt2[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { assert!( cfg!(not(debug_assertions)), \"Day 24 may not be tested in debug mode; it requires --release\" ); test_input!(include_str!(\"input.txt\"), day: 24, ans: (\"94992992796199\".to_owned(), \"11931881141161\".to_owned())); } }","title":"Day 24: Arithmetic Logic Unit","component":"ROOT","version":"","name":"soln","url":"/src/day_24/soln","titles":[{"text":"Setup","hash":"_setup","id":1},{"text":"Parts 1 and 2","hash":"_parts_1_and_2","id":2}]},"26":{"id":26,"text":"Day #25 problem description │ Problem input Simple array manipulation. Not interesting! // tag::setup[] use crate::Answer; use std::{collections::BTreeSet as Set, fmt::Write}; #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)] struct Point { row: usize, col: usize, } #[derive(Debug, Clone)] struct SeaGarden { width: usize, height: usize, rights: Set, downs: Set, } // tag::debugging[] impl std::fmt::Display for SeaGarden { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { writeln!(f, \"{} rows × {} cols\", self.width, self.height)?; for row in 0..self.height { for col in 0..self.width { let p = &Point { row, col }; f.write_char(if self.rights.contains(p) { '>' } else if self.downs.contains(p) { 'v' } else { '.' })?; } f.write_char('\\n')?; } Ok(()) } } // end::debugging[] impl SeaGarden { fn from_str(input: &str) -> Self { let mut rights = Set::new(); let mut downs = Set::new(); let mut width = 0; let mut height = 0; for (row, line) in input.lines().enumerate() { height += 1; width = line.chars().count(); for (col, c) in line.chars().enumerate() { let loc = Point { row, col }; match c { '>' => rights.insert(loc), 'v' => downs.insert(loc), '.' => continue, _ => unreachable!(), }; } } Self { width, height, rights, downs, } } fn tick(&mut self) -> bool { let mut any_cucumbers_did_move = false; let mut new_rights = Set::new(); for old_loc @ &Point { row, col } in &self.rights { let new_loc = Point { row, col: (col + 1) % self.width, }; if self.rights.contains(&new_loc) || self.downs.contains(&new_loc) { new_rights.insert(*old_loc); } else { new_rights.insert(new_loc); any_cucumbers_did_move = true; } } let new_rights = new_rights; let mut new_downs = Set::new(); for old_loc @ &Point { row, col } in &self.downs { let new_loc = Point { row: (row + 1) % self.height, col, }; if new_rights.contains(&new_loc) || self.downs.contains(&new_loc) { new_downs.insert(*old_loc); } else { new_downs.insert(new_loc); any_cucumbers_did_move = true; } } self.rights = new_rights; self.downs = new_downs; any_cucumbers_did_move } fn run_until_no_movement(&mut self) -> usize { let mut n = 1; while self.tick() { n += 1; } n } } fn ans_for_input(input: &str) -> Answer { let mut garden = SeaGarden::from_str(input); (25, (pt1(&mut garden), 0)).into() } pub fn ans() -> Answer { ans_for_input(include_str!(\"input.txt\")) } // end::setup[] // tag::pt1[] fn pt1(garden: &mut SeaGarden) -> usize { garden.run_until_no_movement() } // end::pt1[] #[cfg(test)] mod test { use super::*; use crate::test_input; #[test] fn test() { test_input!(include_str!(\"input.txt\"), day: 25, ans: (557, 0)); } }","title":"Day 25: Sea Cucumber","component":"ROOT","version":"","name":"soln","url":"/src/day_25/soln","titles":[{"text":"Setup and Part 1 (there was no Part 2)","hash":"_setup_and_part_1_there_was_no_part_2","id":1}]}},"components":{},"componentVersions":{"ROOT/":{"displayVersion":"default","title":"Solutions","version":"","name":"ROOT","asciidoc":{"attributes":{"env":"site","env-site":"","site-gen":"antora","site-gen-antora":"","attribute-missing":"warn","data-uri":null,"icons":"font","sectanchors":"","source-highlighter":"highlightjs-ext","site-title":"Robert Bennett — Advent of Code 2021","site-url":"/","src-dir":"src","hide-uri-scheme":true,"click-to-reveal":"Click to reveal answer","caution-caption":true,"soln-description-title":"Description of Solution","setup-title":"Setup","part-title":"Part","page-pagination":true,"link-sep":"│"},"sourcemap":false,"extensions":[{}]},"url":"/","navigation":[{"items":[{"content":"Day 1: Sonar Sweep","url":"/src/day_01/soln","urlType":"internal"},{"content":"Day 2: Dive!","url":"/src/day_02/soln","urlType":"internal"},{"content":"Day 3: Binary Diagnostic","url":"/src/day_03/soln","urlType":"internal"},{"content":"Day 4: Giant Squid","url":"/src/day_04/soln","urlType":"internal"},{"content":"Day 5: Hydrothermal Venture","url":"/src/day_05/soln","urlType":"internal"},{"content":"Day 6: Lanternfish","url":"/src/day_06/soln","urlType":"internal"},{"content":"Day 7: The Treachery of Whales","url":"/src/day_07/soln","urlType":"internal"},{"content":"Day 8: Seven Segment Search","url":"/src/day_08/soln","urlType":"internal"},{"content":"Day 9: Smoke Basin","url":"/src/day_09/soln","urlType":"internal"},{"content":"Day 10: Syntax Scoring","url":"/src/day_10/soln","urlType":"internal"},{"content":"Day 11: Dumbo Octopus","url":"/src/day_11/soln","urlType":"internal"},{"content":"Day 12: Passage Pathing","url":"/src/day_12/soln","urlType":"internal"},{"content":"Day 13: Transparent Origami","url":"/src/day_13/soln","urlType":"internal"},{"content":"Day 14: Extended Polymerization","url":"/src/day_14/soln","urlType":"internal"},{"content":"Day 15: Chiton","url":"/src/day_15/soln","urlType":"internal"},{"content":"Day 16: Packet Decoder","url":"/src/day_16/soln","urlType":"internal"},{"content":"Day 17: Trick Shot","url":"/src/day_17/soln","urlType":"internal"},{"content":"Day 18: Snailfish","url":"/src/day_18/soln","urlType":"internal"},{"content":"Day 19: Beacon Scanner","url":"/src/day_19/soln","urlType":"internal"},{"content":"Day 20: Trench Map","url":"/src/day_20/soln","urlType":"internal"},{"content":"Day 21: Dirac Dice","url":"/src/day_21/soln","urlType":"internal"},{"content":"Day 22: Reactor Reboot","url":"/src/day_22/soln","urlType":"internal"},{"content":"Day 23: Amphipod","url":"/src/day_23/soln","urlType":"internal"},{"content":"Day 24: Arithmetic Logic Unit","url":"/src/day_24/soln","urlType":"internal"},{"content":"Day 25: Sea Cucumber","url":"/src/day_25/soln","urlType":"internal"}],"root":true,"order":0}]}}}})