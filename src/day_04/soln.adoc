= Giant Squid

:day-num: 4
{external-link-left-delim}link:{advent-day-url-stem}{day-num}[{external-link}]{external-link-right-delim}

.Setup
The game is represented as a list of boards and a list of drawn numbers.
Each board has:

. A dictionary that maps undrawn numbers on the board to their Cartesian coordinates (a pair `(row, col)`) on the board.
When a number is drawn, its Cartesian coordinates are used to update `progress` (below), and then the number is removed from the dictionary.
. A `progress` object that stores, for each row and column, the count of numbers in that row/column have not yet been drawn.
If one of those counts hit zero, then every number in the row/column has been drawn, and so the board has a "Bingo".
+
The row and column indices have the same meaning as the Cartesian coordinates in the dictionary described above: if number 25 is drawn, and 25's position on a particular board is `(2, 3)`, then `progress.rows[2]` and `progress.cols[3]` each get decremented.

Reading the input text into a game (numbers and boards) is in `read_input_into_game`, whose implementation should serve as its docs.
`get_answer_from_final_game_state` is just used to prove to Advent of Code that we actually got the solution.

[sidebar]
====
In particular, the choice to remove drawn numbers from a board's dictionary was made to make this answer easy to compute, as Advent of Code asks for the sum of the board's undrawn numbers.
The way we've structured things, a board's undrawn numbers will be the remaining keys in this dictionary when the board gets "Bingo".
====

[source,julia,indent=0]
----
include::soln.jl[tag=setup,indent=3]
----

.{part-title} 1
We simply draw numbers until a board has won, then get the answer.

[source,julia,indent=0]
----
include::soln.jl[tag=pt1,indent=3]
----

.{part-title} 2
This time, we keep track of all of the boards that haven't won yet.
When last un-won boards wins, we use it compute the answer.

[source,julia,indent=0]
----
include::soln.jl[tag=pt2,indent=3]
----
